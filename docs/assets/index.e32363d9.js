const Kb=function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))i(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const o of s.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&i(o)}).observe(document,{childList:!0,subtree:!0});function t(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerpolicy&&(s.referrerPolicy=r.referrerpolicy),r.crossorigin==="use-credentials"?s.credentials="include":r.crossorigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function i(r){if(r.ep)return;r.ep=!0;const s=t(r);fetch(r.href,s)}};Kb();/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const s0="140",Zb=0,jv=1,Jb=2,MS=1,Qb=2,cc=3,Xa=0,Bi=1,po=2,SS=1,hs=0,Fa=1,Om=2,qv=3,Yv=4,eT=5,ma=100,tT=101,nT=102,Kv=103,Zv=104,iT=200,rT=201,sT=202,oT=203,wS=204,ES=205,aT=206,lT=207,cT=208,uT=209,hT=210,dT=0,fT=1,pT=2,Bm=3,mT=4,gT=5,vT=6,_T=7,Wd=0,xT=1,yT=2,Ar=0,MT=1,ST=2,wT=3,ET=4,bT=5,bS=300,ja=301,qa=302,zm=303,km=304,$d=306,Ya=1e3,ci=1001,hd=1002,$t=1003,Hm=1004,Gm=1005,mn=1006,TS=1007,_l=1008,mo=1009,TT=1010,AT=1011,Nc=1012,CT=1013,Xh=1014,ls=1015,Fc=1016,RT=1017,LT=1018,Ua=1020,PT=1021,DT=1022,ui=1023,IT=1024,NT=1025,oo=1026,Ka=1027,FT=1028,UT=1029,OT=1030,BT=1031,zT=1033,Nf=33776,Ff=33777,Uf=33778,Of=33779,Jv=35840,Qv=35841,e_=35842,t_=35843,kT=36196,n_=37492,i_=37496,r_=37808,s_=37809,o_=37810,a_=37811,l_=37812,c_=37813,u_=37814,h_=37815,d_=37816,f_=37817,p_=37818,m_=37819,g_=37820,v_=37821,__=36492,HT=2200,GT=2201,VT=2202,Uc=2300,Za=2301,Bf=2302,_a=2400,xa=2401,dd=2402,o0=2500,AS=2501,WT=0,$T=1,CS=2,bs=3e3,it=3001,XT=3200,jT=3201,bo=0,qT=1,_r="srgb",eo="srgb-linear",zf=7680,YT=519,Oc=35044,fd=35048,x_="300 es",Vm=1035;class To{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[e]===void 0&&(i[e]=[]),i[e].indexOf(t)===-1&&i[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const i=this._listeners;return i[e]!==void 0&&i[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const r=this._listeners[e];if(r!==void 0){const s=r.indexOf(t);s!==-1&&r.splice(s,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const i=this._listeners[e.type];if(i!==void 0){e.target=this;const r=i.slice(0);for(let s=0,o=r.length;s<o;s++)r[s].call(this,e);e.target=null}}}const en=[];for(let n=0;n<256;n++)en[n]=(n<16?"0":"")+n.toString(16);let y_=1234567;const Mc=Math.PI/180,Bc=180/Math.PI;function di(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(en[n&255]+en[n>>8&255]+en[n>>16&255]+en[n>>24&255]+"-"+en[e&255]+en[e>>8&255]+"-"+en[e>>16&15|64]+en[e>>24&255]+"-"+en[t&63|128]+en[t>>8&255]+"-"+en[t>>16&255]+en[t>>24&255]+en[i&255]+en[i>>8&255]+en[i>>16&255]+en[i>>24&255]).toLowerCase()}function rn(n,e,t){return Math.max(e,Math.min(t,n))}function a0(n,e){return(n%e+e)%e}function KT(n,e,t,i,r){return i+(n-e)*(r-i)/(t-e)}function ZT(n,e,t){return n!==e?(t-n)/(e-n):0}function Sc(n,e,t){return(1-t)*n+t*e}function JT(n,e,t,i){return Sc(n,e,1-Math.exp(-t*i))}function QT(n,e=1){return e-Math.abs(a0(n,e*2)-e)}function eA(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))}function tA(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))}function nA(n,e){return n+Math.floor(Math.random()*(e-n+1))}function iA(n,e){return n+Math.random()*(e-n)}function rA(n){return n*(.5-Math.random())}function sA(n){n!==void 0&&(y_=n);let e=y_+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function oA(n){return n*Mc}function aA(n){return n*Bc}function Wm(n){return(n&n-1)===0&&n!==0}function RS(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function pd(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function lA(n,e,t,i,r){const s=Math.cos,o=Math.sin,a=s(t/2),l=o(t/2),c=s((e+i)/2),u=o((e+i)/2),h=s((e-i)/2),d=o((e-i)/2),p=s((i-e)/2),v=o((i-e)/2);switch(r){case"XYX":n.set(a*u,l*h,l*d,a*c);break;case"YZY":n.set(l*d,a*u,l*h,a*c);break;case"ZXZ":n.set(l*h,l*d,a*u,a*c);break;case"XZX":n.set(a*u,l*v,l*p,a*c);break;case"YXY":n.set(l*p,a*u,l*v,a*c);break;case"ZYZ":n.set(l*v,l*p,a*u,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}function cA(n,e){switch(e.constructor){case Float32Array:return n;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function uA(n,e){switch(e.constructor){case Float32Array:return n;case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}var Ze=Object.freeze({__proto__:null,DEG2RAD:Mc,RAD2DEG:Bc,generateUUID:di,clamp:rn,euclideanModulo:a0,mapLinear:KT,inverseLerp:ZT,lerp:Sc,damp:JT,pingpong:QT,smoothstep:eA,smootherstep:tA,randInt:nA,randFloat:iA,randFloatSpread:rA,seededRandom:sA,degToRad:oA,radToDeg:aA,isPowerOfTwo:Wm,ceilPowerOfTwo:RS,floorPowerOfTwo:pd,setQuaternionFromProperEuler:lA,normalize:uA,denormalize:cA});class fe{constructor(e=0,t=0){this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,i=this.y,r=e.elements;return this.x=r[0]*t+r[3]*i+r[6],this.y=r[1]*t+r[4]*i+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y;return t*t+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,i){return i!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const i=Math.cos(t),r=Math.sin(t),s=this.x-e.x,o=this.y-e.y;return this.x=s*i-o*r+e.x,this.y=s*r+o*i+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}fe.prototype.isVector2=!0;class sn{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,i,r,s,o,a,l,c){const u=this.elements;return u[0]=e,u[1]=r,u[2]=a,u[3]=t,u[4]=s,u[5]=l,u[6]=i,u[7]=o,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],this}extractBasis(e,t,i){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,r=t.elements,s=this.elements,o=i[0],a=i[3],l=i[6],c=i[1],u=i[4],h=i[7],d=i[2],p=i[5],v=i[8],m=r[0],f=r[3],g=r[6],_=r[1],M=r[4],E=r[7],S=r[2],T=r[5],R=r[8];return s[0]=o*m+a*_+l*S,s[3]=o*f+a*M+l*T,s[6]=o*g+a*E+l*R,s[1]=c*m+u*_+h*S,s[4]=c*f+u*M+h*T,s[7]=c*g+u*E+h*R,s[2]=d*m+p*_+v*S,s[5]=d*f+p*M+v*T,s[8]=d*g+p*E+v*R,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8];return t*o*u-t*a*c-i*s*u+i*a*l+r*s*c-r*o*l}invert(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=u*o-a*c,d=a*l-u*s,p=c*s-o*l,v=t*h+i*d+r*p;if(v===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/v;return e[0]=h*m,e[1]=(r*c-u*i)*m,e[2]=(a*i-r*o)*m,e[3]=d*m,e[4]=(u*t-r*l)*m,e[5]=(r*s-a*t)*m,e[6]=p*m,e[7]=(i*l-c*t)*m,e[8]=(o*t-i*s)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,i,r,s,o,a){const l=Math.cos(s),c=Math.sin(s);return this.set(i*l,i*c,-i*(l*o+c*a)+o+e,-r*c,r*l,-r*(-c*o+l*a)+a+t,0,0,1),this}scale(e,t){const i=this.elements;return i[0]*=e,i[3]*=e,i[6]*=e,i[1]*=t,i[4]*=t,i[7]*=t,this}rotate(e){const t=Math.cos(e),i=Math.sin(e),r=this.elements,s=r[0],o=r[3],a=r[6],l=r[1],c=r[4],u=r[7];return r[0]=t*s+i*l,r[3]=t*o+i*c,r[6]=t*a+i*u,r[1]=-i*s+t*l,r[4]=-i*o+t*c,r[7]=-i*a+t*u,this}translate(e,t){const i=this.elements;return i[0]+=e*i[2],i[3]+=e*i[5],i[6]+=e*i[8],i[1]+=t*i[2],i[4]+=t*i[5],i[7]+=t*i[8],this}equals(e){const t=this.elements,i=e.elements;for(let r=0;r<9;r++)if(t[r]!==i[r])return!1;return!0}fromArray(e,t=0){for(let i=0;i<9;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e}clone(){return new this.constructor().fromArray(this.elements)}}sn.prototype.isMatrix3=!0;function LS(n){for(let e=n.length-1;e>=0;--e)if(n[e]>65535)return!0;return!1}function zc(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function ao(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function jh(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}const kf={[_r]:{[eo]:ao},[eo]:{[_r]:jh}},Mi={legacyMode:!0,get workingColorSpace(){return eo},set workingColorSpace(n){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(n,e,t){if(this.legacyMode||e===t||!e||!t)return n;if(kf[e]&&kf[e][t]!==void 0){const i=kf[e][t];return n.r=i(n.r),n.g=i(n.g),n.b=i(n.b),n}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(n,e){return this.convert(n,this.workingColorSpace,e)},toWorkingColorSpace:function(n,e){return this.convert(n,e,this.workingColorSpace)}},PS={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Gt={r:0,g:0,b:0},Si={h:0,s:0,l:0},Ru={h:0,s:0,l:0};function Hf(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}function Lu(n,e){return e.r=n.r,e.g=n.g,e.b=n.b,e}class we{constructor(e,t,i){return t===void 0&&i===void 0?this.set(e):this.setRGB(e,t,i)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=_r){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Mi.toWorkingColorSpace(this,t),this}setRGB(e,t,i,r=eo){return this.r=e,this.g=t,this.b=i,Mi.toWorkingColorSpace(this,r),this}setHSL(e,t,i,r=eo){if(e=a0(e,1),t=rn(t,0,1),i=rn(i,0,1),t===0)this.r=this.g=this.b=i;else{const s=i<=.5?i*(1+t):i+t-i*t,o=2*i-s;this.r=Hf(o,s,e+1/3),this.g=Hf(o,s,e),this.b=Hf(o,s,e-1/3)}return Mi.toWorkingColorSpace(this,r),this}setStyle(e,t=_r){function i(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let r;if(r=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let s;const o=r[1],a=r[2];switch(o){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(s[1],10))/255,this.g=Math.min(255,parseInt(s[2],10))/255,this.b=Math.min(255,parseInt(s[3],10))/255,Mi.toWorkingColorSpace(this,t),i(s[4]),this;if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(s[1],10))/100,this.g=Math.min(100,parseInt(s[2],10))/100,this.b=Math.min(100,parseInt(s[3],10))/100,Mi.toWorkingColorSpace(this,t),i(s[4]),this;break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){const l=parseFloat(s[1])/360,c=parseInt(s[2],10)/100,u=parseInt(s[3],10)/100;return i(s[4]),this.setHSL(l,c,u,t)}break}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(e)){const s=r[1],o=s.length;if(o===3)return this.r=parseInt(s.charAt(0)+s.charAt(0),16)/255,this.g=parseInt(s.charAt(1)+s.charAt(1),16)/255,this.b=parseInt(s.charAt(2)+s.charAt(2),16)/255,Mi.toWorkingColorSpace(this,t),this;if(o===6)return this.r=parseInt(s.charAt(0)+s.charAt(1),16)/255,this.g=parseInt(s.charAt(2)+s.charAt(3),16)/255,this.b=parseInt(s.charAt(4)+s.charAt(5),16)/255,Mi.toWorkingColorSpace(this,t),this}return e&&e.length>0?this.setColorName(e,t):this}setColorName(e,t=_r){const i=PS[e.toLowerCase()];return i!==void 0?this.setHex(i,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=ao(e.r),this.g=ao(e.g),this.b=ao(e.b),this}copyLinearToSRGB(e){return this.r=jh(e.r),this.g=jh(e.g),this.b=jh(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=_r){return Mi.fromWorkingColorSpace(Lu(this,Gt),e),rn(Gt.r*255,0,255)<<16^rn(Gt.g*255,0,255)<<8^rn(Gt.b*255,0,255)<<0}getHexString(e=_r){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=eo){Mi.fromWorkingColorSpace(Lu(this,Gt),t);const i=Gt.r,r=Gt.g,s=Gt.b,o=Math.max(i,r,s),a=Math.min(i,r,s);let l,c;const u=(a+o)/2;if(a===o)l=0,c=0;else{const h=o-a;switch(c=u<=.5?h/(o+a):h/(2-o-a),o){case i:l=(r-s)/h+(r<s?6:0);break;case r:l=(s-i)/h+2;break;case s:l=(i-r)/h+4;break}l/=6}return e.h=l,e.s=c,e.l=u,e}getRGB(e,t=eo){return Mi.fromWorkingColorSpace(Lu(this,Gt),t),e.r=Gt.r,e.g=Gt.g,e.b=Gt.b,e}getStyle(e=_r){return Mi.fromWorkingColorSpace(Lu(this,Gt),e),e!==_r?`color(${e} ${Gt.r} ${Gt.g} ${Gt.b})`:`rgb(${Gt.r*255|0},${Gt.g*255|0},${Gt.b*255|0})`}offsetHSL(e,t,i){return this.getHSL(Si),Si.h+=e,Si.s+=t,Si.l+=i,this.setHSL(Si.h,Si.s,Si.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,i){return this.r=e.r+(t.r-e.r)*i,this.g=e.g+(t.g-e.g)*i,this.b=e.b+(t.b-e.b)*i,this}lerpHSL(e,t){this.getHSL(Si),e.getHSL(Ru);const i=Sc(Si.h,Ru.h,t),r=Sc(Si.s,Ru.s,t),s=Sc(Si.l,Ru.l,t);return this.setHSL(i,r,s),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}we.NAMES=PS;we.prototype.isColor=!0;we.prototype.r=1;we.prototype.g=1;we.prototype.b=1;let Io;class Ao{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement=="undefined")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{Io===void 0&&(Io=zc("canvas")),Io.width=e.width,Io.height=e.height;const i=Io.getContext("2d");e instanceof ImageData?i.putImageData(e,0,0):i.drawImage(e,0,0,e.width,e.height),t=Io}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement!="undefined"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&e instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&e instanceof ImageBitmap){const t=zc("canvas");t.width=e.width,t.height=e.height;const i=t.getContext("2d");i.drawImage(e,0,0,e.width,e.height);const r=i.getImageData(0,0,e.width,e.height),s=r.data;for(let o=0;o<s.length;o++)s[o]=ao(s[o]/255)*255;return i.putImageData(r,0,0),t}else if(e.data){const t=e.data.slice(0);for(let i=0;i<t.length;i++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[i]=Math.floor(ao(t[i]/255)*255):t[i]=ao(t[i]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}class DS{constructor(e=null){this.uuid=di(),this.data=e,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const i={uuid:this.uuid,url:""},r=this.data;if(r!==null){let s;if(Array.isArray(r)){s=[];for(let o=0,a=r.length;o<a;o++)r[o].isDataTexture?s.push(Gf(r[o].image)):s.push(Gf(r[o]))}else s=Gf(r);i.url=s}return t||(e.images[this.uuid]=i),i}}function Gf(n){return typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&n instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&n instanceof ImageBitmap?Ao.getDataURL(n):n.data?{data:Array.prototype.slice.call(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}DS.prototype.isSource=!0;let hA=0;class Ht extends To{constructor(e=Ht.DEFAULT_IMAGE,t=Ht.DEFAULT_MAPPING,i=ci,r=ci,s=mn,o=_l,a=ui,l=mo,c=1,u=bs){super(),Object.defineProperty(this,"id",{value:hA++}),this.uuid=di(),this.name="",this.source=new DS(e),this.mipmaps=[],this.mapping=t,this.wrapS=i,this.wrapT=r,this.magFilter=s,this.minFilter=o,this.anisotropy=c,this.format=a,this.internalFormat=null,this.type=l,this.offset=new fe(0,0),this.repeat=new fe(1,1),this.center=new fe(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new sn,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=u,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const i={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),t||(e.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==bS)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Ya:e.x=e.x-Math.floor(e.x);break;case ci:e.x=e.x<0?0:1;break;case hd:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Ya:e.y=e.y-Math.floor(e.y);break;case ci:e.y=e.y<0?0:1;break;case hd:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}}Ht.DEFAULT_IMAGE=null;Ht.DEFAULT_MAPPING=bS;Ht.prototype.isTexture=!0;class ut{constructor(e=0,t=0,i=0,r=1){this.x=e,this.y=t,this.z=i,this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,i,r){return this.x=e,this.y=t,this.z=i,this.w=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,i=this.y,r=this.z,s=this.w,o=e.elements;return this.x=o[0]*t+o[4]*i+o[8]*r+o[12]*s,this.y=o[1]*t+o[5]*i+o[9]*r+o[13]*s,this.z=o[2]*t+o[6]*i+o[10]*r+o[14]*s,this.w=o[3]*t+o[7]*i+o[11]*r+o[15]*s,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,i,r,s;const l=e.elements,c=l[0],u=l[4],h=l[8],d=l[1],p=l[5],v=l[9],m=l[2],f=l[6],g=l[10];if(Math.abs(u-d)<.01&&Math.abs(h-m)<.01&&Math.abs(v-f)<.01){if(Math.abs(u+d)<.1&&Math.abs(h+m)<.1&&Math.abs(v+f)<.1&&Math.abs(c+p+g-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const M=(c+1)/2,E=(p+1)/2,S=(g+1)/2,T=(u+d)/4,R=(h+m)/4,x=(v+f)/4;return M>E&&M>S?M<.01?(i=0,r=.707106781,s=.707106781):(i=Math.sqrt(M),r=T/i,s=R/i):E>S?E<.01?(i=.707106781,r=0,s=.707106781):(r=Math.sqrt(E),i=T/r,s=x/r):S<.01?(i=.707106781,r=.707106781,s=0):(s=Math.sqrt(S),i=R/s,r=x/s),this.set(i,r,s,t),this}let _=Math.sqrt((f-v)*(f-v)+(h-m)*(h-m)+(d-u)*(d-u));return Math.abs(_)<.001&&(_=1),this.x=(f-v)/_,this.y=(h-m)/_,this.z=(d-u)/_,this.w=Math.acos((c+p+g-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this.w=e.w+(t.w-e.w)*i,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,i){return i!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}ut.prototype.isVector4=!0;class on extends To{constructor(e,t,i={}){super(),this.width=e,this.height=t,this.depth=1,this.scissor=new ut(0,0,e,t),this.scissorTest=!1,this.viewport=new ut(0,0,e,t);const r={width:e,height:t,depth:1};this.texture=new Ht(r,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=i.generateMipmaps!==void 0?i.generateMipmaps:!1,this.texture.internalFormat=i.internalFormat!==void 0?i.internalFormat:null,this.texture.minFilter=i.minFilter!==void 0?i.minFilter:mn,this.depthBuffer=i.depthBuffer!==void 0?i.depthBuffer:!0,this.stencilBuffer=i.stencilBuffer!==void 0?i.stencilBuffer:!1,this.depthTexture=i.depthTexture!==void 0?i.depthTexture:null,this.samples=i.samples!==void 0?i.samples:0}setSize(e,t,i=1){(this.width!==e||this.height!==t||this.depth!==i)&&(this.width=e,this.height=t,this.depth=i,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=i,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0,this.texture.image=Object.assign({},e.texture.image),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}on.prototype.isWebGLRenderTarget=!0;class Xd extends Ht{constructor(e=null,t=1,i=1,r=1){super(null),this.image={data:e,width:t,height:i,depth:r},this.magFilter=$t,this.minFilter=$t,this.wrapR=ci,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}Xd.prototype.isDataArrayTexture=!0;class dA extends on{constructor(e,t,i){super(e,t),this.depth=i,this.texture=new Xd(null,e,t,i),this.texture.isRenderTargetTexture=!0}}dA.prototype.isWebGLArrayRenderTarget=!0;class l0 extends Ht{constructor(e=null,t=1,i=1,r=1){super(null),this.image={data:e,width:t,height:i,depth:r},this.magFilter=$t,this.minFilter=$t,this.wrapR=ci,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}l0.prototype.isData3DTexture=!0;class fA extends on{constructor(e,t,i){super(e,t),this.depth=i,this.texture=new l0(null,e,t,i),this.texture.isRenderTargetTexture=!0}}fA.prototype.isWebGL3DRenderTarget=!0;class pA extends on{constructor(e,t,i,r={}){super(e,t,r);const s=this.texture;this.texture=[];for(let o=0;o<i;o++)this.texture[o]=s.clone(),this.texture[o].isRenderTargetTexture=!0}setSize(e,t,i=1){if(this.width!==e||this.height!==t||this.depth!==i){this.width=e,this.height=t,this.depth=i;for(let r=0,s=this.texture.length;r<s;r++)this.texture[r].image.width=e,this.texture[r].image.height=t,this.texture[r].image.depth=i;this.dispose()}return this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t),this}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.texture.length=0;for(let t=0,i=e.texture.length;t<i;t++)this.texture[t]=e.texture[t].clone(),this.texture[t].isRenderTargetTexture=!0;return this}}pA.prototype.isWebGLMultipleRenderTargets=!0;class bn{constructor(e=0,t=0,i=0,r=1){this._x=e,this._y=t,this._z=i,this._w=r}static slerp(e,t,i,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),i.slerpQuaternions(e,t,r)}static slerpFlat(e,t,i,r,s,o,a){let l=i[r+0],c=i[r+1],u=i[r+2],h=i[r+3];const d=s[o+0],p=s[o+1],v=s[o+2],m=s[o+3];if(a===0){e[t+0]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h;return}if(a===1){e[t+0]=d,e[t+1]=p,e[t+2]=v,e[t+3]=m;return}if(h!==m||l!==d||c!==p||u!==v){let f=1-a;const g=l*d+c*p+u*v+h*m,_=g>=0?1:-1,M=1-g*g;if(M>Number.EPSILON){const S=Math.sqrt(M),T=Math.atan2(S,g*_);f=Math.sin(f*T)/S,a=Math.sin(a*T)/S}const E=a*_;if(l=l*f+d*E,c=c*f+p*E,u=u*f+v*E,h=h*f+m*E,f===1-a){const S=1/Math.sqrt(l*l+c*c+u*u+h*h);l*=S,c*=S,u*=S,h*=S}}e[t]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h}static multiplyQuaternionsFlat(e,t,i,r,s,o){const a=i[r],l=i[r+1],c=i[r+2],u=i[r+3],h=s[o],d=s[o+1],p=s[o+2],v=s[o+3];return e[t]=a*v+u*h+l*p-c*d,e[t+1]=l*v+u*d+c*h-a*p,e[t+2]=c*v+u*p+a*d-l*h,e[t+3]=u*v-a*h-l*d-c*p,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,i,r){return this._x=e,this._y=t,this._z=i,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=e._x,r=e._y,s=e._z,o=e._order,a=Math.cos,l=Math.sin,c=a(i/2),u=a(r/2),h=a(s/2),d=l(i/2),p=l(r/2),v=l(s/2);switch(o){case"XYZ":this._x=d*u*h+c*p*v,this._y=c*p*h-d*u*v,this._z=c*u*v+d*p*h,this._w=c*u*h-d*p*v;break;case"YXZ":this._x=d*u*h+c*p*v,this._y=c*p*h-d*u*v,this._z=c*u*v-d*p*h,this._w=c*u*h+d*p*v;break;case"ZXY":this._x=d*u*h-c*p*v,this._y=c*p*h+d*u*v,this._z=c*u*v+d*p*h,this._w=c*u*h-d*p*v;break;case"ZYX":this._x=d*u*h-c*p*v,this._y=c*p*h+d*u*v,this._z=c*u*v-d*p*h,this._w=c*u*h+d*p*v;break;case"YZX":this._x=d*u*h+c*p*v,this._y=c*p*h+d*u*v,this._z=c*u*v-d*p*h,this._w=c*u*h-d*p*v;break;case"XZY":this._x=d*u*h-c*p*v,this._y=c*p*h-d*u*v,this._z=c*u*v+d*p*h,this._w=c*u*h+d*p*v;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const i=t/2,r=Math.sin(i);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,i=t[0],r=t[4],s=t[8],o=t[1],a=t[5],l=t[9],c=t[2],u=t[6],h=t[10],d=i+a+h;if(d>0){const p=.5/Math.sqrt(d+1);this._w=.25/p,this._x=(u-l)*p,this._y=(s-c)*p,this._z=(o-r)*p}else if(i>a&&i>h){const p=2*Math.sqrt(1+i-a-h);this._w=(u-l)/p,this._x=.25*p,this._y=(r+o)/p,this._z=(s+c)/p}else if(a>h){const p=2*Math.sqrt(1+a-i-h);this._w=(s-c)/p,this._x=(r+o)/p,this._y=.25*p,this._z=(l+u)/p}else{const p=2*Math.sqrt(1+h-i-a);this._w=(o-r)/p,this._x=(s+c)/p,this._y=(l+u)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let i=e.dot(t)+1;return i<Number.EPSILON?(i=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=i):(this._x=0,this._y=-e.z,this._z=e.y,this._w=i)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=i),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(rn(this.dot(e),-1,1)))}rotateTowards(e,t){const i=this.angleTo(e);if(i===0)return this;const r=Math.min(1,t/i);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const i=e._x,r=e._y,s=e._z,o=e._w,a=t._x,l=t._y,c=t._z,u=t._w;return this._x=i*u+o*a+r*c-s*l,this._y=r*u+o*l+s*a-i*c,this._z=s*u+o*c+i*l-r*a,this._w=o*u-i*a-r*l-s*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const i=this._x,r=this._y,s=this._z,o=this._w;let a=o*e._w+i*e._x+r*e._y+s*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=i,this._y=r,this._z=s,this;const l=1-a*a;if(l<=Number.EPSILON){const p=1-t;return this._w=p*o+t*this._w,this._x=p*i+t*this._x,this._y=p*r+t*this._y,this._z=p*s+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),u=Math.atan2(c,a),h=Math.sin((1-t)*u)/c,d=Math.sin(t*u)/c;return this._w=o*h+this._w*d,this._x=i*h+this._x*d,this._y=r*h+this._y*d,this._z=s*h+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,i){return this.copy(e).slerp(t,i)}random(){const e=Math.random(),t=Math.sqrt(1-e),i=Math.sqrt(e),r=2*Math.PI*Math.random(),s=2*Math.PI*Math.random();return this.set(t*Math.cos(r),i*Math.sin(s),i*Math.cos(s),t*Math.sin(r))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}bn.prototype.isQuaternion=!0;class B{constructor(e=0,t=0,i=0){this.x=e,this.y=t,this.z=i}set(e,t,i){return i===void 0&&(i=this.z),this.x=e,this.y=t,this.z=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(M_.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(M_.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,i=this.y,r=this.z,s=e.elements;return this.x=s[0]*t+s[3]*i+s[6]*r,this.y=s[1]*t+s[4]*i+s[7]*r,this.z=s[2]*t+s[5]*i+s[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,i=this.y,r=this.z,s=e.elements,o=1/(s[3]*t+s[7]*i+s[11]*r+s[15]);return this.x=(s[0]*t+s[4]*i+s[8]*r+s[12])*o,this.y=(s[1]*t+s[5]*i+s[9]*r+s[13])*o,this.z=(s[2]*t+s[6]*i+s[10]*r+s[14])*o,this}applyQuaternion(e){const t=this.x,i=this.y,r=this.z,s=e.x,o=e.y,a=e.z,l=e.w,c=l*t+o*r-a*i,u=l*i+a*t-s*r,h=l*r+s*i-o*t,d=-s*t-o*i-a*r;return this.x=c*l+d*-s+u*-a-h*-o,this.y=u*l+d*-o+h*-s-c*-a,this.z=h*l+d*-a+c*-o-u*-s,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,i=this.y,r=this.z,s=e.elements;return this.x=s[0]*t+s[4]*i+s[8]*r,this.y=s[1]*t+s[5]*i+s[9]*r,this.z=s[2]*t+s[6]*i+s[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const i=e.x,r=e.y,s=e.z,o=t.x,a=t.y,l=t.z;return this.x=r*l-s*a,this.y=s*o-i*l,this.z=i*a-r*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const i=e.dot(this)/t;return this.copy(e).multiplyScalar(i)}projectOnPlane(e){return Vf.copy(this).projectOnVector(e),this.sub(Vf)}reflect(e){return this.sub(Vf.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const i=this.dot(e)/t;return Math.acos(rn(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y,r=this.z-e.z;return t*t+i*i+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,i){const r=Math.sin(t)*e;return this.x=r*Math.sin(i),this.y=Math.cos(t)*e,this.z=r*Math.cos(i),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,i){return this.x=e*Math.sin(t),this.y=i,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),i=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=i,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,i){return i!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,i=Math.sqrt(1-e**2);return this.x=i*Math.cos(t),this.y=i*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}B.prototype.isVector3=!0;const Vf=new B,M_=new bn;class Mn{constructor(e=new B(1/0,1/0,1/0),t=new B(-1/0,-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,i=1/0,r=1/0,s=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.length;l<c;l+=3){const u=e[l],h=e[l+1],d=e[l+2];u<t&&(t=u),h<i&&(i=h),d<r&&(r=d),u>s&&(s=u),h>o&&(o=h),d>a&&(a=d)}return this.min.set(t,i,r),this.max.set(s,o,a),this}setFromBufferAttribute(e){let t=1/0,i=1/0,r=1/0,s=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.count;l<c;l++){const u=e.getX(l),h=e.getY(l),d=e.getZ(l);u<t&&(t=u),h<i&&(i=h),d<r&&(r=d),u>s&&(s=u),h>o&&(o=h),d>a&&(a=d)}return this.min.set(t,i,r),this.max.set(s,o,a),this}setFromPoints(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const i=ks.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(i),this.max.copy(e).add(i),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const i=e.geometry;if(i!==void 0)if(t&&i.attributes!=null&&i.attributes.position!==void 0){const s=i.attributes.position;for(let o=0,a=s.count;o<a;o++)ks.fromBufferAttribute(s,o).applyMatrix4(e.matrixWorld),this.expandByPoint(ks)}else i.boundingBox===null&&i.computeBoundingBox(),Wf.copy(i.boundingBox),Wf.applyMatrix4(e.matrixWorld),this.union(Wf);const r=e.children;for(let s=0,o=r.length;s<o;s++)this.expandByObject(r[s],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,ks),ks.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,i;return e.normal.x>0?(t=e.normal.x*this.min.x,i=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,i=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,i+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,i+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,i+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,i+=e.normal.z*this.min.z),t<=-e.constant&&i>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Bl),Pu.subVectors(this.max,Bl),No.subVectors(e.a,Bl),Fo.subVectors(e.b,Bl),Uo.subVectors(e.c,Bl),Br.subVectors(Fo,No),zr.subVectors(Uo,Fo),Hs.subVectors(No,Uo);let t=[0,-Br.z,Br.y,0,-zr.z,zr.y,0,-Hs.z,Hs.y,Br.z,0,-Br.x,zr.z,0,-zr.x,Hs.z,0,-Hs.x,-Br.y,Br.x,0,-zr.y,zr.x,0,-Hs.y,Hs.x,0];return!$f(t,No,Fo,Uo,Pu)||(t=[1,0,0,0,1,0,0,0,1],!$f(t,No,Fo,Uo,Pu))?!1:(Du.crossVectors(Br,zr),t=[Du.x,Du.y,Du.z],$f(t,No,Fo,Uo,Pu))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return ks.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=this.getSize(ks).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(rr[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),rr[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),rr[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),rr[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),rr[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),rr[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),rr[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),rr[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(rr),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}Mn.prototype.isBox3=!0;const rr=[new B,new B,new B,new B,new B,new B,new B,new B],ks=new B,Wf=new Mn,No=new B,Fo=new B,Uo=new B,Br=new B,zr=new B,Hs=new B,Bl=new B,Pu=new B,Du=new B,Gs=new B;function $f(n,e,t,i,r){for(let s=0,o=n.length-3;s<=o;s+=3){Gs.fromArray(n,s);const a=r.x*Math.abs(Gs.x)+r.y*Math.abs(Gs.y)+r.z*Math.abs(Gs.z),l=e.dot(Gs),c=t.dot(Gs),u=i.dot(Gs);if(Math.max(-Math.max(l,c,u),Math.min(l,c,u))>a)return!1}return!0}const mA=new Mn,S_=new B,Iu=new B,Xf=new B;class Gi{constructor(e=new B,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const i=this.center;t!==void 0?i.copy(t):mA.setFromPoints(e).getCenter(i);let r=0;for(let s=0,o=e.length;s<o;s++)r=Math.max(r,i.distanceToSquared(e[s]));return this.radius=Math.sqrt(r),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const i=this.center.distanceToSquared(e);return t.copy(e),i>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){Xf.subVectors(e,this.center);const t=Xf.lengthSq();if(t>this.radius*this.radius){const i=Math.sqrt(t),r=(i-this.radius)*.5;this.center.add(Xf.multiplyScalar(r/i)),this.radius+=r}return this}union(e){return this.center.equals(e.center)===!0?Iu.set(0,0,1).multiplyScalar(e.radius):Iu.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(S_.copy(e.center).add(Iu)),this.expandByPoint(S_.copy(e.center).sub(Iu)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const sr=new B,jf=new B,Nu=new B,kr=new B,qf=new B,Fu=new B,Yf=new B;class xl{constructor(e=new B,t=new B(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,sr)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const i=t.dot(this.direction);return i<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(i).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=sr.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(sr.copy(this.direction).multiplyScalar(t).add(this.origin),sr.distanceToSquared(e))}distanceSqToSegment(e,t,i,r){jf.copy(e).add(t).multiplyScalar(.5),Nu.copy(t).sub(e).normalize(),kr.copy(this.origin).sub(jf);const s=e.distanceTo(t)*.5,o=-this.direction.dot(Nu),a=kr.dot(this.direction),l=-kr.dot(Nu),c=kr.lengthSq(),u=Math.abs(1-o*o);let h,d,p,v;if(u>0)if(h=o*l-a,d=o*a-l,v=s*u,h>=0)if(d>=-v)if(d<=v){const m=1/u;h*=m,d*=m,p=h*(h+o*d+2*a)+d*(o*h+d+2*l)+c}else d=s,h=Math.max(0,-(o*d+a)),p=-h*h+d*(d+2*l)+c;else d=-s,h=Math.max(0,-(o*d+a)),p=-h*h+d*(d+2*l)+c;else d<=-v?(h=Math.max(0,-(-o*s+a)),d=h>0?-s:Math.min(Math.max(-s,-l),s),p=-h*h+d*(d+2*l)+c):d<=v?(h=0,d=Math.min(Math.max(-s,-l),s),p=d*(d+2*l)+c):(h=Math.max(0,-(o*s+a)),d=h>0?s:Math.min(Math.max(-s,-l),s),p=-h*h+d*(d+2*l)+c);else d=o>0?-s:s,h=Math.max(0,-(o*d+a)),p=-h*h+d*(d+2*l)+c;return i&&i.copy(this.direction).multiplyScalar(h).add(this.origin),r&&r.copy(Nu).multiplyScalar(d).add(jf),p}intersectSphere(e,t){sr.subVectors(e.center,this.origin);const i=sr.dot(this.direction),r=sr.dot(sr)-i*i,s=e.radius*e.radius;if(r>s)return null;const o=Math.sqrt(s-r),a=i-o,l=i+o;return a<0&&l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(e.normal)+e.constant)/t;return i>=0?i:null}intersectPlane(e,t){const i=this.distanceToPlane(e);return i===null?null:this.at(i,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let i,r,s,o,a,l;const c=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,d=this.origin;return c>=0?(i=(e.min.x-d.x)*c,r=(e.max.x-d.x)*c):(i=(e.max.x-d.x)*c,r=(e.min.x-d.x)*c),u>=0?(s=(e.min.y-d.y)*u,o=(e.max.y-d.y)*u):(s=(e.max.y-d.y)*u,o=(e.min.y-d.y)*u),i>o||s>r||((s>i||i!==i)&&(i=s),(o<r||r!==r)&&(r=o),h>=0?(a=(e.min.z-d.z)*h,l=(e.max.z-d.z)*h):(a=(e.max.z-d.z)*h,l=(e.min.z-d.z)*h),i>l||a>r)||((a>i||i!==i)&&(i=a),(l<r||r!==r)&&(r=l),r<0)?null:this.at(i>=0?i:r,t)}intersectsBox(e){return this.intersectBox(e,sr)!==null}intersectTriangle(e,t,i,r,s){qf.subVectors(t,e),Fu.subVectors(i,e),Yf.crossVectors(qf,Fu);let o=this.direction.dot(Yf),a;if(o>0){if(r)return null;a=1}else if(o<0)a=-1,o=-o;else return null;kr.subVectors(this.origin,e);const l=a*this.direction.dot(Fu.crossVectors(kr,Fu));if(l<0)return null;const c=a*this.direction.dot(qf.cross(kr));if(c<0||l+c>o)return null;const u=-a*kr.dot(Yf);return u<0?null:this.at(u/o,s)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Ve{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,i,r,s,o,a,l,c,u,h,d,p,v,m,f){const g=this.elements;return g[0]=e,g[4]=t,g[8]=i,g[12]=r,g[1]=s,g[5]=o,g[9]=a,g[13]=l,g[2]=c,g[6]=u,g[10]=h,g[14]=d,g[3]=p,g[7]=v,g[11]=m,g[15]=f,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Ve().fromArray(this.elements)}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],t[9]=i[9],t[10]=i[10],t[11]=i[11],t[12]=i[12],t[13]=i[13],t[14]=i[14],t[15]=i[15],this}copyPosition(e){const t=this.elements,i=e.elements;return t[12]=i[12],t[13]=i[13],t[14]=i[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,i){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(e,t,i){return this.set(e.x,t.x,i.x,0,e.y,t.y,i.y,0,e.z,t.z,i.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,i=e.elements,r=1/Oo.setFromMatrixColumn(e,0).length(),s=1/Oo.setFromMatrixColumn(e,1).length(),o=1/Oo.setFromMatrixColumn(e,2).length();return t[0]=i[0]*r,t[1]=i[1]*r,t[2]=i[2]*r,t[3]=0,t[4]=i[4]*s,t[5]=i[5]*s,t[6]=i[6]*s,t[7]=0,t[8]=i[8]*o,t[9]=i[9]*o,t[10]=i[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,i=e.x,r=e.y,s=e.z,o=Math.cos(i),a=Math.sin(i),l=Math.cos(r),c=Math.sin(r),u=Math.cos(s),h=Math.sin(s);if(e.order==="XYZ"){const d=o*u,p=o*h,v=a*u,m=a*h;t[0]=l*u,t[4]=-l*h,t[8]=c,t[1]=p+v*c,t[5]=d-m*c,t[9]=-a*l,t[2]=m-d*c,t[6]=v+p*c,t[10]=o*l}else if(e.order==="YXZ"){const d=l*u,p=l*h,v=c*u,m=c*h;t[0]=d+m*a,t[4]=v*a-p,t[8]=o*c,t[1]=o*h,t[5]=o*u,t[9]=-a,t[2]=p*a-v,t[6]=m+d*a,t[10]=o*l}else if(e.order==="ZXY"){const d=l*u,p=l*h,v=c*u,m=c*h;t[0]=d-m*a,t[4]=-o*h,t[8]=v+p*a,t[1]=p+v*a,t[5]=o*u,t[9]=m-d*a,t[2]=-o*c,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const d=o*u,p=o*h,v=a*u,m=a*h;t[0]=l*u,t[4]=v*c-p,t[8]=d*c+m,t[1]=l*h,t[5]=m*c+d,t[9]=p*c-v,t[2]=-c,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const d=o*l,p=o*c,v=a*l,m=a*c;t[0]=l*u,t[4]=m-d*h,t[8]=v*h+p,t[1]=h,t[5]=o*u,t[9]=-a*u,t[2]=-c*u,t[6]=p*h+v,t[10]=d-m*h}else if(e.order==="XZY"){const d=o*l,p=o*c,v=a*l,m=a*c;t[0]=l*u,t[4]=-h,t[8]=c*u,t[1]=d*h+m,t[5]=o*u,t[9]=p*h-v,t[2]=v*h-p,t[6]=a*u,t[10]=m*h+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(gA,e,vA)}lookAt(e,t,i){const r=this.elements;return Wn.subVectors(e,t),Wn.lengthSq()===0&&(Wn.z=1),Wn.normalize(),Hr.crossVectors(i,Wn),Hr.lengthSq()===0&&(Math.abs(i.z)===1?Wn.x+=1e-4:Wn.z+=1e-4,Wn.normalize(),Hr.crossVectors(i,Wn)),Hr.normalize(),Uu.crossVectors(Wn,Hr),r[0]=Hr.x,r[4]=Uu.x,r[8]=Wn.x,r[1]=Hr.y,r[5]=Uu.y,r[9]=Wn.y,r[2]=Hr.z,r[6]=Uu.z,r[10]=Wn.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,r=t.elements,s=this.elements,o=i[0],a=i[4],l=i[8],c=i[12],u=i[1],h=i[5],d=i[9],p=i[13],v=i[2],m=i[6],f=i[10],g=i[14],_=i[3],M=i[7],E=i[11],S=i[15],T=r[0],R=r[4],x=r[8],A=r[12],I=r[1],N=r[5],J=r[9],q=r[13],L=r[2],$=r[6],z=r[10],W=r[14],U=r[3],P=r[7],k=r[11],Y=r[15];return s[0]=o*T+a*I+l*L+c*U,s[4]=o*R+a*N+l*$+c*P,s[8]=o*x+a*J+l*z+c*k,s[12]=o*A+a*q+l*W+c*Y,s[1]=u*T+h*I+d*L+p*U,s[5]=u*R+h*N+d*$+p*P,s[9]=u*x+h*J+d*z+p*k,s[13]=u*A+h*q+d*W+p*Y,s[2]=v*T+m*I+f*L+g*U,s[6]=v*R+m*N+f*$+g*P,s[10]=v*x+m*J+f*z+g*k,s[14]=v*A+m*q+f*W+g*Y,s[3]=_*T+M*I+E*L+S*U,s[7]=_*R+M*N+E*$+S*P,s[11]=_*x+M*J+E*z+S*k,s[15]=_*A+M*q+E*W+S*Y,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[4],r=e[8],s=e[12],o=e[1],a=e[5],l=e[9],c=e[13],u=e[2],h=e[6],d=e[10],p=e[14],v=e[3],m=e[7],f=e[11],g=e[15];return v*(+s*l*h-r*c*h-s*a*d+i*c*d+r*a*p-i*l*p)+m*(+t*l*p-t*c*d+s*o*d-r*o*p+r*c*u-s*l*u)+f*(+t*c*h-t*a*p-s*o*h+i*o*p+s*a*u-i*c*u)+g*(-r*a*u-t*l*h+t*a*d+r*o*h-i*o*d+i*l*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,i){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=i),this}invert(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],d=e[10],p=e[11],v=e[12],m=e[13],f=e[14],g=e[15],_=h*f*c-m*d*c+m*l*p-a*f*p-h*l*g+a*d*g,M=v*d*c-u*f*c-v*l*p+o*f*p+u*l*g-o*d*g,E=u*m*c-v*h*c+v*a*p-o*m*p-u*a*g+o*h*g,S=v*h*l-u*m*l-v*a*d+o*m*d+u*a*f-o*h*f,T=t*_+i*M+r*E+s*S;if(T===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const R=1/T;return e[0]=_*R,e[1]=(m*d*s-h*f*s-m*r*p+i*f*p+h*r*g-i*d*g)*R,e[2]=(a*f*s-m*l*s+m*r*c-i*f*c-a*r*g+i*l*g)*R,e[3]=(h*l*s-a*d*s-h*r*c+i*d*c+a*r*p-i*l*p)*R,e[4]=M*R,e[5]=(u*f*s-v*d*s+v*r*p-t*f*p-u*r*g+t*d*g)*R,e[6]=(v*l*s-o*f*s-v*r*c+t*f*c+o*r*g-t*l*g)*R,e[7]=(o*d*s-u*l*s+u*r*c-t*d*c-o*r*p+t*l*p)*R,e[8]=E*R,e[9]=(v*h*s-u*m*s-v*i*p+t*m*p+u*i*g-t*h*g)*R,e[10]=(o*m*s-v*a*s+v*i*c-t*m*c-o*i*g+t*a*g)*R,e[11]=(u*a*s-o*h*s-u*i*c+t*h*c+o*i*p-t*a*p)*R,e[12]=S*R,e[13]=(u*m*r-v*h*r+v*i*d-t*m*d-u*i*f+t*h*f)*R,e[14]=(v*a*r-o*m*r-v*i*l+t*m*l+o*i*f-t*a*f)*R,e[15]=(o*h*r-u*a*r+u*i*l-t*h*l-o*i*d+t*a*d)*R,this}scale(e){const t=this.elements,i=e.x,r=e.y,s=e.z;return t[0]*=i,t[4]*=r,t[8]*=s,t[1]*=i,t[5]*=r,t[9]*=s,t[2]*=i,t[6]*=r,t[10]*=s,t[3]*=i,t[7]*=r,t[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],i=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,i,r))}makeTranslation(e,t,i){return this.set(1,0,0,e,0,1,0,t,0,0,1,i,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),i=Math.sin(e);return this.set(1,0,0,0,0,t,-i,0,0,i,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,0,i,0,0,1,0,0,-i,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,-i,0,0,i,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const i=Math.cos(t),r=Math.sin(t),s=1-i,o=e.x,a=e.y,l=e.z,c=s*o,u=s*a;return this.set(c*o+i,c*a-r*l,c*l+r*a,0,c*a+r*l,u*a+i,u*l-r*o,0,c*l-r*a,u*l+r*o,s*l*l+i,0,0,0,0,1),this}makeScale(e,t,i){return this.set(e,0,0,0,0,t,0,0,0,0,i,0,0,0,0,1),this}makeShear(e,t,i,r,s,o){return this.set(1,i,s,0,e,1,o,0,t,r,1,0,0,0,0,1),this}compose(e,t,i){const r=this.elements,s=t._x,o=t._y,a=t._z,l=t._w,c=s+s,u=o+o,h=a+a,d=s*c,p=s*u,v=s*h,m=o*u,f=o*h,g=a*h,_=l*c,M=l*u,E=l*h,S=i.x,T=i.y,R=i.z;return r[0]=(1-(m+g))*S,r[1]=(p+E)*S,r[2]=(v-M)*S,r[3]=0,r[4]=(p-E)*T,r[5]=(1-(d+g))*T,r[6]=(f+_)*T,r[7]=0,r[8]=(v+M)*R,r[9]=(f-_)*R,r[10]=(1-(d+m))*R,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,i){const r=this.elements;let s=Oo.set(r[0],r[1],r[2]).length();const o=Oo.set(r[4],r[5],r[6]).length(),a=Oo.set(r[8],r[9],r[10]).length();this.determinant()<0&&(s=-s),e.x=r[12],e.y=r[13],e.z=r[14],wi.copy(this);const c=1/s,u=1/o,h=1/a;return wi.elements[0]*=c,wi.elements[1]*=c,wi.elements[2]*=c,wi.elements[4]*=u,wi.elements[5]*=u,wi.elements[6]*=u,wi.elements[8]*=h,wi.elements[9]*=h,wi.elements[10]*=h,t.setFromRotationMatrix(wi),i.x=s,i.y=o,i.z=a,this}makePerspective(e,t,i,r,s,o){o===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,l=2*s/(t-e),c=2*s/(i-r),u=(t+e)/(t-e),h=(i+r)/(i-r),d=-(o+s)/(o-s),p=-2*o*s/(o-s);return a[0]=l,a[4]=0,a[8]=u,a[12]=0,a[1]=0,a[5]=c,a[9]=h,a[13]=0,a[2]=0,a[6]=0,a[10]=d,a[14]=p,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,i,r,s,o){const a=this.elements,l=1/(t-e),c=1/(i-r),u=1/(o-s),h=(t+e)*l,d=(i+r)*c,p=(o+s)*u;return a[0]=2*l,a[4]=0,a[8]=0,a[12]=-h,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-d,a[2]=0,a[6]=0,a[10]=-2*u,a[14]=-p,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){const t=this.elements,i=e.elements;for(let r=0;r<16;r++)if(t[r]!==i[r])return!1;return!0}fromArray(e,t=0){for(let i=0;i<16;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e[t+9]=i[9],e[t+10]=i[10],e[t+11]=i[11],e[t+12]=i[12],e[t+13]=i[13],e[t+14]=i[14],e[t+15]=i[15],e}}Ve.prototype.isMatrix4=!0;const Oo=new B,wi=new Ve,gA=new B(0,0,0),vA=new B(1,1,1),Hr=new B,Uu=new B,Wn=new B,w_=new Ve,E_=new bn;class Co{constructor(e=0,t=0,i=0,r=Co.DefaultOrder){this._x=e,this._y=t,this._z=i,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,i,r=this._order){return this._x=e,this._y=t,this._z=i,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,i=!0){const r=e.elements,s=r[0],o=r[4],a=r[8],l=r[1],c=r[5],u=r[9],h=r[2],d=r[6],p=r[10];switch(t){case"XYZ":this._y=Math.asin(rn(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-o,s)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-rn(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,p),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-h,s),this._z=0);break;case"ZXY":this._x=Math.asin(rn(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,p),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(l,s));break;case"ZYX":this._y=Math.asin(-rn(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(l,s)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin(rn(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,c),this._y=Math.atan2(-h,s)):(this._x=0,this._y=Math.atan2(a,p));break;case"XZY":this._z=Math.asin(-rn(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(a,s)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,i===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,i){return w_.makeRotationFromQuaternion(e),this.setFromRotationMatrix(w_,t,i)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return E_.setFromEuler(this),this.setFromQuaternion(E_,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Co.prototype.isEuler=!0;Co.DefaultOrder="XYZ";Co.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class IS{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let _A=0;const b_=new B,Bo=new bn,or=new Ve,Ou=new B,zl=new B,xA=new B,yA=new bn,T_=new B(1,0,0),A_=new B(0,1,0),C_=new B(0,0,1),MA={type:"added"},R_={type:"removed"};class at extends To{constructor(){super(),Object.defineProperty(this,"id",{value:_A++}),this.uuid=di(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=at.DefaultUp.clone();const e=new B,t=new Co,i=new bn,r=new B(1,1,1);function s(){i.setFromEuler(t,!1)}function o(){t.setFromQuaternion(i,void 0,!1)}t._onChange(s),i._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new Ve},normalMatrix:{value:new sn}}),this.matrix=new Ve,this.matrixWorld=new Ve,this.matrixAutoUpdate=at.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new IS,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return Bo.setFromAxisAngle(e,t),this.quaternion.multiply(Bo),this}rotateOnWorldAxis(e,t){return Bo.setFromAxisAngle(e,t),this.quaternion.premultiply(Bo),this}rotateX(e){return this.rotateOnAxis(T_,e)}rotateY(e){return this.rotateOnAxis(A_,e)}rotateZ(e){return this.rotateOnAxis(C_,e)}translateOnAxis(e,t){return b_.copy(e).applyQuaternion(this.quaternion),this.position.add(b_.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(T_,e)}translateY(e){return this.translateOnAxis(A_,e)}translateZ(e){return this.translateOnAxis(C_,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(or.copy(this.matrixWorld).invert())}lookAt(e,t,i){e.isVector3?Ou.copy(e):Ou.set(e,t,i);const r=this.parent;this.updateWorldMatrix(!0,!1),zl.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?or.lookAt(zl,Ou,this.up):or.lookAt(Ou,zl,this.up),this.quaternion.setFromRotationMatrix(or),r&&(or.extractRotation(r.matrixWorld),Bo.setFromRotationMatrix(or),this.quaternion.premultiply(Bo.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(MA)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(R_)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(R_)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),or.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),or.multiply(e.parent.matrixWorld)),e.applyMatrix4(or),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let i=0,r=this.children.length;i<r;i++){const o=this.children[i].getObjectByProperty(e,t);if(o!==void 0)return o}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(zl,e,xA),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(zl,yA,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].updateMatrixWorld(e)}updateWorldMatrix(e,t){const i=this.parent;if(e===!0&&i!==null&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const r=this.children;for(let s=0,o=r.length;s<o;s++)r[s].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",i={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(r.instanceColor=this.instanceColor.toJSON()));function s(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&(r.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=s(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let c=0,u=l.length;c<u;c++){const h=l[c];s(e.shapes,h)}else s(e.shapes,l)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(e.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,c=this.material.length;l<c;l++)a.push(s(e.materials,this.material[l]));r.material=a}else r.material=s(e.materials,this.material);if(this.children.length>0){r.children=[];for(let a=0;a<this.children.length;a++)r.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];r.animations.push(s(e.animations,l))}}if(t){const a=o(e.geometries),l=o(e.materials),c=o(e.textures),u=o(e.images),h=o(e.shapes),d=o(e.skeletons),p=o(e.animations),v=o(e.nodes);a.length>0&&(i.geometries=a),l.length>0&&(i.materials=l),c.length>0&&(i.textures=c),u.length>0&&(i.images=u),h.length>0&&(i.shapes=h),d.length>0&&(i.skeletons=d),p.length>0&&(i.animations=p),v.length>0&&(i.nodes=v)}return i.object=r,i;function o(a){const l=[];for(const c in a){const u=a[c];delete u.metadata,l.push(u)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let i=0;i<e.children.length;i++){const r=e.children[i];this.add(r.clone())}return this}}at.DefaultUp=new B(0,1,0);at.DefaultMatrixAutoUpdate=!0;at.prototype.isObject3D=!0;const Ei=new B,ar=new B,Kf=new B,lr=new B,zo=new B,ko=new B,L_=new B,Zf=new B,Jf=new B,Qf=new B;class zt{constructor(e=new B,t=new B,i=new B){this.a=e,this.b=t,this.c=i}static getNormal(e,t,i,r){r.subVectors(i,t),Ei.subVectors(e,t),r.cross(Ei);const s=r.lengthSq();return s>0?r.multiplyScalar(1/Math.sqrt(s)):r.set(0,0,0)}static getBarycoord(e,t,i,r,s){Ei.subVectors(r,t),ar.subVectors(i,t),Kf.subVectors(e,t);const o=Ei.dot(Ei),a=Ei.dot(ar),l=Ei.dot(Kf),c=ar.dot(ar),u=ar.dot(Kf),h=o*c-a*a;if(h===0)return s.set(-2,-1,-1);const d=1/h,p=(c*l-a*u)*d,v=(o*u-a*l)*d;return s.set(1-p-v,v,p)}static containsPoint(e,t,i,r){return this.getBarycoord(e,t,i,r,lr),lr.x>=0&&lr.y>=0&&lr.x+lr.y<=1}static getUV(e,t,i,r,s,o,a,l){return this.getBarycoord(e,t,i,r,lr),l.set(0,0),l.addScaledVector(s,lr.x),l.addScaledVector(o,lr.y),l.addScaledVector(a,lr.z),l}static isFrontFacing(e,t,i,r){return Ei.subVectors(i,t),ar.subVectors(e,t),Ei.cross(ar).dot(r)<0}set(e,t,i){return this.a.copy(e),this.b.copy(t),this.c.copy(i),this}setFromPointsAndIndices(e,t,i,r){return this.a.copy(e[t]),this.b.copy(e[i]),this.c.copy(e[r]),this}setFromAttributeAndIndices(e,t,i,r){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,i),this.c.fromBufferAttribute(e,r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Ei.subVectors(this.c,this.b),ar.subVectors(this.a,this.b),Ei.cross(ar).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return zt.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return zt.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,i,r,s){return zt.getUV(e,this.a,this.b,this.c,t,i,r,s)}containsPoint(e){return zt.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return zt.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const i=this.a,r=this.b,s=this.c;let o,a;zo.subVectors(r,i),ko.subVectors(s,i),Zf.subVectors(e,i);const l=zo.dot(Zf),c=ko.dot(Zf);if(l<=0&&c<=0)return t.copy(i);Jf.subVectors(e,r);const u=zo.dot(Jf),h=ko.dot(Jf);if(u>=0&&h<=u)return t.copy(r);const d=l*h-u*c;if(d<=0&&l>=0&&u<=0)return o=l/(l-u),t.copy(i).addScaledVector(zo,o);Qf.subVectors(e,s);const p=zo.dot(Qf),v=ko.dot(Qf);if(v>=0&&p<=v)return t.copy(s);const m=p*c-l*v;if(m<=0&&c>=0&&v<=0)return a=c/(c-v),t.copy(i).addScaledVector(ko,a);const f=u*v-p*h;if(f<=0&&h-u>=0&&p-v>=0)return L_.subVectors(s,r),a=(h-u)/(h-u+(p-v)),t.copy(r).addScaledVector(L_,a);const g=1/(f+m+d);return o=m*g,a=d*g,t.copy(i).addScaledVector(zo,o).addScaledVector(ko,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let SA=0;class Rt extends To{constructor(){super(),Object.defineProperty(this,"id",{value:SA++}),this.uuid=di(),this.name="",this.type="Material",this.blending=Fa,this.side=Xa,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=wS,this.blendDst=ES,this.blendEquation=ma,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Bm,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=YT,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=zf,this.stencilZFail=zf,this.stencilZPass=zf,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const i=e[t];if(i===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=i===SS;continue}const r=this[t];if(r===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}r&&r.isColor?r.set(i):r&&r.isVector3&&i&&i.isVector3?r.copy(i):this[t]=i}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const i={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),this.roughness!==void 0&&(i.roughness=this.roughness),this.metalness!==void 0&&(i.metalness=this.metalness),this.sheen!==void 0&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(i.shininess=this.shininess),this.clearcoat!==void 0&&(i.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(e).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(e).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(e).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(e).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(e).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(i.combine=this.combine)),this.envMapIntensity!==void 0&&(i.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(i.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&(i.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(i.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(i.size=this.size),this.shadowSide!==null&&(i.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==Fa&&(i.blending=this.blending),this.side!==Xa&&(i.side=this.side),this.vertexColors&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),this.transparent===!0&&(i.transparent=this.transparent),i.depthFunc=this.depthFunc,i.depthTest=this.depthTest,i.depthWrite=this.depthWrite,i.colorWrite=this.colorWrite,i.stencilWrite=this.stencilWrite,i.stencilWriteMask=this.stencilWriteMask,i.stencilFunc=this.stencilFunc,i.stencilRef=this.stencilRef,i.stencilFuncMask=this.stencilFuncMask,i.stencilFail=this.stencilFail,i.stencilZFail=this.stencilZFail,i.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(i.rotation=this.rotation),this.polygonOffset===!0&&(i.polygonOffset=!0),this.polygonOffsetFactor!==0&&(i.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(i.linewidth=this.linewidth),this.dashSize!==void 0&&(i.dashSize=this.dashSize),this.gapSize!==void 0&&(i.gapSize=this.gapSize),this.scale!==void 0&&(i.scale=this.scale),this.dithering===!0&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(i.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(i.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(i.wireframe=this.wireframe),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(i.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(i.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(i.flatShading=this.flatShading),this.visible===!1&&(i.visible=!1),this.toneMapped===!1&&(i.toneMapped=!1),this.fog===!1&&(i.fog=!1),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData);function r(s){const o=[];for(const a in s){const l=s[a];delete l.metadata,o.push(l)}return o}if(t){const s=r(e.textures),o=r(e.images);s.length>0&&(i.textures=s),o.length>0&&(i.images=o)}return i}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let i=null;if(t!==null){const r=t.length;i=new Array(r);for(let s=0;s!==r;++s)i[s]=t[s].clone()}return this.clippingPlanes=i,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}Rt.prototype.isMaterial=!0;Rt.fromType=function(){return null};class Fn extends Rt{constructor(e){super(),this.type="MeshBasicMaterial",this.color=new we(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Wd,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}Fn.prototype.isMeshBasicMaterial=!0;const Ot=new B,Bu=new fe;class Ut{constructor(e,t,i){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=i===!0,this.usage=Oc,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,i){e*=this.itemSize,i*=t.itemSize;for(let r=0,s=this.itemSize;r<s;r++)this.array[e+r]=t.array[i+r];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){const t=this.array;let i=0;for(let r=0,s=e.length;r<s;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),o=new we),t[i++]=o.r,t[i++]=o.g,t[i++]=o.b}return this}copyVector2sArray(e){const t=this.array;let i=0;for(let r=0,s=e.length;r<s;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),o=new fe),t[i++]=o.x,t[i++]=o.y}return this}copyVector3sArray(e){const t=this.array;let i=0;for(let r=0,s=e.length;r<s;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),o=new B),t[i++]=o.x,t[i++]=o.y,t[i++]=o.z}return this}copyVector4sArray(e){const t=this.array;let i=0;for(let r=0,s=e.length;r<s;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),o=new ut),t[i++]=o.x,t[i++]=o.y,t[i++]=o.z,t[i++]=o.w}return this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,i=this.count;t<i;t++)Bu.fromBufferAttribute(this,t),Bu.applyMatrix3(e),this.setXY(t,Bu.x,Bu.y);else if(this.itemSize===3)for(let t=0,i=this.count;t<i;t++)Ot.fromBufferAttribute(this,t),Ot.applyMatrix3(e),this.setXYZ(t,Ot.x,Ot.y,Ot.z);return this}applyMatrix4(e){for(let t=0,i=this.count;t<i;t++)Ot.fromBufferAttribute(this,t),Ot.applyMatrix4(e),this.setXYZ(t,Ot.x,Ot.y,Ot.z);return this}applyNormalMatrix(e){for(let t=0,i=this.count;t<i;t++)Ot.fromBufferAttribute(this,t),Ot.applyNormalMatrix(e),this.setXYZ(t,Ot.x,Ot.y,Ot.z);return this}transformDirection(e){for(let t=0,i=this.count;t<i;t++)Ot.fromBufferAttribute(this,t),Ot.transformDirection(e),this.setXYZ(t,Ot.x,Ot.y,Ot.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=i,this}setXYZ(e,t,i,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=r,this}setXYZW(e,t,i,r,s){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=r,this.array[e+3]=s,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==Oc&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}}Ut.prototype.isBufferAttribute=!0;class NS extends Ut{constructor(e,t,i){super(new Uint16Array(e),t,i)}}class FS extends Ut{constructor(e,t,i){super(new Uint32Array(e),t,i)}}class wA extends Ut{constructor(e,t,i){super(new Uint16Array(e),t,i)}}wA.prototype.isFloat16BufferAttribute=!0;class rt extends Ut{constructor(e,t,i){super(new Float32Array(e),t,i)}}let EA=0;const ri=new Ve,ep=new at,Ho=new B,$n=new Mn,kl=new Mn,jt=new B;class lt extends To{constructor(){super(),Object.defineProperty(this,"id",{value:EA++}),this.uuid=di(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(LS(e)?FS:NS)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,i=0){this.groups.push({start:e,count:t,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const i=this.attributes.normal;if(i!==void 0){const s=new sn().getNormalMatrix(e);i.applyNormalMatrix(s),i.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(e),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return ri.makeRotationFromQuaternion(e),this.applyMatrix4(ri),this}rotateX(e){return ri.makeRotationX(e),this.applyMatrix4(ri),this}rotateY(e){return ri.makeRotationY(e),this.applyMatrix4(ri),this}rotateZ(e){return ri.makeRotationZ(e),this.applyMatrix4(ri),this}translate(e,t,i){return ri.makeTranslation(e,t,i),this.applyMatrix4(ri),this}scale(e,t,i){return ri.makeScale(e,t,i),this.applyMatrix4(ri),this}lookAt(e){return ep.lookAt(e),ep.updateMatrix(),this.applyMatrix4(ep.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Ho).negate(),this.translate(Ho.x,Ho.y,Ho.z),this}setFromPoints(e){const t=[];for(let i=0,r=e.length;i<r;i++){const s=e[i];t.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new rt(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Mn);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new B(-1/0,-1/0,-1/0),new B(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let i=0,r=t.length;i<r;i++){const s=t[i];$n.setFromBufferAttribute(s),this.morphTargetsRelative?(jt.addVectors(this.boundingBox.min,$n.min),this.boundingBox.expandByPoint(jt),jt.addVectors(this.boundingBox.max,$n.max),this.boundingBox.expandByPoint(jt)):(this.boundingBox.expandByPoint($n.min),this.boundingBox.expandByPoint($n.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Gi);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new B,1/0);return}if(e){const i=this.boundingSphere.center;if($n.setFromBufferAttribute(e),t)for(let s=0,o=t.length;s<o;s++){const a=t[s];kl.setFromBufferAttribute(a),this.morphTargetsRelative?(jt.addVectors($n.min,kl.min),$n.expandByPoint(jt),jt.addVectors($n.max,kl.max),$n.expandByPoint(jt)):($n.expandByPoint(kl.min),$n.expandByPoint(kl.max))}$n.getCenter(i);let r=0;for(let s=0,o=e.count;s<o;s++)jt.fromBufferAttribute(e,s),r=Math.max(r,i.distanceToSquared(jt));if(t)for(let s=0,o=t.length;s<o;s++){const a=t[s],l=this.morphTargetsRelative;for(let c=0,u=a.count;c<u;c++)jt.fromBufferAttribute(a,c),l&&(Ho.fromBufferAttribute(e,c),jt.add(Ho)),r=Math.max(r,i.distanceToSquared(jt))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const i=e.array,r=t.position.array,s=t.normal.array,o=t.uv.array,a=r.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Ut(new Float32Array(4*a),4));const l=this.getAttribute("tangent").array,c=[],u=[];for(let I=0;I<a;I++)c[I]=new B,u[I]=new B;const h=new B,d=new B,p=new B,v=new fe,m=new fe,f=new fe,g=new B,_=new B;function M(I,N,J){h.fromArray(r,I*3),d.fromArray(r,N*3),p.fromArray(r,J*3),v.fromArray(o,I*2),m.fromArray(o,N*2),f.fromArray(o,J*2),d.sub(h),p.sub(h),m.sub(v),f.sub(v);const q=1/(m.x*f.y-f.x*m.y);!isFinite(q)||(g.copy(d).multiplyScalar(f.y).addScaledVector(p,-m.y).multiplyScalar(q),_.copy(p).multiplyScalar(m.x).addScaledVector(d,-f.x).multiplyScalar(q),c[I].add(g),c[N].add(g),c[J].add(g),u[I].add(_),u[N].add(_),u[J].add(_))}let E=this.groups;E.length===0&&(E=[{start:0,count:i.length}]);for(let I=0,N=E.length;I<N;++I){const J=E[I],q=J.start,L=J.count;for(let $=q,z=q+L;$<z;$+=3)M(i[$+0],i[$+1],i[$+2])}const S=new B,T=new B,R=new B,x=new B;function A(I){R.fromArray(s,I*3),x.copy(R);const N=c[I];S.copy(N),S.sub(R.multiplyScalar(R.dot(N))).normalize(),T.crossVectors(x,N);const q=T.dot(u[I])<0?-1:1;l[I*4]=S.x,l[I*4+1]=S.y,l[I*4+2]=S.z,l[I*4+3]=q}for(let I=0,N=E.length;I<N;++I){const J=E[I],q=J.start,L=J.count;for(let $=q,z=q+L;$<z;$+=3)A(i[$+0]),A(i[$+1]),A(i[$+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let i=this.getAttribute("normal");if(i===void 0)i=new Ut(new Float32Array(t.count*3),3),this.setAttribute("normal",i);else for(let d=0,p=i.count;d<p;d++)i.setXYZ(d,0,0,0);const r=new B,s=new B,o=new B,a=new B,l=new B,c=new B,u=new B,h=new B;if(e)for(let d=0,p=e.count;d<p;d+=3){const v=e.getX(d+0),m=e.getX(d+1),f=e.getX(d+2);r.fromBufferAttribute(t,v),s.fromBufferAttribute(t,m),o.fromBufferAttribute(t,f),u.subVectors(o,s),h.subVectors(r,s),u.cross(h),a.fromBufferAttribute(i,v),l.fromBufferAttribute(i,m),c.fromBufferAttribute(i,f),a.add(u),l.add(u),c.add(u),i.setXYZ(v,a.x,a.y,a.z),i.setXYZ(m,l.x,l.y,l.z),i.setXYZ(f,c.x,c.y,c.z)}else for(let d=0,p=t.count;d<p;d+=3)r.fromBufferAttribute(t,d+0),s.fromBufferAttribute(t,d+1),o.fromBufferAttribute(t,d+2),u.subVectors(o,s),h.subVectors(r,s),u.cross(h),i.setXYZ(d+0,u.x,u.y,u.z),i.setXYZ(d+1,u.x,u.y,u.z),i.setXYZ(d+2,u.x,u.y,u.z);this.normalizeNormals(),i.needsUpdate=!0}}merge(e,t){if(!(e&&e.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);return}t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const i=this.attributes;for(const r in i){if(e.attributes[r]===void 0)continue;const o=i[r].array,a=e.attributes[r],l=a.array,c=a.itemSize*t,u=Math.min(l.length,o.length-c);for(let h=0,d=c;h<u;h++,d++)o[d]=l[h]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,i=e.count;t<i;t++)jt.fromBufferAttribute(e,t),jt.normalize(),e.setXYZ(t,jt.x,jt.y,jt.z)}toNonIndexed(){function e(a,l){const c=a.array,u=a.itemSize,h=a.normalized,d=new c.constructor(l.length*u);let p=0,v=0;for(let m=0,f=l.length;m<f;m++){a.isInterleavedBufferAttribute?p=l[m]*a.data.stride+a.offset:p=l[m]*u;for(let g=0;g<u;g++)d[v++]=c[p++]}return new Ut(d,u,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new lt,i=this.index.array,r=this.attributes;for(const a in r){const l=r[a],c=e(l,i);t.setAttribute(a,c)}const s=this.morphAttributes;for(const a in s){const l=[],c=s[a];for(let u=0,h=c.length;u<h;u++){const d=c[u],p=e(d,i);l.push(p)}t.morphAttributes[a]=l}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const c=o[a];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const i=this.attributes;for(const l in i){const c=i[l];e.data.attributes[l]=c.toJSON(e.data)}const r={};let s=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],u=[];for(let h=0,d=c.length;h<d;h++){const p=c[h];u.push(p.toJSON(e.data))}u.length>0&&(r[l]=u,s=!0)}s&&(e.data.morphAttributes=r,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const i=e.index;i!==null&&this.setIndex(i.clone(t));const r=e.attributes;for(const c in r){const u=r[c];this.setAttribute(c,u.clone(t))}const s=e.morphAttributes;for(const c in s){const u=[],h=s[c];for(let d=0,p=h.length;d<p;d++)u.push(h[d].clone(t));this.morphAttributes[c]=u}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let c=0,u=o.length;c<u;c++){const h=o[c];this.addGroup(h.start,h.count,h.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,e.parameters!==void 0&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}lt.prototype.isBufferGeometry=!0;const P_=new Ve,Go=new xl,tp=new Gi,Gr=new B,Vr=new B,Wr=new B,np=new B,ip=new B,rp=new B,zu=new B,ku=new B,Hu=new B,Gu=new fe,Vu=new fe,Wu=new fe,sp=new B,$u=new B;class dt extends at{constructor(e=new lt,t=new Fn){super(),this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,i=Object.keys(t);if(i.length>0){const r=t[i[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=r.length;s<o;s++){const a=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(e,t){const i=this.geometry,r=this.material,s=this.matrixWorld;if(r===void 0||(i.boundingSphere===null&&i.computeBoundingSphere(),tp.copy(i.boundingSphere),tp.applyMatrix4(s),e.ray.intersectsSphere(tp)===!1)||(P_.copy(s).invert(),Go.copy(e.ray).applyMatrix4(P_),i.boundingBox!==null&&Go.intersectsBox(i.boundingBox)===!1))return;let o;if(i.isBufferGeometry){const a=i.index,l=i.attributes.position,c=i.morphAttributes.position,u=i.morphTargetsRelative,h=i.attributes.uv,d=i.attributes.uv2,p=i.groups,v=i.drawRange;if(a!==null)if(Array.isArray(r))for(let m=0,f=p.length;m<f;m++){const g=p[m],_=r[g.materialIndex],M=Math.max(g.start,v.start),E=Math.min(a.count,Math.min(g.start+g.count,v.start+v.count));for(let S=M,T=E;S<T;S+=3){const R=a.getX(S),x=a.getX(S+1),A=a.getX(S+2);o=Xu(this,_,e,Go,l,c,u,h,d,R,x,A),o&&(o.faceIndex=Math.floor(S/3),o.face.materialIndex=g.materialIndex,t.push(o))}}else{const m=Math.max(0,v.start),f=Math.min(a.count,v.start+v.count);for(let g=m,_=f;g<_;g+=3){const M=a.getX(g),E=a.getX(g+1),S=a.getX(g+2);o=Xu(this,r,e,Go,l,c,u,h,d,M,E,S),o&&(o.faceIndex=Math.floor(g/3),t.push(o))}}else if(l!==void 0)if(Array.isArray(r))for(let m=0,f=p.length;m<f;m++){const g=p[m],_=r[g.materialIndex],M=Math.max(g.start,v.start),E=Math.min(l.count,Math.min(g.start+g.count,v.start+v.count));for(let S=M,T=E;S<T;S+=3){const R=S,x=S+1,A=S+2;o=Xu(this,_,e,Go,l,c,u,h,d,R,x,A),o&&(o.faceIndex=Math.floor(S/3),o.face.materialIndex=g.materialIndex,t.push(o))}}else{const m=Math.max(0,v.start),f=Math.min(l.count,v.start+v.count);for(let g=m,_=f;g<_;g+=3){const M=g,E=g+1,S=g+2;o=Xu(this,r,e,Go,l,c,u,h,d,M,E,S),o&&(o.faceIndex=Math.floor(g/3),t.push(o))}}}else i.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}dt.prototype.isMesh=!0;function bA(n,e,t,i,r,s,o,a){let l;if(e.side===Bi?l=i.intersectTriangle(o,s,r,!0,a):l=i.intersectTriangle(r,s,o,e.side!==po,a),l===null)return null;$u.copy(a),$u.applyMatrix4(n.matrixWorld);const c=t.ray.origin.distanceTo($u);return c<t.near||c>t.far?null:{distance:c,point:$u.clone(),object:n}}function Xu(n,e,t,i,r,s,o,a,l,c,u,h){Gr.fromBufferAttribute(r,c),Vr.fromBufferAttribute(r,u),Wr.fromBufferAttribute(r,h);const d=n.morphTargetInfluences;if(s&&d){zu.set(0,0,0),ku.set(0,0,0),Hu.set(0,0,0);for(let v=0,m=s.length;v<m;v++){const f=d[v],g=s[v];f!==0&&(np.fromBufferAttribute(g,c),ip.fromBufferAttribute(g,u),rp.fromBufferAttribute(g,h),o?(zu.addScaledVector(np,f),ku.addScaledVector(ip,f),Hu.addScaledVector(rp,f)):(zu.addScaledVector(np.sub(Gr),f),ku.addScaledVector(ip.sub(Vr),f),Hu.addScaledVector(rp.sub(Wr),f)))}Gr.add(zu),Vr.add(ku),Wr.add(Hu)}n.isSkinnedMesh&&(n.boneTransform(c,Gr),n.boneTransform(u,Vr),n.boneTransform(h,Wr));const p=bA(n,e,t,i,Gr,Vr,Wr,sp);if(p){a&&(Gu.fromBufferAttribute(a,c),Vu.fromBufferAttribute(a,u),Wu.fromBufferAttribute(a,h),p.uv=zt.getUV(sp,Gr,Vr,Wr,Gu,Vu,Wu,new fe)),l&&(Gu.fromBufferAttribute(l,c),Vu.fromBufferAttribute(l,u),Wu.fromBufferAttribute(l,h),p.uv2=zt.getUV(sp,Gr,Vr,Wr,Gu,Vu,Wu,new fe));const v={a:c,b:u,c:h,normal:new B,materialIndex:0};zt.getNormal(Gr,Vr,Wr,v.normal),p.face=v}return p}class Ji extends lt{constructor(e=1,t=1,i=1,r=1,s=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:i,widthSegments:r,heightSegments:s,depthSegments:o};const a=this;r=Math.floor(r),s=Math.floor(s),o=Math.floor(o);const l=[],c=[],u=[],h=[];let d=0,p=0;v("z","y","x",-1,-1,i,t,e,o,s,0),v("z","y","x",1,-1,i,t,-e,o,s,1),v("x","z","y",1,1,e,i,t,r,o,2),v("x","z","y",1,-1,e,i,-t,r,o,3),v("x","y","z",1,-1,e,t,i,r,s,4),v("x","y","z",-1,-1,e,t,-i,r,s,5),this.setIndex(l),this.setAttribute("position",new rt(c,3)),this.setAttribute("normal",new rt(u,3)),this.setAttribute("uv",new rt(h,2));function v(m,f,g,_,M,E,S,T,R,x,A){const I=E/R,N=S/x,J=E/2,q=S/2,L=T/2,$=R+1,z=x+1;let W=0,U=0;const P=new B;for(let k=0;k<z;k++){const Y=k*N-q;for(let j=0;j<$;j++){const K=j*I-J;P[m]=K*_,P[f]=Y*M,P[g]=L,c.push(P.x,P.y,P.z),P[m]=0,P[f]=0,P[g]=T>0?1:-1,u.push(P.x,P.y,P.z),h.push(j/R),h.push(1-k/x),W+=1}}for(let k=0;k<x;k++)for(let Y=0;Y<R;Y++){const j=d+Y+$*k,K=d+Y+$*(k+1),ce=d+(Y+1)+$*(k+1),de=d+(Y+1)+$*k;l.push(j,K,de),l.push(K,ce,de),U+=6}a.addGroup(p,U,A),p+=U,d+=W}}static fromJSON(e){return new Ji(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function Ja(n){const e={};for(const t in n){e[t]={};for(const i in n[t]){const r=n[t][i];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?e[t][i]=r.clone():Array.isArray(r)?e[t][i]=r.slice():e[t][i]=r}}return e}function fn(n){const e={};for(let t=0;t<n.length;t++){const i=Ja(n[t]);for(const r in i)e[r]=i[r]}return e}const md={clone:Ja,merge:fn};var TA=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,AA=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Zt extends Rt{constructor(e){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=TA,this.fragmentShader=AA,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=Ja(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const r in this.uniforms){const o=this.uniforms[r].value;o&&o.isTexture?t.uniforms[r]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[r]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[r]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[r]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[r]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[r]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[r]={type:"m4",value:o.toArray()}:t.uniforms[r]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const i={};for(const r in this.extensions)this.extensions[r]===!0&&(i[r]=!0);return Object.keys(i).length>0&&(t.extensions=i),t}}Zt.prototype.isShaderMaterial=!0;class c0 extends at{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new Ve,this.projectionMatrix=new Ve,this.projectionMatrixInverse=new Ve}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}c0.prototype.isCamera=!0;class gn extends c0{constructor(e=50,t=1,i=.1,r=2e3){super(),this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=i,this.far=r,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=Bc*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(Mc*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return Bc*2*Math.atan(Math.tan(Mc*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,i,r,s,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=r,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(Mc*.5*this.fov)/this.zoom,i=2*t,r=this.aspect*i,s=-.5*r;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,c=o.fullHeight;s+=o.offsetX*r/l,t-=o.offsetY*i/c,r*=o.width/l,i*=o.height/c}const a=this.filmOffset;a!==0&&(s+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+r,t,t-i,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}gn.prototype.isPerspectiveCamera=!0;const Vo=90,Wo=1;class u0 extends at{constructor(e,t,i){if(super(),this.type="CubeCamera",i.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=i;const r=new gn(Vo,Wo,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new B(1,0,0)),this.add(r);const s=new gn(Vo,Wo,e,t);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new B(-1,0,0)),this.add(s);const o=new gn(Vo,Wo,e,t);o.layers=this.layers,o.up.set(0,0,1),o.lookAt(new B(0,1,0)),this.add(o);const a=new gn(Vo,Wo,e,t);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new B(0,-1,0)),this.add(a);const l=new gn(Vo,Wo,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new B(0,0,1)),this.add(l);const c=new gn(Vo,Wo,e,t);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new B(0,0,-1)),this.add(c)}update(e,t){this.parent===null&&this.updateMatrixWorld();const i=this.renderTarget,[r,s,o,a,l,c]=this.children,u=e.getRenderTarget(),h=e.toneMapping,d=e.xr.enabled;e.toneMapping=Ar,e.xr.enabled=!1;const p=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,e.setRenderTarget(i,0),e.render(t,r),e.setRenderTarget(i,1),e.render(t,s),e.setRenderTarget(i,2),e.render(t,o),e.setRenderTarget(i,3),e.render(t,a),e.setRenderTarget(i,4),e.render(t,l),i.texture.generateMipmaps=p,e.setRenderTarget(i,5),e.render(t,c),e.setRenderTarget(u),e.toneMapping=h,e.xr.enabled=d,i.texture.needsPMREMUpdate=!0}}class jd extends Ht{constructor(e,t,i,r,s,o,a,l,c,u){e=e!==void 0?e:[],t=t!==void 0?t:ja,super(e,t,i,r,s,o,a,l,c,u),this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}jd.prototype.isCubeTexture=!0;class US extends on{constructor(e,t={}){super(e,e,t);const i={width:e,height:e,depth:1},r=[i,i,i,i,i,i];this.texture=new jd(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:mn}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const i={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},r=new Ji(5,5,5),s=new Zt({name:"CubemapFromEquirect",uniforms:Ja(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:Bi,blending:hs});s.uniforms.tEquirect.value=t;const o=new dt(r,s),a=t.minFilter;return t.minFilter===_l&&(t.minFilter=mn),new u0(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,i,r){const s=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,i,r);e.setRenderTarget(s)}}US.prototype.isWebGLCubeRenderTarget=!0;const op=new B,CA=new B,RA=new sn;class Mr{constructor(e=new B(1,0,0),t=0){this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,i,r){return this.normal.set(e,t,i),this.constant=r,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,i){const r=op.subVectors(i,t).cross(CA.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(r,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const i=e.delta(op),r=this.normal.dot(i);if(r===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const s=-(e.start.dot(this.normal)+this.constant)/r;return s<0||s>1?null:t.copy(i).multiplyScalar(s).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),i=this.distanceToPoint(e.end);return t<0&&i>0||i<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const i=t||RA.getNormalMatrix(e),r=this.coplanarPoint(op).applyMatrix4(e),s=this.normal.applyMatrix3(i).normalize();return this.constant=-r.dot(s),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}Mr.prototype.isPlane=!0;const $o=new Gi,ju=new B;class qd{constructor(e=new Mr,t=new Mr,i=new Mr,r=new Mr,s=new Mr,o=new Mr){this.planes=[e,t,i,r,s,o]}set(e,t,i,r,s,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(i),a[3].copy(r),a[4].copy(s),a[5].copy(o),this}copy(e){const t=this.planes;for(let i=0;i<6;i++)t[i].copy(e.planes[i]);return this}setFromProjectionMatrix(e){const t=this.planes,i=e.elements,r=i[0],s=i[1],o=i[2],a=i[3],l=i[4],c=i[5],u=i[6],h=i[7],d=i[8],p=i[9],v=i[10],m=i[11],f=i[12],g=i[13],_=i[14],M=i[15];return t[0].setComponents(a-r,h-l,m-d,M-f).normalize(),t[1].setComponents(a+r,h+l,m+d,M+f).normalize(),t[2].setComponents(a+s,h+c,m+p,M+g).normalize(),t[3].setComponents(a-s,h-c,m-p,M-g).normalize(),t[4].setComponents(a-o,h-u,m-v,M-_).normalize(),t[5].setComponents(a+o,h+u,m+v,M+_).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),$o.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere($o)}intersectsSprite(e){return $o.center.set(0,0,0),$o.radius=.7071067811865476,$o.applyMatrix4(e.matrixWorld),this.intersectsSphere($o)}intersectsSphere(e){const t=this.planes,i=e.center,r=-e.radius;for(let s=0;s<6;s++)if(t[s].distanceToPoint(i)<r)return!1;return!0}intersectsBox(e){const t=this.planes;for(let i=0;i<6;i++){const r=t[i];if(ju.x=r.normal.x>0?e.max.x:e.min.x,ju.y=r.normal.y>0?e.max.y:e.min.y,ju.z=r.normal.z>0?e.max.z:e.min.z,r.distanceToPoint(ju)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let i=0;i<6;i++)if(t[i].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function OS(){let n=null,e=!1,t=null,i=null;function r(s,o){t(s,o),i=n.requestAnimationFrame(r)}return{start:function(){e!==!0&&t!==null&&(i=n.requestAnimationFrame(r),e=!0)},stop:function(){n.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(s){t=s},setContext:function(s){n=s}}}function LA(n,e){const t=e.isWebGL2,i=new WeakMap;function r(c,u){const h=c.array,d=c.usage,p=n.createBuffer();n.bindBuffer(u,p),n.bufferData(u,h,d),c.onUploadCallback();let v;if(h instanceof Float32Array)v=5126;else if(h instanceof Uint16Array)if(c.isFloat16BufferAttribute)if(t)v=5131;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else v=5123;else if(h instanceof Int16Array)v=5122;else if(h instanceof Uint32Array)v=5125;else if(h instanceof Int32Array)v=5124;else if(h instanceof Int8Array)v=5120;else if(h instanceof Uint8Array)v=5121;else if(h instanceof Uint8ClampedArray)v=5121;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+h);return{buffer:p,type:v,bytesPerElement:h.BYTES_PER_ELEMENT,version:c.version}}function s(c,u,h){const d=u.array,p=u.updateRange;n.bindBuffer(h,c),p.count===-1?n.bufferSubData(h,0,d):(t?n.bufferSubData(h,p.offset*d.BYTES_PER_ELEMENT,d,p.offset,p.count):n.bufferSubData(h,p.offset*d.BYTES_PER_ELEMENT,d.subarray(p.offset,p.offset+p.count)),p.count=-1)}function o(c){return c.isInterleavedBufferAttribute&&(c=c.data),i.get(c)}function a(c){c.isInterleavedBufferAttribute&&(c=c.data);const u=i.get(c);u&&(n.deleteBuffer(u.buffer),i.delete(c))}function l(c,u){if(c.isGLBufferAttribute){const d=i.get(c);(!d||d.version<c.version)&&i.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const h=i.get(c);h===void 0?i.set(c,r(c,u)):h.version<c.version&&(s(h.buffer,c,u),h.version=c.version)}return{get:o,remove:a,update:l}}class Yd extends lt{constructor(e=1,t=1,i=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:i,heightSegments:r};const s=e/2,o=t/2,a=Math.floor(i),l=Math.floor(r),c=a+1,u=l+1,h=e/a,d=t/l,p=[],v=[],m=[],f=[];for(let g=0;g<u;g++){const _=g*d-o;for(let M=0;M<c;M++){const E=M*h-s;v.push(E,-_,0),m.push(0,0,1),f.push(M/a),f.push(1-g/l)}}for(let g=0;g<l;g++)for(let _=0;_<a;_++){const M=_+c*g,E=_+c*(g+1),S=_+1+c*(g+1),T=_+1+c*g;p.push(M,E,T),p.push(E,S,T)}this.setIndex(p),this.setAttribute("position",new rt(v,3)),this.setAttribute("normal",new rt(m,3)),this.setAttribute("uv",new rt(f,2))}static fromJSON(e){return new Yd(e.width,e.height,e.widthSegments,e.heightSegments)}}var PA=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,DA=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,IA=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,NA=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,FA=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,UA=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,OA="vec3 transformed = vec3( position );",BA=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,zA=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,kA=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,HA=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,GA=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,VA=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,WA=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,$A=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,XA=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,jA=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,qA=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,YA=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,KA=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,ZA=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,JA=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,QA=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,eC=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,tC=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,nC="gl_FragColor = linearToOutputTexel( gl_FragColor );",iC=`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,rC=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,sC=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,oC=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,aC=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,lC=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,cC=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,uC=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,hC=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,dC=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,fC=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,pC=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,mC=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,gC=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,vC=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,_C=`#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,xC=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,yC=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,MC=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,SC=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,wC=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,EC=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,bC=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,TC=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,AC=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,CC=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,RC=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,LC=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,PC=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,DC=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,IC=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,NC=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,FC=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,UC=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,OC=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,BC=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,zC=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,kC=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,HC=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,GC=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,VC=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,WC=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,$C=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,XC=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,jC=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,qC=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,YC=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,KC=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,ZC=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,JC=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,QC=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,eR=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,tR=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,nR=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,iR=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,rR=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,sR=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,oR=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,aR=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,lR=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,cR=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,uR=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,hR=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,dR=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,fR=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,pR=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,mR=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,gR=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,vR=`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,_R=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,xR=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,yR=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,MR=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,SR=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,wR=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,ER=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,bR=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const TR=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,AR=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,CR=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,RR=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,LR=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,PR=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,DR=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,IR=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,NR=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,FR=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,UR=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,OR=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,BR=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,zR=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,kR=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,HR=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,GR=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,VR=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,WR=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,$R=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,XR=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,jR=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,qR=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,YR=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,KR=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,ZR=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,JR=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,QR=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,e2=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,t2=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,n2=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,i2=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Ye={alphamap_fragment:PA,alphamap_pars_fragment:DA,alphatest_fragment:IA,alphatest_pars_fragment:NA,aomap_fragment:FA,aomap_pars_fragment:UA,begin_vertex:OA,beginnormal_vertex:BA,bsdfs:zA,bumpmap_pars_fragment:kA,clipping_planes_fragment:HA,clipping_planes_pars_fragment:GA,clipping_planes_pars_vertex:VA,clipping_planes_vertex:WA,color_fragment:$A,color_pars_fragment:XA,color_pars_vertex:jA,color_vertex:qA,common:YA,cube_uv_reflection_fragment:KA,defaultnormal_vertex:ZA,displacementmap_pars_vertex:JA,displacementmap_vertex:QA,emissivemap_fragment:eC,emissivemap_pars_fragment:tC,encodings_fragment:nC,encodings_pars_fragment:iC,envmap_fragment:rC,envmap_common_pars_fragment:sC,envmap_pars_fragment:oC,envmap_pars_vertex:aC,envmap_physical_pars_fragment:_C,envmap_vertex:lC,fog_vertex:cC,fog_pars_vertex:uC,fog_fragment:hC,fog_pars_fragment:dC,gradientmap_pars_fragment:fC,lightmap_fragment:pC,lightmap_pars_fragment:mC,lights_lambert_vertex:gC,lights_pars_begin:vC,lights_toon_fragment:xC,lights_toon_pars_fragment:yC,lights_phong_fragment:MC,lights_phong_pars_fragment:SC,lights_physical_fragment:wC,lights_physical_pars_fragment:EC,lights_fragment_begin:bC,lights_fragment_maps:TC,lights_fragment_end:AC,logdepthbuf_fragment:CC,logdepthbuf_pars_fragment:RC,logdepthbuf_pars_vertex:LC,logdepthbuf_vertex:PC,map_fragment:DC,map_pars_fragment:IC,map_particle_fragment:NC,map_particle_pars_fragment:FC,metalnessmap_fragment:UC,metalnessmap_pars_fragment:OC,morphcolor_vertex:BC,morphnormal_vertex:zC,morphtarget_pars_vertex:kC,morphtarget_vertex:HC,normal_fragment_begin:GC,normal_fragment_maps:VC,normal_pars_fragment:WC,normal_pars_vertex:$C,normal_vertex:XC,normalmap_pars_fragment:jC,clearcoat_normal_fragment_begin:qC,clearcoat_normal_fragment_maps:YC,clearcoat_pars_fragment:KC,output_fragment:ZC,packing:JC,premultiplied_alpha_fragment:QC,project_vertex:eR,dithering_fragment:tR,dithering_pars_fragment:nR,roughnessmap_fragment:iR,roughnessmap_pars_fragment:rR,shadowmap_pars_fragment:sR,shadowmap_pars_vertex:oR,shadowmap_vertex:aR,shadowmask_pars_fragment:lR,skinbase_vertex:cR,skinning_pars_vertex:uR,skinning_vertex:hR,skinnormal_vertex:dR,specularmap_fragment:fR,specularmap_pars_fragment:pR,tonemapping_fragment:mR,tonemapping_pars_fragment:gR,transmission_fragment:vR,transmission_pars_fragment:_R,uv_pars_fragment:xR,uv_pars_vertex:yR,uv_vertex:MR,uv2_pars_fragment:SR,uv2_pars_vertex:wR,uv2_vertex:ER,worldpos_vertex:bR,background_vert:TR,background_frag:AR,cube_vert:CR,cube_frag:RR,depth_vert:LR,depth_frag:PR,distanceRGBA_vert:DR,distanceRGBA_frag:IR,equirect_vert:NR,equirect_frag:FR,linedashed_vert:UR,linedashed_frag:OR,meshbasic_vert:BR,meshbasic_frag:zR,meshlambert_vert:kR,meshlambert_frag:HR,meshmatcap_vert:GR,meshmatcap_frag:VR,meshnormal_vert:WR,meshnormal_frag:$R,meshphong_vert:XR,meshphong_frag:jR,meshphysical_vert:qR,meshphysical_frag:YR,meshtoon_vert:KR,meshtoon_frag:ZR,points_vert:JR,points_frag:QR,shadow_vert:e2,shadow_frag:t2,sprite_vert:n2,sprite_frag:i2},Le={common:{diffuse:{value:new we(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new sn},uv2Transform:{value:new sn},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new fe(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new we(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new we(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new sn}},sprite:{diffuse:{value:new we(16777215)},opacity:{value:1},center:{value:new fe(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new sn}}},Yi={basic:{uniforms:fn([Le.common,Le.specularmap,Le.envmap,Le.aomap,Le.lightmap,Le.fog]),vertexShader:Ye.meshbasic_vert,fragmentShader:Ye.meshbasic_frag},lambert:{uniforms:fn([Le.common,Le.specularmap,Le.envmap,Le.aomap,Le.lightmap,Le.emissivemap,Le.fog,Le.lights,{emissive:{value:new we(0)}}]),vertexShader:Ye.meshlambert_vert,fragmentShader:Ye.meshlambert_frag},phong:{uniforms:fn([Le.common,Le.specularmap,Le.envmap,Le.aomap,Le.lightmap,Le.emissivemap,Le.bumpmap,Le.normalmap,Le.displacementmap,Le.fog,Le.lights,{emissive:{value:new we(0)},specular:{value:new we(1118481)},shininess:{value:30}}]),vertexShader:Ye.meshphong_vert,fragmentShader:Ye.meshphong_frag},standard:{uniforms:fn([Le.common,Le.envmap,Le.aomap,Le.lightmap,Le.emissivemap,Le.bumpmap,Le.normalmap,Le.displacementmap,Le.roughnessmap,Le.metalnessmap,Le.fog,Le.lights,{emissive:{value:new we(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Ye.meshphysical_vert,fragmentShader:Ye.meshphysical_frag},toon:{uniforms:fn([Le.common,Le.aomap,Le.lightmap,Le.emissivemap,Le.bumpmap,Le.normalmap,Le.displacementmap,Le.gradientmap,Le.fog,Le.lights,{emissive:{value:new we(0)}}]),vertexShader:Ye.meshtoon_vert,fragmentShader:Ye.meshtoon_frag},matcap:{uniforms:fn([Le.common,Le.bumpmap,Le.normalmap,Le.displacementmap,Le.fog,{matcap:{value:null}}]),vertexShader:Ye.meshmatcap_vert,fragmentShader:Ye.meshmatcap_frag},points:{uniforms:fn([Le.points,Le.fog]),vertexShader:Ye.points_vert,fragmentShader:Ye.points_frag},dashed:{uniforms:fn([Le.common,Le.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Ye.linedashed_vert,fragmentShader:Ye.linedashed_frag},depth:{uniforms:fn([Le.common,Le.displacementmap]),vertexShader:Ye.depth_vert,fragmentShader:Ye.depth_frag},normal:{uniforms:fn([Le.common,Le.bumpmap,Le.normalmap,Le.displacementmap,{opacity:{value:1}}]),vertexShader:Ye.meshnormal_vert,fragmentShader:Ye.meshnormal_frag},sprite:{uniforms:fn([Le.sprite,Le.fog]),vertexShader:Ye.sprite_vert,fragmentShader:Ye.sprite_frag},background:{uniforms:{uvTransform:{value:new sn},t2D:{value:null}},vertexShader:Ye.background_vert,fragmentShader:Ye.background_frag},cube:{uniforms:fn([Le.envmap,{opacity:{value:1}}]),vertexShader:Ye.cube_vert,fragmentShader:Ye.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Ye.equirect_vert,fragmentShader:Ye.equirect_frag},distanceRGBA:{uniforms:fn([Le.common,Le.displacementmap,{referencePosition:{value:new B},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Ye.distanceRGBA_vert,fragmentShader:Ye.distanceRGBA_frag},shadow:{uniforms:fn([Le.lights,Le.fog,{color:{value:new we(0)},opacity:{value:1}}]),vertexShader:Ye.shadow_vert,fragmentShader:Ye.shadow_frag}};Yi.physical={uniforms:fn([Yi.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new fe(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new we(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new fe},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new we(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new we(1,1,1)},specularColorMap:{value:null}}]),vertexShader:Ye.meshphysical_vert,fragmentShader:Ye.meshphysical_frag};function r2(n,e,t,i,r,s){const o=new we(0);let a=r===!0?0:1,l,c,u=null,h=0,d=null;function p(m,f){let g=!1,_=f.isScene===!0?f.background:null;_&&_.isTexture&&(_=e.get(_));const M=n.xr,E=M.getSession&&M.getSession();E&&E.environmentBlendMode==="additive"&&(_=null),_===null?v(o,a):_&&_.isColor&&(v(_,1),g=!0),(n.autoClear||g)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),_&&(_.isCubeTexture||_.mapping===$d)?(c===void 0&&(c=new dt(new Ji(1,1,1),new Zt({name:"BackgroundCubeMaterial",uniforms:Ja(Yi.cube.uniforms),vertexShader:Yi.cube.vertexShader,fragmentShader:Yi.cube.fragmentShader,side:Bi,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(S,T,R){this.matrixWorld.copyPosition(R.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(c)),c.material.uniforms.envMap.value=_,c.material.uniforms.flipEnvMap.value=_.isCubeTexture&&_.isRenderTargetTexture===!1?-1:1,(u!==_||h!==_.version||d!==n.toneMapping)&&(c.material.needsUpdate=!0,u=_,h=_.version,d=n.toneMapping),c.layers.enableAll(),m.unshift(c,c.geometry,c.material,0,0,null)):_&&_.isTexture&&(l===void 0&&(l=new dt(new Yd(2,2),new Zt({name:"BackgroundMaterial",uniforms:Ja(Yi.background.uniforms),vertexShader:Yi.background.vertexShader,fragmentShader:Yi.background.fragmentShader,side:Xa,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(l)),l.material.uniforms.t2D.value=_,_.matrixAutoUpdate===!0&&_.updateMatrix(),l.material.uniforms.uvTransform.value.copy(_.matrix),(u!==_||h!==_.version||d!==n.toneMapping)&&(l.material.needsUpdate=!0,u=_,h=_.version,d=n.toneMapping),l.layers.enableAll(),m.unshift(l,l.geometry,l.material,0,0,null))}function v(m,f){t.buffers.color.setClear(m.r,m.g,m.b,f,s)}return{getClearColor:function(){return o},setClearColor:function(m,f=1){o.set(m),a=f,v(o,a)},getClearAlpha:function(){return a},setClearAlpha:function(m){a=m,v(o,a)},render:p}}function s2(n,e,t,i){const r=n.getParameter(34921),s=i.isWebGL2?null:e.get("OES_vertex_array_object"),o=i.isWebGL2||s!==null,a={},l=f(null);let c=l,u=!1;function h(L,$,z,W,U){let P=!1;if(o){const k=m(W,z,$);c!==k&&(c=k,p(c.object)),P=g(L,W,z,U),P&&_(L,W,z,U)}else{const k=$.wireframe===!0;(c.geometry!==W.id||c.program!==z.id||c.wireframe!==k)&&(c.geometry=W.id,c.program=z.id,c.wireframe=k,P=!0)}U!==null&&t.update(U,34963),(P||u)&&(u=!1,x(L,$,z,W),U!==null&&n.bindBuffer(34963,t.get(U).buffer))}function d(){return i.isWebGL2?n.createVertexArray():s.createVertexArrayOES()}function p(L){return i.isWebGL2?n.bindVertexArray(L):s.bindVertexArrayOES(L)}function v(L){return i.isWebGL2?n.deleteVertexArray(L):s.deleteVertexArrayOES(L)}function m(L,$,z){const W=z.wireframe===!0;let U=a[L.id];U===void 0&&(U={},a[L.id]=U);let P=U[$.id];P===void 0&&(P={},U[$.id]=P);let k=P[W];return k===void 0&&(k=f(d()),P[W]=k),k}function f(L){const $=[],z=[],W=[];for(let U=0;U<r;U++)$[U]=0,z[U]=0,W[U]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:$,enabledAttributes:z,attributeDivisors:W,object:L,attributes:{},index:null}}function g(L,$,z,W){const U=c.attributes,P=$.attributes;let k=0;const Y=z.getAttributes();for(const j in Y)if(Y[j].location>=0){const ce=U[j];let de=P[j];if(de===void 0&&(j==="instanceMatrix"&&L.instanceMatrix&&(de=L.instanceMatrix),j==="instanceColor"&&L.instanceColor&&(de=L.instanceColor)),ce===void 0||ce.attribute!==de||de&&ce.data!==de.data)return!0;k++}return c.attributesNum!==k||c.index!==W}function _(L,$,z,W){const U={},P=$.attributes;let k=0;const Y=z.getAttributes();for(const j in Y)if(Y[j].location>=0){let ce=P[j];ce===void 0&&(j==="instanceMatrix"&&L.instanceMatrix&&(ce=L.instanceMatrix),j==="instanceColor"&&L.instanceColor&&(ce=L.instanceColor));const de={};de.attribute=ce,ce&&ce.data&&(de.data=ce.data),U[j]=de,k++}c.attributes=U,c.attributesNum=k,c.index=W}function M(){const L=c.newAttributes;for(let $=0,z=L.length;$<z;$++)L[$]=0}function E(L){S(L,0)}function S(L,$){const z=c.newAttributes,W=c.enabledAttributes,U=c.attributeDivisors;z[L]=1,W[L]===0&&(n.enableVertexAttribArray(L),W[L]=1),U[L]!==$&&((i.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](L,$),U[L]=$)}function T(){const L=c.newAttributes,$=c.enabledAttributes;for(let z=0,W=$.length;z<W;z++)$[z]!==L[z]&&(n.disableVertexAttribArray(z),$[z]=0)}function R(L,$,z,W,U,P){i.isWebGL2===!0&&(z===5124||z===5125)?n.vertexAttribIPointer(L,$,z,U,P):n.vertexAttribPointer(L,$,z,W,U,P)}function x(L,$,z,W){if(i.isWebGL2===!1&&(L.isInstancedMesh||W.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;M();const U=W.attributes,P=z.getAttributes(),k=$.defaultAttributeValues;for(const Y in P){const j=P[Y];if(j.location>=0){let K=U[Y];if(K===void 0&&(Y==="instanceMatrix"&&L.instanceMatrix&&(K=L.instanceMatrix),Y==="instanceColor"&&L.instanceColor&&(K=L.instanceColor)),K!==void 0){const ce=K.normalized,de=K.itemSize,F=t.get(K);if(F===void 0)continue;const We=F.buffer,Me=F.type,Ce=F.bytesPerElement;if(K.isInterleavedBufferAttribute){const re=K.data,ze=re.stride,oe=K.offset;if(re.isInstancedInterleavedBuffer){for(let ne=0;ne<j.locationSize;ne++)S(j.location+ne,re.meshPerAttribute);L.isInstancedMesh!==!0&&W._maxInstanceCount===void 0&&(W._maxInstanceCount=re.meshPerAttribute*re.count)}else for(let ne=0;ne<j.locationSize;ne++)E(j.location+ne);n.bindBuffer(34962,We);for(let ne=0;ne<j.locationSize;ne++)R(j.location+ne,de/j.locationSize,Me,ce,ze*Ce,(oe+de/j.locationSize*ne)*Ce)}else{if(K.isInstancedBufferAttribute){for(let re=0;re<j.locationSize;re++)S(j.location+re,K.meshPerAttribute);L.isInstancedMesh!==!0&&W._maxInstanceCount===void 0&&(W._maxInstanceCount=K.meshPerAttribute*K.count)}else for(let re=0;re<j.locationSize;re++)E(j.location+re);n.bindBuffer(34962,We);for(let re=0;re<j.locationSize;re++)R(j.location+re,de/j.locationSize,Me,ce,de*Ce,de/j.locationSize*re*Ce)}}else if(k!==void 0){const ce=k[Y];if(ce!==void 0)switch(ce.length){case 2:n.vertexAttrib2fv(j.location,ce);break;case 3:n.vertexAttrib3fv(j.location,ce);break;case 4:n.vertexAttrib4fv(j.location,ce);break;default:n.vertexAttrib1fv(j.location,ce)}}}}T()}function A(){J();for(const L in a){const $=a[L];for(const z in $){const W=$[z];for(const U in W)v(W[U].object),delete W[U];delete $[z]}delete a[L]}}function I(L){if(a[L.id]===void 0)return;const $=a[L.id];for(const z in $){const W=$[z];for(const U in W)v(W[U].object),delete W[U];delete $[z]}delete a[L.id]}function N(L){for(const $ in a){const z=a[$];if(z[L.id]===void 0)continue;const W=z[L.id];for(const U in W)v(W[U].object),delete W[U];delete z[L.id]}}function J(){q(),u=!0,c!==l&&(c=l,p(c.object))}function q(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:h,reset:J,resetDefaultState:q,dispose:A,releaseStatesOfGeometry:I,releaseStatesOfProgram:N,initAttributes:M,enableAttribute:E,disableUnusedAttributes:T}}function o2(n,e,t,i){const r=i.isWebGL2;let s;function o(c){s=c}function a(c,u){n.drawArrays(s,c,u),t.update(u,s,1)}function l(c,u,h){if(h===0)return;let d,p;if(r)d=n,p="drawArraysInstanced";else if(d=e.get("ANGLE_instanced_arrays"),p="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[p](s,c,u,h),t.update(u,s,h)}this.setMode=o,this.render=a,this.renderInstances=l}function a2(n,e,t){let i;function r(){if(i!==void 0)return i;if(e.has("EXT_texture_filter_anisotropic")===!0){const R=e.get("EXT_texture_filter_anisotropic");i=n.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}function s(R){if(R==="highp"){if(n.getShaderPrecisionFormat(35633,36338).precision>0&&n.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";R="mediump"}return R==="mediump"&&n.getShaderPrecisionFormat(35633,36337).precision>0&&n.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext!="undefined"&&n instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&n instanceof WebGL2ComputeRenderingContext;let a=t.precision!==void 0?t.precision:"highp";const l=s(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const c=o||e.has("WEBGL_draw_buffers"),u=t.logarithmicDepthBuffer===!0,h=n.getParameter(34930),d=n.getParameter(35660),p=n.getParameter(3379),v=n.getParameter(34076),m=n.getParameter(34921),f=n.getParameter(36347),g=n.getParameter(36348),_=n.getParameter(36349),M=d>0,E=o||e.has("OES_texture_float"),S=M&&E,T=o?n.getParameter(36183):0;return{isWebGL2:o,drawBuffers:c,getMaxAnisotropy:r,getMaxPrecision:s,precision:a,logarithmicDepthBuffer:u,maxTextures:h,maxVertexTextures:d,maxTextureSize:p,maxCubemapSize:v,maxAttributes:m,maxVertexUniforms:f,maxVaryings:g,maxFragmentUniforms:_,vertexTextures:M,floatFragmentTextures:E,floatVertexTextures:S,maxSamples:T}}function l2(n){const e=this;let t=null,i=0,r=!1,s=!1;const o=new Mr,a=new sn,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(h,d,p){const v=h.length!==0||d||i!==0||r;return r=d,t=u(h,p,0),i=h.length,v},this.beginShadows=function(){s=!0,u(null)},this.endShadows=function(){s=!1,c()},this.setState=function(h,d,p){const v=h.clippingPlanes,m=h.clipIntersection,f=h.clipShadows,g=n.get(h);if(!r||v===null||v.length===0||s&&!f)s?u(null):c();else{const _=s?0:i,M=_*4;let E=g.clippingState||null;l.value=E,E=u(v,d,M,p);for(let S=0;S!==M;++S)E[S]=t[S];g.clippingState=E,this.numIntersection=m?this.numPlanes:0,this.numPlanes+=_}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=i>0),e.numPlanes=i,e.numIntersection=0}function u(h,d,p,v){const m=h!==null?h.length:0;let f=null;if(m!==0){if(f=l.value,v!==!0||f===null){const g=p+m*4,_=d.matrixWorldInverse;a.getNormalMatrix(_),(f===null||f.length<g)&&(f=new Float32Array(g));for(let M=0,E=p;M!==m;++M,E+=4)o.copy(h[M]).applyMatrix4(_,a),o.normal.toArray(f,E),f[E+3]=o.constant}l.value=f,l.needsUpdate=!0}return e.numPlanes=m,e.numIntersection=0,f}}function c2(n){let e=new WeakMap;function t(o,a){return a===zm?o.mapping=ja:a===km&&(o.mapping=qa),o}function i(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const a=o.mapping;if(a===zm||a===km)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=new US(l.height/2);return c.fromEquirectangularTexture(n,o),e.set(o,c),o.addEventListener("dispose",r),t(c.texture,o.mapping)}else return null}}return o}function r(o){const a=o.target;a.removeEventListener("dispose",r);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function s(){e=new WeakMap}return{get:i,dispose:s}}class yl extends c0{constructor(e=-1,t=1,i=1,r=-1,s=.1,o=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=i,this.bottom=r,this.near=s,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,i,r,s,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=r,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let s=i-e,o=i+e,a=r+t,l=r-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=c*this.view.offsetX,o=s+c*this.view.width,a-=u*this.view.offsetY,l=a-u*this.view.height}this.projectionMatrix.makeOrthographic(s,o,a,l,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}yl.prototype.isOrthographicCamera=!0;const ya=4,D_=[.125,.215,.35,.446,.526,.582],Js=20,ap=new yl,I_=new we;let lp=null;const Xs=(1+Math.sqrt(5))/2,Xo=1/Xs,N_=[new B(1,1,1),new B(-1,1,1),new B(1,1,-1),new B(-1,1,-1),new B(0,Xs,Xo),new B(0,Xs,-Xo),new B(Xo,0,Xs),new B(-Xo,0,Xs),new B(Xs,Xo,0),new B(-Xs,Xo,0)];class F_{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,i=.1,r=100){lp=this._renderer.getRenderTarget(),this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(e,i,r,s),t>0&&this._blur(s,0,0,t),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=B_(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=O_(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(lp),e.scissorTest=!1,qu(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===ja||e.mapping===qa?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),lp=this._renderer.getRenderTarget();const i=t||this._allocateTargets();return this._textureToCubeUV(e,i),this._applyPMREM(i),this._cleanup(i),i}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,i={magFilter:mn,minFilter:mn,generateMipmaps:!1,type:Fc,format:ui,encoding:bs,depthBuffer:!1},r=U_(e,t,i);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=U_(e,t,i);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=u2(s)),this._blurMaterial=h2(s,e,t)}return r}_compileMaterial(e){const t=new dt(this._lodPlanes[0],e);this._renderer.compile(t,ap)}_sceneToCubeUV(e,t,i,r){const a=new gn(90,1,t,i),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],u=this._renderer,h=u.autoClear,d=u.toneMapping;u.getClearColor(I_),u.toneMapping=Ar,u.autoClear=!1;const p=new Fn({name:"PMREM.Background",side:Bi,depthWrite:!1,depthTest:!1}),v=new dt(new Ji,p);let m=!1;const f=e.background;f?f.isColor&&(p.color.copy(f),e.background=null,m=!0):(p.color.copy(I_),m=!0);for(let g=0;g<6;g++){const _=g%3;_===0?(a.up.set(0,l[g],0),a.lookAt(c[g],0,0)):_===1?(a.up.set(0,0,l[g]),a.lookAt(0,c[g],0)):(a.up.set(0,l[g],0),a.lookAt(0,0,c[g]));const M=this._cubeSize;qu(r,_*M,g>2?M:0,M,M),u.setRenderTarget(r),m&&u.render(v,a),u.render(e,a)}v.geometry.dispose(),v.material.dispose(),u.toneMapping=d,u.autoClear=h,e.background=f}_textureToCubeUV(e,t){const i=this._renderer,r=e.mapping===ja||e.mapping===qa;r?(this._cubemapMaterial===null&&(this._cubemapMaterial=B_()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=O_());const s=r?this._cubemapMaterial:this._equirectMaterial,o=new dt(this._lodPlanes[0],s),a=s.uniforms;a.envMap.value=e;const l=this._cubeSize;qu(t,0,0,3*l,2*l),i.setRenderTarget(t),i.render(o,ap)}_applyPMREM(e){const t=this._renderer,i=t.autoClear;t.autoClear=!1;for(let r=1;r<this._lodPlanes.length;r++){const s=Math.sqrt(this._sigmas[r]*this._sigmas[r]-this._sigmas[r-1]*this._sigmas[r-1]),o=N_[(r-1)%N_.length];this._blur(e,r-1,r,s,o)}t.autoClear=i}_blur(e,t,i,r,s){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,i,r,"latitudinal",s),this._halfBlur(o,e,i,i,r,"longitudinal",s)}_halfBlur(e,t,i,r,s,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,h=new dt(this._lodPlanes[r],c),d=c.uniforms,p=this._sizeLods[i]-1,v=isFinite(s)?Math.PI/(2*p):2*Math.PI/(2*Js-1),m=s/v,f=isFinite(s)?1+Math.floor(u*m):Js;f>Js&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${f} samples when the maximum is set to ${Js}`);const g=[];let _=0;for(let R=0;R<Js;++R){const x=R/m,A=Math.exp(-x*x/2);g.push(A),R===0?_+=A:R<f&&(_+=2*A)}for(let R=0;R<g.length;R++)g[R]=g[R]/_;d.envMap.value=e.texture,d.samples.value=f,d.weights.value=g,d.latitudinal.value=o==="latitudinal",a&&(d.poleAxis.value=a);const{_lodMax:M}=this;d.dTheta.value=v,d.mipInt.value=M-i;const E=this._sizeLods[r],S=3*E*(r>M-ya?r-M+ya:0),T=4*(this._cubeSize-E);qu(t,S,T,3*E,2*E),l.setRenderTarget(t),l.render(h,ap)}}function u2(n){const e=[],t=[],i=[];let r=n;const s=n-ya+1+D_.length;for(let o=0;o<s;o++){const a=Math.pow(2,r);t.push(a);let l=1/a;o>n-ya?l=D_[o-n+ya-1]:o===0&&(l=0),i.push(l);const c=1/(a-2),u=-c,h=1+c,d=[u,u,h,u,h,h,u,u,h,h,u,h],p=6,v=6,m=3,f=2,g=1,_=new Float32Array(m*v*p),M=new Float32Array(f*v*p),E=new Float32Array(g*v*p);for(let T=0;T<p;T++){const R=T%3*2/3-1,x=T>2?0:-1,A=[R,x,0,R+2/3,x,0,R+2/3,x+1,0,R,x,0,R+2/3,x+1,0,R,x+1,0];_.set(A,m*v*T),M.set(d,f*v*T);const I=[T,T,T,T,T,T];E.set(I,g*v*T)}const S=new lt;S.setAttribute("position",new Ut(_,m)),S.setAttribute("uv",new Ut(M,f)),S.setAttribute("faceIndex",new Ut(E,g)),e.push(S),r>ya&&r--}return{lodPlanes:e,sizeLods:t,sigmas:i}}function U_(n,e,t){const i=new on(n,e,t);return i.texture.mapping=$d,i.texture.name="PMREM.cubeUv",i.scissorTest=!0,i}function qu(n,e,t,i,r){n.viewport.set(e,t,i,r),n.scissor.set(e,t,i,r)}function h2(n,e,t){const i=new Float32Array(Js),r=new B(0,1,0);return new Zt({name:"SphericalGaussianBlur",defines:{n:Js,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:i},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:r}},vertexShader:h0(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:hs,depthTest:!1,depthWrite:!1})}function O_(){return new Zt({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:h0(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:hs,depthTest:!1,depthWrite:!1})}function B_(){return new Zt({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:h0(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:hs,depthTest:!1,depthWrite:!1})}function h0(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function d2(n){let e=new WeakMap,t=null;function i(a){if(a&&a.isTexture){const l=a.mapping,c=l===zm||l===km,u=l===ja||l===qa;if(c||u)if(a.isRenderTargetTexture&&a.needsPMREMUpdate===!0){a.needsPMREMUpdate=!1;let h=e.get(a);return t===null&&(t=new F_(n)),h=c?t.fromEquirectangular(a,h):t.fromCubemap(a,h),e.set(a,h),h.texture}else{if(e.has(a))return e.get(a).texture;{const h=a.image;if(c&&h&&h.height>0||u&&h&&r(h)){t===null&&(t=new F_(n));const d=c?t.fromEquirectangular(a):t.fromCubemap(a);return e.set(a,d),a.addEventListener("dispose",s),d.texture}else return null}}}return a}function r(a){let l=0;const c=6;for(let u=0;u<c;u++)a[u]!==void 0&&l++;return l===c}function s(a){const l=a.target;l.removeEventListener("dispose",s);const c=e.get(l);c!==void 0&&(e.delete(l),c.dispose())}function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:i,dispose:o}}function f2(n){const e={};function t(i){if(e[i]!==void 0)return e[i];let r;switch(i){case"WEBGL_depth_texture":r=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=n.getExtension(i)}return e[i]=r,r}return{has:function(i){return t(i)!==null},init:function(i){i.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(i){const r=t(i);return r===null&&console.warn("THREE.WebGLRenderer: "+i+" extension not supported."),r}}}function p2(n,e,t,i){const r={},s=new WeakMap;function o(h){const d=h.target;d.index!==null&&e.remove(d.index);for(const v in d.attributes)e.remove(d.attributes[v]);d.removeEventListener("dispose",o),delete r[d.id];const p=s.get(d);p&&(e.remove(p),s.delete(d)),i.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}function a(h,d){return r[d.id]===!0||(d.addEventListener("dispose",o),r[d.id]=!0,t.memory.geometries++),d}function l(h){const d=h.attributes;for(const v in d)e.update(d[v],34962);const p=h.morphAttributes;for(const v in p){const m=p[v];for(let f=0,g=m.length;f<g;f++)e.update(m[f],34962)}}function c(h){const d=[],p=h.index,v=h.attributes.position;let m=0;if(p!==null){const _=p.array;m=p.version;for(let M=0,E=_.length;M<E;M+=3){const S=_[M+0],T=_[M+1],R=_[M+2];d.push(S,T,T,R,R,S)}}else{const _=v.array;m=v.version;for(let M=0,E=_.length/3-1;M<E;M+=3){const S=M+0,T=M+1,R=M+2;d.push(S,T,T,R,R,S)}}const f=new(LS(d)?FS:NS)(d,1);f.version=m;const g=s.get(h);g&&e.remove(g),s.set(h,f)}function u(h){const d=s.get(h);if(d){const p=h.index;p!==null&&d.version<p.version&&c(h)}else c(h);return s.get(h)}return{get:a,update:l,getWireframeAttribute:u}}function m2(n,e,t,i){const r=i.isWebGL2;let s;function o(d){s=d}let a,l;function c(d){a=d.type,l=d.bytesPerElement}function u(d,p){n.drawElements(s,p,a,d*l),t.update(p,s,1)}function h(d,p,v){if(v===0)return;let m,f;if(r)m=n,f="drawElementsInstanced";else if(m=e.get("ANGLE_instanced_arrays"),f="drawElementsInstancedANGLE",m===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[f](s,p,a,d*l,v),t.update(p,s,v)}this.setMode=o,this.setIndex=c,this.render=u,this.renderInstances=h}function g2(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function i(s,o,a){switch(t.calls++,o){case 4:t.triangles+=a*(s/3);break;case 1:t.lines+=a*(s/2);break;case 3:t.lines+=a*(s-1);break;case 2:t.lines+=a*s;break;case 0:t.points+=a*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function r(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:r,update:i}}function v2(n,e){return n[0]-e[0]}function _2(n,e){return Math.abs(e[1])-Math.abs(n[1])}function cp(n,e){let t=1;const i=e.isInterleavedBufferAttribute?e.data.array:e.array;i instanceof Int8Array?t=127:i instanceof Int16Array?t=32767:i instanceof Int32Array?t=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",i),n.divideScalar(t)}function x2(n,e,t){const i={},r=new Float32Array(8),s=new WeakMap,o=new ut,a=[];for(let c=0;c<8;c++)a[c]=[c,0];function l(c,u,h,d){const p=c.morphTargetInfluences;if(e.isWebGL2===!0){const m=u.morphAttributes.position||u.morphAttributes.normal||u.morphAttributes.color,f=m!==void 0?m.length:0;let g=s.get(u);if(g===void 0||g.count!==f){let z=function(){L.dispose(),s.delete(u),u.removeEventListener("dispose",z)};var v=z;g!==void 0&&g.texture.dispose();const E=u.morphAttributes.position!==void 0,S=u.morphAttributes.normal!==void 0,T=u.morphAttributes.color!==void 0,R=u.morphAttributes.position||[],x=u.morphAttributes.normal||[],A=u.morphAttributes.color||[];let I=0;E===!0&&(I=1),S===!0&&(I=2),T===!0&&(I=3);let N=u.attributes.position.count*I,J=1;N>e.maxTextureSize&&(J=Math.ceil(N/e.maxTextureSize),N=e.maxTextureSize);const q=new Float32Array(N*J*4*f),L=new Xd(q,N,J,f);L.type=ls,L.needsUpdate=!0;const $=I*4;for(let W=0;W<f;W++){const U=R[W],P=x[W],k=A[W],Y=N*J*4*W;for(let j=0;j<U.count;j++){const K=j*$;E===!0&&(o.fromBufferAttribute(U,j),U.normalized===!0&&cp(o,U),q[Y+K+0]=o.x,q[Y+K+1]=o.y,q[Y+K+2]=o.z,q[Y+K+3]=0),S===!0&&(o.fromBufferAttribute(P,j),P.normalized===!0&&cp(o,P),q[Y+K+4]=o.x,q[Y+K+5]=o.y,q[Y+K+6]=o.z,q[Y+K+7]=0),T===!0&&(o.fromBufferAttribute(k,j),k.normalized===!0&&cp(o,k),q[Y+K+8]=o.x,q[Y+K+9]=o.y,q[Y+K+10]=o.z,q[Y+K+11]=k.itemSize===4?o.w:1)}}g={count:f,texture:L,size:new fe(N,J)},s.set(u,g),u.addEventListener("dispose",z)}let _=0;for(let E=0;E<p.length;E++)_+=p[E];const M=u.morphTargetsRelative?1:1-_;d.getUniforms().setValue(n,"morphTargetBaseInfluence",M),d.getUniforms().setValue(n,"morphTargetInfluences",p),d.getUniforms().setValue(n,"morphTargetsTexture",g.texture,t),d.getUniforms().setValue(n,"morphTargetsTextureSize",g.size)}else{const m=p===void 0?0:p.length;let f=i[u.id];if(f===void 0||f.length!==m){f=[];for(let S=0;S<m;S++)f[S]=[S,0];i[u.id]=f}for(let S=0;S<m;S++){const T=f[S];T[0]=S,T[1]=p[S]}f.sort(_2);for(let S=0;S<8;S++)S<m&&f[S][1]?(a[S][0]=f[S][0],a[S][1]=f[S][1]):(a[S][0]=Number.MAX_SAFE_INTEGER,a[S][1]=0);a.sort(v2);const g=u.morphAttributes.position,_=u.morphAttributes.normal;let M=0;for(let S=0;S<8;S++){const T=a[S],R=T[0],x=T[1];R!==Number.MAX_SAFE_INTEGER&&x?(g&&u.getAttribute("morphTarget"+S)!==g[R]&&u.setAttribute("morphTarget"+S,g[R]),_&&u.getAttribute("morphNormal"+S)!==_[R]&&u.setAttribute("morphNormal"+S,_[R]),r[S]=x,M+=x):(g&&u.hasAttribute("morphTarget"+S)===!0&&u.deleteAttribute("morphTarget"+S),_&&u.hasAttribute("morphNormal"+S)===!0&&u.deleteAttribute("morphNormal"+S),r[S]=0)}const E=u.morphTargetsRelative?1:1-M;d.getUniforms().setValue(n,"morphTargetBaseInfluence",E),d.getUniforms().setValue(n,"morphTargetInfluences",r)}}return{update:l}}function y2(n,e,t,i){let r=new WeakMap;function s(l){const c=i.render.frame,u=l.geometry,h=e.get(l,u);return r.get(h)!==c&&(e.update(h),r.set(h,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),t.update(l.instanceMatrix,34962),l.instanceColor!==null&&t.update(l.instanceColor,34962)),h}function o(){r=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:s,dispose:o}}const BS=new Ht,zS=new Xd,kS=new l0,HS=new jd,z_=[],k_=[],H_=new Float32Array(16),G_=new Float32Array(9),V_=new Float32Array(4);function Ml(n,e,t){const i=n[0];if(i<=0||i>0)return n;const r=e*t;let s=z_[r];if(s===void 0&&(s=new Float32Array(r),z_[r]=s),e!==0){i.toArray(s,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(s,a)}return s}function An(n,e){if(n.length!==e.length)return!1;for(let t=0,i=n.length;t<i;t++)if(n[t]!==e[t])return!1;return!0}function Cn(n,e){for(let t=0,i=e.length;t<i;t++)n[t]=e[t]}function Kd(n,e){let t=k_[e];t===void 0&&(t=new Int32Array(e),k_[e]=t);for(let i=0;i!==e;++i)t[i]=n.allocateTextureUnit();return t}function M2(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function S2(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(An(t,e))return;n.uniform2fv(this.addr,e),Cn(t,e)}}function w2(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(An(t,e))return;n.uniform3fv(this.addr,e),Cn(t,e)}}function E2(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(An(t,e))return;n.uniform4fv(this.addr,e),Cn(t,e)}}function b2(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(An(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Cn(t,e)}else{if(An(t,i))return;V_.set(i),n.uniformMatrix2fv(this.addr,!1,V_),Cn(t,i)}}function T2(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(An(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Cn(t,e)}else{if(An(t,i))return;G_.set(i),n.uniformMatrix3fv(this.addr,!1,G_),Cn(t,i)}}function A2(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(An(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Cn(t,e)}else{if(An(t,i))return;H_.set(i),n.uniformMatrix4fv(this.addr,!1,H_),Cn(t,i)}}function C2(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function R2(n,e){const t=this.cache;An(t,e)||(n.uniform2iv(this.addr,e),Cn(t,e))}function L2(n,e){const t=this.cache;An(t,e)||(n.uniform3iv(this.addr,e),Cn(t,e))}function P2(n,e){const t=this.cache;An(t,e)||(n.uniform4iv(this.addr,e),Cn(t,e))}function D2(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function I2(n,e){const t=this.cache;An(t,e)||(n.uniform2uiv(this.addr,e),Cn(t,e))}function N2(n,e){const t=this.cache;An(t,e)||(n.uniform3uiv(this.addr,e),Cn(t,e))}function F2(n,e){const t=this.cache;An(t,e)||(n.uniform4uiv(this.addr,e),Cn(t,e))}function U2(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTexture2D(e||BS,r)}function O2(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTexture3D(e||kS,r)}function B2(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTextureCube(e||HS,r)}function z2(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTexture2DArray(e||zS,r)}function k2(n){switch(n){case 5126:return M2;case 35664:return S2;case 35665:return w2;case 35666:return E2;case 35674:return b2;case 35675:return T2;case 35676:return A2;case 5124:case 35670:return C2;case 35667:case 35671:return R2;case 35668:case 35672:return L2;case 35669:case 35673:return P2;case 5125:return D2;case 36294:return I2;case 36295:return N2;case 36296:return F2;case 35678:case 36198:case 36298:case 36306:case 35682:return U2;case 35679:case 36299:case 36307:return O2;case 35680:case 36300:case 36308:case 36293:return B2;case 36289:case 36303:case 36311:case 36292:return z2}}function H2(n,e){n.uniform1fv(this.addr,e)}function G2(n,e){const t=Ml(e,this.size,2);n.uniform2fv(this.addr,t)}function V2(n,e){const t=Ml(e,this.size,3);n.uniform3fv(this.addr,t)}function W2(n,e){const t=Ml(e,this.size,4);n.uniform4fv(this.addr,t)}function $2(n,e){const t=Ml(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function X2(n,e){const t=Ml(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function j2(n,e){const t=Ml(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function q2(n,e){n.uniform1iv(this.addr,e)}function Y2(n,e){n.uniform2iv(this.addr,e)}function K2(n,e){n.uniform3iv(this.addr,e)}function Z2(n,e){n.uniform4iv(this.addr,e)}function J2(n,e){n.uniform1uiv(this.addr,e)}function Q2(n,e){n.uniform2uiv(this.addr,e)}function eL(n,e){n.uniform3uiv(this.addr,e)}function tL(n,e){n.uniform4uiv(this.addr,e)}function nL(n,e,t){const i=e.length,r=Kd(t,i);n.uniform1iv(this.addr,r);for(let s=0;s!==i;++s)t.setTexture2D(e[s]||BS,r[s])}function iL(n,e,t){const i=e.length,r=Kd(t,i);n.uniform1iv(this.addr,r);for(let s=0;s!==i;++s)t.setTexture3D(e[s]||kS,r[s])}function rL(n,e,t){const i=e.length,r=Kd(t,i);n.uniform1iv(this.addr,r);for(let s=0;s!==i;++s)t.setTextureCube(e[s]||HS,r[s])}function sL(n,e,t){const i=e.length,r=Kd(t,i);n.uniform1iv(this.addr,r);for(let s=0;s!==i;++s)t.setTexture2DArray(e[s]||zS,r[s])}function oL(n){switch(n){case 5126:return H2;case 35664:return G2;case 35665:return V2;case 35666:return W2;case 35674:return $2;case 35675:return X2;case 35676:return j2;case 5124:case 35670:return q2;case 35667:case 35671:return Y2;case 35668:case 35672:return K2;case 35669:case 35673:return Z2;case 5125:return J2;case 36294:return Q2;case 36295:return eL;case 36296:return tL;case 35678:case 36198:case 36298:case 36306:case 35682:return nL;case 35679:case 36299:case 36307:return iL;case 35680:case 36300:case 36308:case 36293:return rL;case 36289:case 36303:case 36311:case 36292:return sL}}function aL(n,e,t){this.id=n,this.addr=t,this.cache=[],this.setValue=k2(e.type)}function lL(n,e,t){this.id=n,this.addr=t,this.cache=[],this.size=e.size,this.setValue=oL(e.type)}function GS(n){this.id=n,this.seq=[],this.map={}}GS.prototype.setValue=function(n,e,t){const i=this.seq;for(let r=0,s=i.length;r!==s;++r){const o=i[r];o.setValue(n,e[o.id],t)}};const up=/(\w+)(\])?(\[|\.)?/g;function W_(n,e){n.seq.push(e),n.map[e.id]=e}function cL(n,e,t){const i=n.name,r=i.length;for(up.lastIndex=0;;){const s=up.exec(i),o=up.lastIndex;let a=s[1];const l=s[2]==="]",c=s[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===r){W_(t,c===void 0?new aL(a,n,e):new lL(a,n,e));break}else{let h=t.map[a];h===void 0&&(h=new GS(a),W_(t,h)),t=h}}}function ds(n,e){this.seq=[],this.map={};const t=n.getProgramParameter(e,35718);for(let i=0;i<t;++i){const r=n.getActiveUniform(e,i),s=n.getUniformLocation(e,r.name);cL(r,s,this)}}ds.prototype.setValue=function(n,e,t,i){const r=this.map[e];r!==void 0&&r.setValue(n,t,i)};ds.prototype.setOptional=function(n,e,t){const i=e[t];i!==void 0&&this.setValue(n,t,i)};ds.upload=function(n,e,t,i){for(let r=0,s=e.length;r!==s;++r){const o=e[r],a=t[o.id];a.needsUpdate!==!1&&o.setValue(n,a.value,i)}};ds.seqWithValue=function(n,e){const t=[];for(let i=0,r=n.length;i!==r;++i){const s=n[i];s.id in e&&t.push(s)}return t};function $_(n,e,t){const i=n.createShader(e);return n.shaderSource(i,t),n.compileShader(i),i}let uL=0;function hL(n,e){const t=n.split(`
`),i=[],r=Math.max(e-6,0),s=Math.min(e+6,t.length);for(let o=r;o<s;o++)i.push(o+1+": "+t[o]);return i.join(`
`)}function dL(n){switch(n){case bs:return["Linear","( value )"];case it:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",n),["Linear","( value )"]}}function X_(n,e,t){const i=n.getShaderParameter(e,35713),r=n.getShaderInfoLog(e).trim();if(i&&r==="")return"";const s=/ERROR: 0:(\d+)/.exec(r);if(s){const o=parseInt(s[0]);return t.toUpperCase()+`

`+r+`

`+hL(n.getShaderSource(e),o)}else return r}function fL(n,e){const t=dL(e);return"vec4 "+n+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function pL(n,e){let t;switch(e){case MT:t="Linear";break;case ST:t="Reinhard";break;case wT:t="OptimizedCineon";break;case ET:t="ACESFilmic";break;case bT:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function mL(n){return[n.extensionDerivatives||!!n.envMapCubeUVHeight||n.bumpMap||n.tangentSpaceNormalMap||n.clearcoatNormalMap||n.flatShading||n.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap||n.transmission)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(uc).join(`
`)}function gL(n){const e=[];for(const t in n){const i=n[t];i!==!1&&e.push("#define "+t+" "+i)}return e.join(`
`)}function vL(n,e){const t={},i=n.getProgramParameter(e,35721);for(let r=0;r<i;r++){const s=n.getActiveAttrib(e,r),o=s.name;let a=1;s.type===35674&&(a=2),s.type===35675&&(a=3),s.type===35676&&(a=4),t[o]={type:s.type,location:n.getAttribLocation(e,o),locationSize:a}}return t}function uc(n){return n!==""}function j_(n,e){return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function q_(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const _L=/^[ \t]*#include +<([\w\d./]+)>/gm;function $m(n){return n.replace(_L,xL)}function xL(n,e){const t=Ye[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return $m(t)}const yL=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,ML=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Y_(n){return n.replace(ML,VS).replace(yL,SL)}function SL(n,e,t,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),VS(n,e,t,i)}function VS(n,e,t,i){let r="";for(let s=parseInt(e);s<parseInt(t);s++)r+=i.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return r}function K_(n){let e="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function wL(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===MS?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===Qb?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===cc&&(e="SHADOWMAP_TYPE_VSM"),e}function EL(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case ja:case qa:e="ENVMAP_TYPE_CUBE";break;case $d:e="ENVMAP_TYPE_CUBE_UV";break}return e}function bL(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case qa:e="ENVMAP_MODE_REFRACTION";break}return e}function TL(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case Wd:e="ENVMAP_BLENDING_MULTIPLY";break;case xT:e="ENVMAP_BLENDING_MIX";break;case yT:e="ENVMAP_BLENDING_ADD";break}return e}function AL(n){const e=n.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,i=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:i,maxMip:t}}function CL(n,e,t,i){const r=n.getContext(),s=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=wL(t),c=EL(t),u=bL(t),h=TL(t),d=AL(t),p=t.isWebGL2?"":mL(t),v=gL(s),m=r.createProgram();let f,g,_=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(f=[v].filter(uc).join(`
`),f.length>0&&(f+=`
`),g=[p,v].filter(uc).join(`
`),g.length>0&&(g+=`
`)):(f=[K_(t),"#define SHADER_NAME "+t.shaderName,v,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(uc).join(`
`),g=[p,K_(t),"#define SHADER_NAME "+t.shaderName,v,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+u:"",t.envMap?"#define "+h:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Ar?"#define TONE_MAPPING":"",t.toneMapping!==Ar?Ye.tonemapping_pars_fragment:"",t.toneMapping!==Ar?pL("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",Ye.encodings_pars_fragment,fL("linearToOutputTexel",t.outputEncoding),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(uc).join(`
`)),o=$m(o),o=j_(o,t),o=q_(o,t),a=$m(a),a=j_(a,t),a=q_(a,t),o=Y_(o),a=Y_(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(_=`#version 300 es
`,f=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+f,g=["#define varying in",t.glslVersion===x_?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===x_?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+g);const M=_+f+o,E=_+g+a,S=$_(r,35633,M),T=$_(r,35632,E);if(r.attachShader(m,S),r.attachShader(m,T),t.index0AttributeName!==void 0?r.bindAttribLocation(m,0,t.index0AttributeName):t.morphTargets===!0&&r.bindAttribLocation(m,0,"position"),r.linkProgram(m),n.debug.checkShaderErrors){const A=r.getProgramInfoLog(m).trim(),I=r.getShaderInfoLog(S).trim(),N=r.getShaderInfoLog(T).trim();let J=!0,q=!0;if(r.getProgramParameter(m,35714)===!1){J=!1;const L=X_(r,S,"vertex"),$=X_(r,T,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(m,35715)+`

Program Info Log: `+A+`
`+L+`
`+$)}else A!==""?console.warn("THREE.WebGLProgram: Program Info Log:",A):(I===""||N==="")&&(q=!1);q&&(this.diagnostics={runnable:J,programLog:A,vertexShader:{log:I,prefix:f},fragmentShader:{log:N,prefix:g}})}r.deleteShader(S),r.deleteShader(T);let R;this.getUniforms=function(){return R===void 0&&(R=new ds(r,m)),R};let x;return this.getAttributes=function(){return x===void 0&&(x=vL(r,m)),x},this.destroy=function(){i.releaseStatesOfProgram(this),r.deleteProgram(m),this.program=void 0},this.name=t.shaderName,this.id=uL++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=S,this.fragmentShader=T,this}let RL=0;class LL{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,i=e.fragmentShader,r=this._getShaderStage(t),s=this._getShaderStage(i),o=this._getShaderCacheForMaterial(e);return o.has(r)===!1&&(o.add(r),r.usedTimes++),o.has(s)===!1&&(o.add(s),s.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const i of t)i.usedTimes--,i.usedTimes===0&&this.shaderCache.delete(i.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;return t.has(e)===!1&&t.set(e,new Set),t.get(e)}_getShaderStage(e){const t=this.shaderCache;if(t.has(e)===!1){const i=new PL(e);t.set(e,i)}return t.get(e)}}class PL{constructor(e){this.id=RL++,this.code=e,this.usedTimes=0}}function DL(n,e,t,i,r,s,o){const a=new IS,l=new LL,c=[],u=r.isWebGL2,h=r.logarithmicDepthBuffer,d=r.vertexTextures;let p=r.precision;const v={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function m(x,A,I,N,J){const q=N.fog,L=J.geometry,$=x.isMeshStandardMaterial?N.environment:null,z=(x.isMeshStandardMaterial?t:e).get(x.envMap||$),W=!!z&&z.mapping===$d?z.image.height:null,U=v[x.type];x.precision!==null&&(p=r.getMaxPrecision(x.precision),p!==x.precision&&console.warn("THREE.WebGLProgram.getParameters:",x.precision,"not supported, using",p,"instead."));const P=L.morphAttributes.position||L.morphAttributes.normal||L.morphAttributes.color,k=P!==void 0?P.length:0;let Y=0;L.morphAttributes.position!==void 0&&(Y=1),L.morphAttributes.normal!==void 0&&(Y=2),L.morphAttributes.color!==void 0&&(Y=3);let j,K,ce,de;if(U){const re=Yi[U];j=re.vertexShader,K=re.fragmentShader}else j=x.vertexShader,K=x.fragmentShader,l.update(x),ce=l.getVertexShaderID(x),de=l.getFragmentShaderID(x);const F=n.getRenderTarget(),We=x.alphaTest>0,Me=x.clearcoat>0;return{isWebGL2:u,shaderID:U,shaderName:x.type,vertexShader:j,fragmentShader:K,defines:x.defines,customVertexShaderID:ce,customFragmentShaderID:de,isRawShaderMaterial:x.isRawShaderMaterial===!0,glslVersion:x.glslVersion,precision:p,instancing:J.isInstancedMesh===!0,instancingColor:J.isInstancedMesh===!0&&J.instanceColor!==null,supportsVertexTextures:d,outputEncoding:F===null?n.outputEncoding:F.isXRRenderTarget===!0?F.texture.encoding:bs,map:!!x.map,matcap:!!x.matcap,envMap:!!z,envMapMode:z&&z.mapping,envMapCubeUVHeight:W,lightMap:!!x.lightMap,aoMap:!!x.aoMap,emissiveMap:!!x.emissiveMap,bumpMap:!!x.bumpMap,normalMap:!!x.normalMap,objectSpaceNormalMap:x.normalMapType===qT,tangentSpaceNormalMap:x.normalMapType===bo,decodeVideoTexture:!!x.map&&x.map.isVideoTexture===!0&&x.map.encoding===it,clearcoat:Me,clearcoatMap:Me&&!!x.clearcoatMap,clearcoatRoughnessMap:Me&&!!x.clearcoatRoughnessMap,clearcoatNormalMap:Me&&!!x.clearcoatNormalMap,displacementMap:!!x.displacementMap,roughnessMap:!!x.roughnessMap,metalnessMap:!!x.metalnessMap,specularMap:!!x.specularMap,specularIntensityMap:!!x.specularIntensityMap,specularColorMap:!!x.specularColorMap,opaque:x.transparent===!1&&x.blending===Fa,alphaMap:!!x.alphaMap,alphaTest:We,gradientMap:!!x.gradientMap,sheen:x.sheen>0,sheenColorMap:!!x.sheenColorMap,sheenRoughnessMap:!!x.sheenRoughnessMap,transmission:x.transmission>0,transmissionMap:!!x.transmissionMap,thicknessMap:!!x.thicknessMap,combine:x.combine,vertexTangents:!!x.normalMap&&!!L.attributes.tangent,vertexColors:x.vertexColors,vertexAlphas:x.vertexColors===!0&&!!L.attributes.color&&L.attributes.color.itemSize===4,vertexUvs:!!x.map||!!x.bumpMap||!!x.normalMap||!!x.specularMap||!!x.alphaMap||!!x.emissiveMap||!!x.roughnessMap||!!x.metalnessMap||!!x.clearcoatMap||!!x.clearcoatRoughnessMap||!!x.clearcoatNormalMap||!!x.displacementMap||!!x.transmissionMap||!!x.thicknessMap||!!x.specularIntensityMap||!!x.specularColorMap||!!x.sheenColorMap||!!x.sheenRoughnessMap,uvsVertexOnly:!(!!x.map||!!x.bumpMap||!!x.normalMap||!!x.specularMap||!!x.alphaMap||!!x.emissiveMap||!!x.roughnessMap||!!x.metalnessMap||!!x.clearcoatNormalMap||x.transmission>0||!!x.transmissionMap||!!x.thicknessMap||!!x.specularIntensityMap||!!x.specularColorMap||x.sheen>0||!!x.sheenColorMap||!!x.sheenRoughnessMap)&&!!x.displacementMap,fog:!!q,useFog:x.fog===!0,fogExp2:q&&q.isFogExp2,flatShading:!!x.flatShading,sizeAttenuation:x.sizeAttenuation,logarithmicDepthBuffer:h,skinning:J.isSkinnedMesh===!0,morphTargets:L.morphAttributes.position!==void 0,morphNormals:L.morphAttributes.normal!==void 0,morphColors:L.morphAttributes.color!==void 0,morphTargetsCount:k,morphTextureStride:Y,numDirLights:A.directional.length,numPointLights:A.point.length,numSpotLights:A.spot.length,numRectAreaLights:A.rectArea.length,numHemiLights:A.hemi.length,numDirLightShadows:A.directionalShadowMap.length,numPointLightShadows:A.pointShadowMap.length,numSpotLightShadows:A.spotShadowMap.length,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:x.dithering,shadowMapEnabled:n.shadowMap.enabled&&I.length>0,shadowMapType:n.shadowMap.type,toneMapping:x.toneMapped?n.toneMapping:Ar,physicallyCorrectLights:n.physicallyCorrectLights,premultipliedAlpha:x.premultipliedAlpha,doubleSided:x.side===po,flipSided:x.side===Bi,useDepthPacking:!!x.depthPacking,depthPacking:x.depthPacking||0,index0AttributeName:x.index0AttributeName,extensionDerivatives:x.extensions&&x.extensions.derivatives,extensionFragDepth:x.extensions&&x.extensions.fragDepth,extensionDrawBuffers:x.extensions&&x.extensions.drawBuffers,extensionShaderTextureLOD:x.extensions&&x.extensions.shaderTextureLOD,rendererExtensionFragDepth:u||i.has("EXT_frag_depth"),rendererExtensionDrawBuffers:u||i.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:u||i.has("EXT_shader_texture_lod"),customProgramCacheKey:x.customProgramCacheKey()}}function f(x){const A=[];if(x.shaderID?A.push(x.shaderID):(A.push(x.customVertexShaderID),A.push(x.customFragmentShaderID)),x.defines!==void 0)for(const I in x.defines)A.push(I),A.push(x.defines[I]);return x.isRawShaderMaterial===!1&&(g(A,x),_(A,x),A.push(n.outputEncoding)),A.push(x.customProgramCacheKey),A.join()}function g(x,A){x.push(A.precision),x.push(A.outputEncoding),x.push(A.envMapMode),x.push(A.envMapCubeUVHeight),x.push(A.combine),x.push(A.vertexUvs),x.push(A.fogExp2),x.push(A.sizeAttenuation),x.push(A.morphTargetsCount),x.push(A.morphAttributeCount),x.push(A.numDirLights),x.push(A.numPointLights),x.push(A.numSpotLights),x.push(A.numHemiLights),x.push(A.numRectAreaLights),x.push(A.numDirLightShadows),x.push(A.numPointLightShadows),x.push(A.numSpotLightShadows),x.push(A.shadowMapType),x.push(A.toneMapping),x.push(A.numClippingPlanes),x.push(A.numClipIntersection),x.push(A.depthPacking)}function _(x,A){a.disableAll(),A.isWebGL2&&a.enable(0),A.supportsVertexTextures&&a.enable(1),A.instancing&&a.enable(2),A.instancingColor&&a.enable(3),A.map&&a.enable(4),A.matcap&&a.enable(5),A.envMap&&a.enable(6),A.lightMap&&a.enable(7),A.aoMap&&a.enable(8),A.emissiveMap&&a.enable(9),A.bumpMap&&a.enable(10),A.normalMap&&a.enable(11),A.objectSpaceNormalMap&&a.enable(12),A.tangentSpaceNormalMap&&a.enable(13),A.clearcoat&&a.enable(14),A.clearcoatMap&&a.enable(15),A.clearcoatRoughnessMap&&a.enable(16),A.clearcoatNormalMap&&a.enable(17),A.displacementMap&&a.enable(18),A.specularMap&&a.enable(19),A.roughnessMap&&a.enable(20),A.metalnessMap&&a.enable(21),A.gradientMap&&a.enable(22),A.alphaMap&&a.enable(23),A.alphaTest&&a.enable(24),A.vertexColors&&a.enable(25),A.vertexAlphas&&a.enable(26),A.vertexUvs&&a.enable(27),A.vertexTangents&&a.enable(28),A.uvsVertexOnly&&a.enable(29),A.fog&&a.enable(30),x.push(a.mask),a.disableAll(),A.useFog&&a.enable(0),A.flatShading&&a.enable(1),A.logarithmicDepthBuffer&&a.enable(2),A.skinning&&a.enable(3),A.morphTargets&&a.enable(4),A.morphNormals&&a.enable(5),A.morphColors&&a.enable(6),A.premultipliedAlpha&&a.enable(7),A.shadowMapEnabled&&a.enable(8),A.physicallyCorrectLights&&a.enable(9),A.doubleSided&&a.enable(10),A.flipSided&&a.enable(11),A.useDepthPacking&&a.enable(12),A.dithering&&a.enable(13),A.specularIntensityMap&&a.enable(14),A.specularColorMap&&a.enable(15),A.transmission&&a.enable(16),A.transmissionMap&&a.enable(17),A.thicknessMap&&a.enable(18),A.sheen&&a.enable(19),A.sheenColorMap&&a.enable(20),A.sheenRoughnessMap&&a.enable(21),A.decodeVideoTexture&&a.enable(22),A.opaque&&a.enable(23),x.push(a.mask)}function M(x){const A=v[x.type];let I;if(A){const N=Yi[A];I=md.clone(N.uniforms)}else I=x.uniforms;return I}function E(x,A){let I;for(let N=0,J=c.length;N<J;N++){const q=c[N];if(q.cacheKey===A){I=q,++I.usedTimes;break}}return I===void 0&&(I=new CL(n,A,x,s),c.push(I)),I}function S(x){if(--x.usedTimes===0){const A=c.indexOf(x);c[A]=c[c.length-1],c.pop(),x.destroy()}}function T(x){l.remove(x)}function R(){l.dispose()}return{getParameters:m,getProgramCacheKey:f,getUniforms:M,acquireProgram:E,releaseProgram:S,releaseShaderCache:T,programs:c,dispose:R}}function IL(){let n=new WeakMap;function e(s){let o=n.get(s);return o===void 0&&(o={},n.set(s,o)),o}function t(s){n.delete(s)}function i(s,o,a){n.get(s)[o]=a}function r(){n=new WeakMap}return{get:e,remove:t,update:i,dispose:r}}function NL(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function Z_(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function J_(){const n=[];let e=0;const t=[],i=[],r=[];function s(){e=0,t.length=0,i.length=0,r.length=0}function o(h,d,p,v,m,f){let g=n[e];return g===void 0?(g={id:h.id,object:h,geometry:d,material:p,groupOrder:v,renderOrder:h.renderOrder,z:m,group:f},n[e]=g):(g.id=h.id,g.object=h,g.geometry=d,g.material=p,g.groupOrder=v,g.renderOrder=h.renderOrder,g.z=m,g.group=f),e++,g}function a(h,d,p,v,m,f){const g=o(h,d,p,v,m,f);p.transmission>0?i.push(g):p.transparent===!0?r.push(g):t.push(g)}function l(h,d,p,v,m,f){const g=o(h,d,p,v,m,f);p.transmission>0?i.unshift(g):p.transparent===!0?r.unshift(g):t.unshift(g)}function c(h,d){t.length>1&&t.sort(h||NL),i.length>1&&i.sort(d||Z_),r.length>1&&r.sort(d||Z_)}function u(){for(let h=e,d=n.length;h<d;h++){const p=n[h];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.group=null}}return{opaque:t,transmissive:i,transparent:r,init:s,push:a,unshift:l,finish:u,sort:c}}function FL(){let n=new WeakMap;function e(i,r){let s;return n.has(i)===!1?(s=new J_,n.set(i,[s])):r>=n.get(i).length?(s=new J_,n.get(i).push(s)):s=n.get(i)[r],s}function t(){n=new WeakMap}return{get:e,dispose:t}}function UL(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new B,color:new we};break;case"SpotLight":t={position:new B,direction:new B,color:new we,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new B,color:new we,distance:0,decay:0};break;case"HemisphereLight":t={direction:new B,skyColor:new we,groundColor:new we};break;case"RectAreaLight":t={color:new we,position:new B,halfWidth:new B,halfHeight:new B};break}return n[e.id]=t,t}}}function OL(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new fe};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new fe};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new fe,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let BL=0;function zL(n,e){return(e.castShadow?1:0)-(n.castShadow?1:0)}function kL(n,e){const t=new UL,i=OL(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let u=0;u<9;u++)r.probe.push(new B);const s=new B,o=new Ve,a=new Ve;function l(u,h){let d=0,p=0,v=0;for(let A=0;A<9;A++)r.probe[A].set(0,0,0);let m=0,f=0,g=0,_=0,M=0,E=0,S=0,T=0;u.sort(zL);const R=h!==!0?Math.PI:1;for(let A=0,I=u.length;A<I;A++){const N=u[A],J=N.color,q=N.intensity,L=N.distance,$=N.shadow&&N.shadow.map?N.shadow.map.texture:null;if(N.isAmbientLight)d+=J.r*q*R,p+=J.g*q*R,v+=J.b*q*R;else if(N.isLightProbe)for(let z=0;z<9;z++)r.probe[z].addScaledVector(N.sh.coefficients[z],q);else if(N.isDirectionalLight){const z=t.get(N);if(z.color.copy(N.color).multiplyScalar(N.intensity*R),N.castShadow){const W=N.shadow,U=i.get(N);U.shadowBias=W.bias,U.shadowNormalBias=W.normalBias,U.shadowRadius=W.radius,U.shadowMapSize=W.mapSize,r.directionalShadow[m]=U,r.directionalShadowMap[m]=$,r.directionalShadowMatrix[m]=N.shadow.matrix,E++}r.directional[m]=z,m++}else if(N.isSpotLight){const z=t.get(N);if(z.position.setFromMatrixPosition(N.matrixWorld),z.color.copy(J).multiplyScalar(q*R),z.distance=L,z.coneCos=Math.cos(N.angle),z.penumbraCos=Math.cos(N.angle*(1-N.penumbra)),z.decay=N.decay,N.castShadow){const W=N.shadow,U=i.get(N);U.shadowBias=W.bias,U.shadowNormalBias=W.normalBias,U.shadowRadius=W.radius,U.shadowMapSize=W.mapSize,r.spotShadow[g]=U,r.spotShadowMap[g]=$,r.spotShadowMatrix[g]=N.shadow.matrix,T++}r.spot[g]=z,g++}else if(N.isRectAreaLight){const z=t.get(N);z.color.copy(J).multiplyScalar(q),z.halfWidth.set(N.width*.5,0,0),z.halfHeight.set(0,N.height*.5,0),r.rectArea[_]=z,_++}else if(N.isPointLight){const z=t.get(N);if(z.color.copy(N.color).multiplyScalar(N.intensity*R),z.distance=N.distance,z.decay=N.decay,N.castShadow){const W=N.shadow,U=i.get(N);U.shadowBias=W.bias,U.shadowNormalBias=W.normalBias,U.shadowRadius=W.radius,U.shadowMapSize=W.mapSize,U.shadowCameraNear=W.camera.near,U.shadowCameraFar=W.camera.far,r.pointShadow[f]=U,r.pointShadowMap[f]=$,r.pointShadowMatrix[f]=N.shadow.matrix,S++}r.point[f]=z,f++}else if(N.isHemisphereLight){const z=t.get(N);z.skyColor.copy(N.color).multiplyScalar(q*R),z.groundColor.copy(N.groundColor).multiplyScalar(q*R),r.hemi[M]=z,M++}}_>0&&(e.isWebGL2||n.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=Le.LTC_FLOAT_1,r.rectAreaLTC2=Le.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(r.rectAreaLTC1=Le.LTC_HALF_1,r.rectAreaLTC2=Le.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=d,r.ambient[1]=p,r.ambient[2]=v;const x=r.hash;(x.directionalLength!==m||x.pointLength!==f||x.spotLength!==g||x.rectAreaLength!==_||x.hemiLength!==M||x.numDirectionalShadows!==E||x.numPointShadows!==S||x.numSpotShadows!==T)&&(r.directional.length=m,r.spot.length=g,r.rectArea.length=_,r.point.length=f,r.hemi.length=M,r.directionalShadow.length=E,r.directionalShadowMap.length=E,r.pointShadow.length=S,r.pointShadowMap.length=S,r.spotShadow.length=T,r.spotShadowMap.length=T,r.directionalShadowMatrix.length=E,r.pointShadowMatrix.length=S,r.spotShadowMatrix.length=T,x.directionalLength=m,x.pointLength=f,x.spotLength=g,x.rectAreaLength=_,x.hemiLength=M,x.numDirectionalShadows=E,x.numPointShadows=S,x.numSpotShadows=T,r.version=BL++)}function c(u,h){let d=0,p=0,v=0,m=0,f=0;const g=h.matrixWorldInverse;for(let _=0,M=u.length;_<M;_++){const E=u[_];if(E.isDirectionalLight){const S=r.directional[d];S.direction.setFromMatrixPosition(E.matrixWorld),s.setFromMatrixPosition(E.target.matrixWorld),S.direction.sub(s),S.direction.transformDirection(g),d++}else if(E.isSpotLight){const S=r.spot[v];S.position.setFromMatrixPosition(E.matrixWorld),S.position.applyMatrix4(g),S.direction.setFromMatrixPosition(E.matrixWorld),s.setFromMatrixPosition(E.target.matrixWorld),S.direction.sub(s),S.direction.transformDirection(g),v++}else if(E.isRectAreaLight){const S=r.rectArea[m];S.position.setFromMatrixPosition(E.matrixWorld),S.position.applyMatrix4(g),a.identity(),o.copy(E.matrixWorld),o.premultiply(g),a.extractRotation(o),S.halfWidth.set(E.width*.5,0,0),S.halfHeight.set(0,E.height*.5,0),S.halfWidth.applyMatrix4(a),S.halfHeight.applyMatrix4(a),m++}else if(E.isPointLight){const S=r.point[p];S.position.setFromMatrixPosition(E.matrixWorld),S.position.applyMatrix4(g),p++}else if(E.isHemisphereLight){const S=r.hemi[f];S.direction.setFromMatrixPosition(E.matrixWorld),S.direction.transformDirection(g),f++}}}return{setup:l,setupView:c,state:r}}function Q_(n,e){const t=new kL(n,e),i=[],r=[];function s(){i.length=0,r.length=0}function o(h){i.push(h)}function a(h){r.push(h)}function l(h){t.setup(i,h)}function c(h){t.setupView(i,h)}return{init:s,state:{lightsArray:i,shadowsArray:r,lights:t},setupLights:l,setupLightsView:c,pushLight:o,pushShadow:a}}function HL(n,e){let t=new WeakMap;function i(s,o=0){let a;return t.has(s)===!1?(a=new Q_(n,e),t.set(s,[a])):o>=t.get(s).length?(a=new Q_(n,e),t.get(s).push(a)):a=t.get(s)[o],a}function r(){t=new WeakMap}return{get:i,dispose:r}}class d0 extends Rt{constructor(e){super(),this.type="MeshDepthMaterial",this.depthPacking=XT,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}d0.prototype.isMeshDepthMaterial=!0;class f0 extends Rt{constructor(e){super(),this.type="MeshDistanceMaterial",this.referencePosition=new B,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}f0.prototype.isMeshDistanceMaterial=!0;const GL=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,VL=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function WS(n,e,t){let i=new qd;const r=new fe,s=new fe,o=new ut,a=new d0({depthPacking:jT}),l=new f0,c={},u=t.maxTextureSize,h={0:Bi,1:Xa,2:po},d=new Zt({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new fe},radius:{value:4}},vertexShader:GL,fragmentShader:VL}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const v=new lt;v.setAttribute("position",new Ut(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const m=new dt(v,d),f=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=MS,this.render=function(E,S,T){if(f.enabled===!1||f.autoUpdate===!1&&f.needsUpdate===!1||E.length===0)return;const R=n.getRenderTarget(),x=n.getActiveCubeFace(),A=n.getActiveMipmapLevel(),I=n.state;I.setBlending(hs),I.buffers.color.setClear(1,1,1,1),I.buffers.depth.setTest(!0),I.setScissorTest(!1);for(let N=0,J=E.length;N<J;N++){const q=E[N],L=q.shadow;if(L===void 0){console.warn("THREE.WebGLShadowMap:",q,"has no shadow.");continue}if(L.autoUpdate===!1&&L.needsUpdate===!1)continue;r.copy(L.mapSize);const $=L.getFrameExtents();if(r.multiply($),s.copy(L.mapSize),(r.x>u||r.y>u)&&(r.x>u&&(s.x=Math.floor(u/$.x),r.x=s.x*$.x,L.mapSize.x=s.x),r.y>u&&(s.y=Math.floor(u/$.y),r.y=s.y*$.y,L.mapSize.y=s.y)),L.map===null&&!L.isPointLightShadow&&this.type===cc&&(L.map=new on(r.x,r.y),L.map.texture.name=q.name+".shadowMap",L.mapPass=new on(r.x,r.y),L.camera.updateProjectionMatrix()),L.map===null){const W={minFilter:$t,magFilter:$t,format:ui};L.map=new on(r.x,r.y,W),L.map.texture.name=q.name+".shadowMap",L.camera.updateProjectionMatrix()}n.setRenderTarget(L.map),n.clear();const z=L.getViewportCount();for(let W=0;W<z;W++){const U=L.getViewport(W);o.set(s.x*U.x,s.y*U.y,s.x*U.z,s.y*U.w),I.viewport(o),L.updateMatrices(q,W),i=L.getFrustum(),M(S,T,L.camera,q,this.type)}!L.isPointLightShadow&&this.type===cc&&g(L,T),L.needsUpdate=!1}f.needsUpdate=!1,n.setRenderTarget(R,x,A)};function g(E,S){const T=e.update(m);d.defines.VSM_SAMPLES!==E.blurSamples&&(d.defines.VSM_SAMPLES=E.blurSamples,p.defines.VSM_SAMPLES=E.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),d.uniforms.shadow_pass.value=E.map.texture,d.uniforms.resolution.value=E.mapSize,d.uniforms.radius.value=E.radius,n.setRenderTarget(E.mapPass),n.clear(),n.renderBufferDirect(S,null,T,d,m,null),p.uniforms.shadow_pass.value=E.mapPass.texture,p.uniforms.resolution.value=E.mapSize,p.uniforms.radius.value=E.radius,n.setRenderTarget(E.map),n.clear(),n.renderBufferDirect(S,null,T,p,m,null)}function _(E,S,T,R,x,A){let I=null;const N=T.isPointLight===!0?E.customDistanceMaterial:E.customDepthMaterial;if(N!==void 0?I=N:I=T.isPointLight===!0?l:a,n.localClippingEnabled&&S.clipShadows===!0&&S.clippingPlanes.length!==0||S.displacementMap&&S.displacementScale!==0||S.alphaMap&&S.alphaTest>0){const J=I.uuid,q=S.uuid;let L=c[J];L===void 0&&(L={},c[J]=L);let $=L[q];$===void 0&&($=I.clone(),L[q]=$),I=$}return I.visible=S.visible,I.wireframe=S.wireframe,A===cc?I.side=S.shadowSide!==null?S.shadowSide:S.side:I.side=S.shadowSide!==null?S.shadowSide:h[S.side],I.alphaMap=S.alphaMap,I.alphaTest=S.alphaTest,I.clipShadows=S.clipShadows,I.clippingPlanes=S.clippingPlanes,I.clipIntersection=S.clipIntersection,I.displacementMap=S.displacementMap,I.displacementScale=S.displacementScale,I.displacementBias=S.displacementBias,I.wireframeLinewidth=S.wireframeLinewidth,I.linewidth=S.linewidth,T.isPointLight===!0&&I.isMeshDistanceMaterial===!0&&(I.referencePosition.setFromMatrixPosition(T.matrixWorld),I.nearDistance=R,I.farDistance=x),I}function M(E,S,T,R,x){if(E.visible===!1)return;if(E.layers.test(S.layers)&&(E.isMesh||E.isLine||E.isPoints)&&(E.castShadow||E.receiveShadow&&x===cc)&&(!E.frustumCulled||i.intersectsObject(E))){E.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse,E.matrixWorld);const N=e.update(E),J=E.material;if(Array.isArray(J)){const q=N.groups;for(let L=0,$=q.length;L<$;L++){const z=q[L],W=J[z.materialIndex];if(W&&W.visible){const U=_(E,W,R,T.near,T.far,x);n.renderBufferDirect(T,null,N,U,E,z)}}}else if(J.visible){const q=_(E,J,R,T.near,T.far,x);n.renderBufferDirect(T,null,N,q,E,null)}}const I=E.children;for(let N=0,J=I.length;N<J;N++)M(I[N],S,T,R,x)}}function WL(n,e,t){const i=t.isWebGL2;function r(){let C=!1;const ie=new ut;let te=null;const _e=new ut(0,0,0,0);return{setMask:function(ue){te!==ue&&!C&&(n.colorMask(ue,ue,ue,ue),te=ue)},setLocked:function(ue){C=ue},setClear:function(ue,ge,ee,xe,He){He===!0&&(ue*=xe,ge*=xe,ee*=xe),ie.set(ue,ge,ee,xe),_e.equals(ie)===!1&&(n.clearColor(ue,ge,ee,xe),_e.copy(ie))},reset:function(){C=!1,te=null,_e.set(-1,0,0,0)}}}function s(){let C=!1,ie=null,te=null,_e=null;return{setTest:function(ue){ue?de(2929):F(2929)},setMask:function(ue){ie!==ue&&!C&&(n.depthMask(ue),ie=ue)},setFunc:function(ue){if(te!==ue){if(ue)switch(ue){case dT:n.depthFunc(512);break;case fT:n.depthFunc(519);break;case pT:n.depthFunc(513);break;case Bm:n.depthFunc(515);break;case mT:n.depthFunc(514);break;case gT:n.depthFunc(518);break;case vT:n.depthFunc(516);break;case _T:n.depthFunc(517);break;default:n.depthFunc(515)}else n.depthFunc(515);te=ue}},setLocked:function(ue){C=ue},setClear:function(ue){_e!==ue&&(n.clearDepth(ue),_e=ue)},reset:function(){C=!1,ie=null,te=null,_e=null}}}function o(){let C=!1,ie=null,te=null,_e=null,ue=null,ge=null,ee=null,xe=null,He=null;return{setTest:function(Ne){C||(Ne?de(2960):F(2960))},setMask:function(Ne){ie!==Ne&&!C&&(n.stencilMask(Ne),ie=Ne)},setFunc:function(Ne,Lt,Pt){(te!==Ne||_e!==Lt||ue!==Pt)&&(n.stencilFunc(Ne,Lt,Pt),te=Ne,_e=Lt,ue=Pt)},setOp:function(Ne,Lt,Pt){(ge!==Ne||ee!==Lt||xe!==Pt)&&(n.stencilOp(Ne,Lt,Pt),ge=Ne,ee=Lt,xe=Pt)},setLocked:function(Ne){C=Ne},setClear:function(Ne){He!==Ne&&(n.clearStencil(Ne),He=Ne)},reset:function(){C=!1,ie=null,te=null,_e=null,ue=null,ge=null,ee=null,xe=null,He=null}}}const a=new r,l=new s,c=new o;let u={},h={},d=new WeakMap,p=[],v=null,m=!1,f=null,g=null,_=null,M=null,E=null,S=null,T=null,R=!1,x=null,A=null,I=null,N=null,J=null;const q=n.getParameter(35661);let L=!1,$=0;const z=n.getParameter(7938);z.indexOf("WebGL")!==-1?($=parseFloat(/^WebGL (\d)/.exec(z)[1]),L=$>=1):z.indexOf("OpenGL ES")!==-1&&($=parseFloat(/^OpenGL ES (\d)/.exec(z)[1]),L=$>=2);let W=null,U={};const P=n.getParameter(3088),k=n.getParameter(2978),Y=new ut().fromArray(P),j=new ut().fromArray(k);function K(C,ie,te){const _e=new Uint8Array(4),ue=n.createTexture();n.bindTexture(C,ue),n.texParameteri(C,10241,9728),n.texParameteri(C,10240,9728);for(let ge=0;ge<te;ge++)n.texImage2D(ie+ge,0,6408,1,1,0,6408,5121,_e);return ue}const ce={};ce[3553]=K(3553,3553,1),ce[34067]=K(34067,34069,6),a.setClear(0,0,0,1),l.setClear(1),c.setClear(0),de(2929),l.setFunc(Bm),pe(!1),De(jv),de(2884),oe(hs);function de(C){u[C]!==!0&&(n.enable(C),u[C]=!0)}function F(C){u[C]!==!1&&(n.disable(C),u[C]=!1)}function We(C,ie){return h[C]!==ie?(n.bindFramebuffer(C,ie),h[C]=ie,i&&(C===36009&&(h[36160]=ie),C===36160&&(h[36009]=ie)),!0):!1}function Me(C,ie){let te=p,_e=!1;if(C)if(te=d.get(ie),te===void 0&&(te=[],d.set(ie,te)),C.isWebGLMultipleRenderTargets){const ue=C.texture;if(te.length!==ue.length||te[0]!==36064){for(let ge=0,ee=ue.length;ge<ee;ge++)te[ge]=36064+ge;te.length=ue.length,_e=!0}}else te[0]!==36064&&(te[0]=36064,_e=!0);else te[0]!==1029&&(te[0]=1029,_e=!0);_e&&(t.isWebGL2?n.drawBuffers(te):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(te))}function Ce(C){return v!==C?(n.useProgram(C),v=C,!0):!1}const re={[ma]:32774,[tT]:32778,[nT]:32779};if(i)re[Kv]=32775,re[Zv]=32776;else{const C=e.get("EXT_blend_minmax");C!==null&&(re[Kv]=C.MIN_EXT,re[Zv]=C.MAX_EXT)}const ze={[iT]:0,[rT]:1,[sT]:768,[wS]:770,[hT]:776,[cT]:774,[aT]:772,[oT]:769,[ES]:771,[uT]:775,[lT]:773};function oe(C,ie,te,_e,ue,ge,ee,xe){if(C===hs){m===!0&&(F(3042),m=!1);return}if(m===!1&&(de(3042),m=!0),C!==eT){if(C!==f||xe!==R){if((g!==ma||E!==ma)&&(n.blendEquation(32774),g=ma,E=ma),xe)switch(C){case Fa:n.blendFuncSeparate(1,771,1,771);break;case Om:n.blendFunc(1,1);break;case qv:n.blendFuncSeparate(0,769,0,1);break;case Yv:n.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",C);break}else switch(C){case Fa:n.blendFuncSeparate(770,771,1,771);break;case Om:n.blendFunc(770,1);break;case qv:n.blendFuncSeparate(0,769,0,1);break;case Yv:n.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",C);break}_=null,M=null,S=null,T=null,f=C,R=xe}return}ue=ue||ie,ge=ge||te,ee=ee||_e,(ie!==g||ue!==E)&&(n.blendEquationSeparate(re[ie],re[ue]),g=ie,E=ue),(te!==_||_e!==M||ge!==S||ee!==T)&&(n.blendFuncSeparate(ze[te],ze[_e],ze[ge],ze[ee]),_=te,M=_e,S=ge,T=ee),f=C,R=null}function ne(C,ie){C.side===po?F(2884):de(2884);let te=C.side===Bi;ie&&(te=!te),pe(te),C.blending===Fa&&C.transparent===!1?oe(hs):oe(C.blending,C.blendEquation,C.blendSrc,C.blendDst,C.blendEquationAlpha,C.blendSrcAlpha,C.blendDstAlpha,C.premultipliedAlpha),l.setFunc(C.depthFunc),l.setTest(C.depthTest),l.setMask(C.depthWrite),a.setMask(C.colorWrite);const _e=C.stencilWrite;c.setTest(_e),_e&&(c.setMask(C.stencilWriteMask),c.setFunc(C.stencilFunc,C.stencilRef,C.stencilFuncMask),c.setOp(C.stencilFail,C.stencilZFail,C.stencilZPass)),$e(C.polygonOffset,C.polygonOffsetFactor,C.polygonOffsetUnits),C.alphaToCoverage===!0?de(32926):F(32926)}function pe(C){x!==C&&(C?n.frontFace(2304):n.frontFace(2305),x=C)}function De(C){C!==Zb?(de(2884),C!==A&&(C===jv?n.cullFace(1029):C===Jb?n.cullFace(1028):n.cullFace(1032))):F(2884),A=C}function Se(C){C!==I&&(L&&n.lineWidth(C),I=C)}function $e(C,ie,te){C?(de(32823),(N!==ie||J!==te)&&(n.polygonOffset(ie,te),N=ie,J=te)):F(32823)}function Oe(C){C?de(3089):F(3089)}function Te(C){C===void 0&&(C=33984+q-1),W!==C&&(n.activeTexture(C),W=C)}function et(C,ie){W===null&&Te();let te=U[W];te===void 0&&(te={type:void 0,texture:void 0},U[W]=te),(te.type!==C||te.texture!==ie)&&(n.bindTexture(C,ie||ce[C]),te.type=C,te.texture=ie)}function qe(){const C=U[W];C!==void 0&&C.type!==void 0&&(n.bindTexture(C.type,null),C.type=void 0,C.texture=void 0)}function b(){try{n.compressedTexImage2D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function y(){try{n.texSubImage2D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function G(){try{n.texSubImage3D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function Z(){try{n.compressedTexSubImage2D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function ae(){try{n.texStorage2D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function le(){try{n.texStorage3D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function me(){try{n.texImage2D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function V(){try{n.texImage3D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function Ae(C){Y.equals(C)===!1&&(n.scissor(C.x,C.y,C.z,C.w),Y.copy(C))}function Ie(C){j.equals(C)===!1&&(n.viewport(C.x,C.y,C.z,C.w),j.copy(C))}function he(){n.disable(3042),n.disable(2884),n.disable(2929),n.disable(32823),n.disable(3089),n.disable(2960),n.disable(32926),n.blendEquation(32774),n.blendFunc(1,0),n.blendFuncSeparate(1,0,1,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(513),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(519,0,4294967295),n.stencilOp(7680,7680,7680),n.clearStencil(0),n.cullFace(1029),n.frontFace(2305),n.polygonOffset(0,0),n.activeTexture(33984),n.bindFramebuffer(36160,null),i===!0&&(n.bindFramebuffer(36009,null),n.bindFramebuffer(36008,null)),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),u={},W=null,U={},h={},d=new WeakMap,p=[],v=null,m=!1,f=null,g=null,_=null,M=null,E=null,S=null,T=null,R=!1,x=null,A=null,I=null,N=null,J=null,Y.set(0,0,n.canvas.width,n.canvas.height),j.set(0,0,n.canvas.width,n.canvas.height),a.reset(),l.reset(),c.reset()}return{buffers:{color:a,depth:l,stencil:c},enable:de,disable:F,bindFramebuffer:We,drawBuffers:Me,useProgram:Ce,setBlending:oe,setMaterial:ne,setFlipSided:pe,setCullFace:De,setLineWidth:Se,setPolygonOffset:$e,setScissorTest:Oe,activeTexture:Te,bindTexture:et,unbindTexture:qe,compressedTexImage2D:b,texImage2D:me,texImage3D:V,texStorage2D:ae,texStorage3D:le,texSubImage2D:y,texSubImage3D:G,compressedTexSubImage2D:Z,scissor:Ae,viewport:Ie,reset:he}}function $L(n,e,t,i,r,s,o){const a=r.isWebGL2,l=r.maxTextures,c=r.maxCubemapSize,u=r.maxTextureSize,h=r.maxSamples,d=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,p=/OculusBrowser/g.test(navigator.userAgent),v=new WeakMap;let m;const f=new WeakMap;let g=!1;try{g=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function _(b,y){return g?new OffscreenCanvas(b,y):zc("canvas")}function M(b,y,G,Z){let ae=1;if((b.width>Z||b.height>Z)&&(ae=Z/Math.max(b.width,b.height)),ae<1||y===!0)if(typeof HTMLImageElement!="undefined"&&b instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&b instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&b instanceof ImageBitmap){const le=y?pd:Math.floor,me=le(ae*b.width),V=le(ae*b.height);m===void 0&&(m=_(me,V));const Ae=G?_(me,V):m;return Ae.width=me,Ae.height=V,Ae.getContext("2d").drawImage(b,0,0,me,V),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+b.width+"x"+b.height+") to ("+me+"x"+V+")."),Ae}else return"data"in b&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+b.width+"x"+b.height+")."),b;return b}function E(b){return Wm(b.width)&&Wm(b.height)}function S(b){return a?!1:b.wrapS!==ci||b.wrapT!==ci||b.minFilter!==$t&&b.minFilter!==mn}function T(b,y){return b.generateMipmaps&&y&&b.minFilter!==$t&&b.minFilter!==mn}function R(b){n.generateMipmap(b)}function x(b,y,G,Z,ae=!1){if(a===!1)return y;if(b!==null){if(n[b]!==void 0)return n[b];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+b+"'")}let le=y;return y===6403&&(G===5126&&(le=33326),G===5131&&(le=33325),G===5121&&(le=33321)),y===33319&&(G===5126&&(le=33328),G===5131&&(le=33327),G===5121&&(le=33323)),y===6408&&(G===5126&&(le=34836),G===5131&&(le=34842),G===5121&&(le=Z===it&&ae===!1?35907:32856),G===32819&&(le=32854),G===32820&&(le=32855)),(le===33325||le===33326||le===33327||le===33328||le===34842||le===34836)&&e.get("EXT_color_buffer_float"),le}function A(b,y,G){return T(b,G)===!0||b.isFramebufferTexture&&b.minFilter!==$t&&b.minFilter!==mn?Math.log2(Math.max(y.width,y.height))+1:b.mipmaps!==void 0&&b.mipmaps.length>0?b.mipmaps.length:b.isCompressedTexture&&Array.isArray(b.image)?y.mipmaps.length:1}function I(b){return b===$t||b===Hm||b===Gm?9728:9729}function N(b){const y=b.target;y.removeEventListener("dispose",N),q(y),y.isVideoTexture&&v.delete(y)}function J(b){const y=b.target;y.removeEventListener("dispose",J),$(y)}function q(b){const y=i.get(b);if(y.__webglInit===void 0)return;const G=b.source,Z=f.get(G);if(Z){const ae=Z[y.__cacheKey];ae.usedTimes--,ae.usedTimes===0&&L(b),Object.keys(Z).length===0&&f.delete(G)}i.remove(b)}function L(b){const y=i.get(b);n.deleteTexture(y.__webglTexture);const G=b.source,Z=f.get(G);delete Z[y.__cacheKey],o.memory.textures--}function $(b){const y=b.texture,G=i.get(b),Z=i.get(y);if(Z.__webglTexture!==void 0&&(n.deleteTexture(Z.__webglTexture),o.memory.textures--),b.depthTexture&&b.depthTexture.dispose(),b.isWebGLCubeRenderTarget)for(let ae=0;ae<6;ae++)n.deleteFramebuffer(G.__webglFramebuffer[ae]),G.__webglDepthbuffer&&n.deleteRenderbuffer(G.__webglDepthbuffer[ae]);else n.deleteFramebuffer(G.__webglFramebuffer),G.__webglDepthbuffer&&n.deleteRenderbuffer(G.__webglDepthbuffer),G.__webglMultisampledFramebuffer&&n.deleteFramebuffer(G.__webglMultisampledFramebuffer),G.__webglColorRenderbuffer&&n.deleteRenderbuffer(G.__webglColorRenderbuffer),G.__webglDepthRenderbuffer&&n.deleteRenderbuffer(G.__webglDepthRenderbuffer);if(b.isWebGLMultipleRenderTargets)for(let ae=0,le=y.length;ae<le;ae++){const me=i.get(y[ae]);me.__webglTexture&&(n.deleteTexture(me.__webglTexture),o.memory.textures--),i.remove(y[ae])}i.remove(y),i.remove(b)}let z=0;function W(){z=0}function U(){const b=z;return b>=l&&console.warn("THREE.WebGLTextures: Trying to use "+b+" texture units while this GPU supports only "+l),z+=1,b}function P(b){const y=[];return y.push(b.wrapS),y.push(b.wrapT),y.push(b.magFilter),y.push(b.minFilter),y.push(b.anisotropy),y.push(b.internalFormat),y.push(b.format),y.push(b.type),y.push(b.generateMipmaps),y.push(b.premultiplyAlpha),y.push(b.flipY),y.push(b.unpackAlignment),y.push(b.encoding),y.join()}function k(b,y){const G=i.get(b);if(b.isVideoTexture&&et(b),b.isRenderTargetTexture===!1&&b.version>0&&G.__version!==b.version){const Z=b.image;if(Z===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(Z.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Me(G,b,y);return}}t.activeTexture(33984+y),t.bindTexture(3553,G.__webglTexture)}function Y(b,y){const G=i.get(b);if(b.version>0&&G.__version!==b.version){Me(G,b,y);return}t.activeTexture(33984+y),t.bindTexture(35866,G.__webglTexture)}function j(b,y){const G=i.get(b);if(b.version>0&&G.__version!==b.version){Me(G,b,y);return}t.activeTexture(33984+y),t.bindTexture(32879,G.__webglTexture)}function K(b,y){const G=i.get(b);if(b.version>0&&G.__version!==b.version){Ce(G,b,y);return}t.activeTexture(33984+y),t.bindTexture(34067,G.__webglTexture)}const ce={[Ya]:10497,[ci]:33071,[hd]:33648},de={[$t]:9728,[Hm]:9984,[Gm]:9986,[mn]:9729,[TS]:9985,[_l]:9987};function F(b,y,G){if(G?(n.texParameteri(b,10242,ce[y.wrapS]),n.texParameteri(b,10243,ce[y.wrapT]),(b===32879||b===35866)&&n.texParameteri(b,32882,ce[y.wrapR]),n.texParameteri(b,10240,de[y.magFilter]),n.texParameteri(b,10241,de[y.minFilter])):(n.texParameteri(b,10242,33071),n.texParameteri(b,10243,33071),(b===32879||b===35866)&&n.texParameteri(b,32882,33071),(y.wrapS!==ci||y.wrapT!==ci)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(b,10240,I(y.magFilter)),n.texParameteri(b,10241,I(y.minFilter)),y.minFilter!==$t&&y.minFilter!==mn&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),e.has("EXT_texture_filter_anisotropic")===!0){const Z=e.get("EXT_texture_filter_anisotropic");if(y.type===ls&&e.has("OES_texture_float_linear")===!1||a===!1&&y.type===Fc&&e.has("OES_texture_half_float_linear")===!1)return;(y.anisotropy>1||i.get(y).__currentAnisotropy)&&(n.texParameterf(b,Z.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(y.anisotropy,r.getMaxAnisotropy())),i.get(y).__currentAnisotropy=y.anisotropy)}}function We(b,y){let G=!1;b.__webglInit===void 0&&(b.__webglInit=!0,y.addEventListener("dispose",N));const Z=y.source;let ae=f.get(Z);ae===void 0&&(ae={},f.set(Z,ae));const le=P(y);if(le!==b.__cacheKey){ae[le]===void 0&&(ae[le]={texture:n.createTexture(),usedTimes:0},o.memory.textures++,G=!0),ae[le].usedTimes++;const me=ae[b.__cacheKey];me!==void 0&&(ae[b.__cacheKey].usedTimes--,me.usedTimes===0&&L(y)),b.__cacheKey=le,b.__webglTexture=ae[le].texture}return G}function Me(b,y,G){let Z=3553;y.isDataArrayTexture&&(Z=35866),y.isData3DTexture&&(Z=32879);const ae=We(b,y),le=y.source;if(t.activeTexture(33984+G),t.bindTexture(Z,b.__webglTexture),le.version!==le.__currentVersion||ae===!0){n.pixelStorei(37440,y.flipY),n.pixelStorei(37441,y.premultiplyAlpha),n.pixelStorei(3317,y.unpackAlignment),n.pixelStorei(37443,0);const me=S(y)&&E(y.image)===!1;let V=M(y.image,me,!1,u);V=qe(y,V);const Ae=E(V)||a,Ie=s.convert(y.format,y.encoding);let he=s.convert(y.type),C=x(y.internalFormat,Ie,he,y.encoding,y.isVideoTexture);F(Z,y,Ae);let ie;const te=y.mipmaps,_e=a&&y.isVideoTexture!==!0,ue=b.__version===void 0||ae===!0,ge=A(y,V,Ae);if(y.isDepthTexture)C=6402,a?y.type===ls?C=36012:y.type===Xh?C=33190:y.type===Ua?C=35056:C=33189:y.type===ls&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),y.format===oo&&C===6402&&y.type!==Nc&&y.type!==Xh&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),y.type=Nc,he=s.convert(y.type)),y.format===Ka&&C===6402&&(C=34041,y.type!==Ua&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),y.type=Ua,he=s.convert(y.type))),ue&&(_e?t.texStorage2D(3553,1,C,V.width,V.height):t.texImage2D(3553,0,C,V.width,V.height,0,Ie,he,null));else if(y.isDataTexture)if(te.length>0&&Ae){_e&&ue&&t.texStorage2D(3553,ge,C,te[0].width,te[0].height);for(let ee=0,xe=te.length;ee<xe;ee++)ie=te[ee],_e?t.texSubImage2D(3553,ee,0,0,ie.width,ie.height,Ie,he,ie.data):t.texImage2D(3553,ee,C,ie.width,ie.height,0,Ie,he,ie.data);y.generateMipmaps=!1}else _e?(ue&&t.texStorage2D(3553,ge,C,V.width,V.height),t.texSubImage2D(3553,0,0,0,V.width,V.height,Ie,he,V.data)):t.texImage2D(3553,0,C,V.width,V.height,0,Ie,he,V.data);else if(y.isCompressedTexture){_e&&ue&&t.texStorage2D(3553,ge,C,te[0].width,te[0].height);for(let ee=0,xe=te.length;ee<xe;ee++)ie=te[ee],y.format!==ui?Ie!==null?_e?t.compressedTexSubImage2D(3553,ee,0,0,ie.width,ie.height,Ie,ie.data):t.compressedTexImage2D(3553,ee,C,ie.width,ie.height,0,ie.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):_e?t.texSubImage2D(3553,ee,0,0,ie.width,ie.height,Ie,he,ie.data):t.texImage2D(3553,ee,C,ie.width,ie.height,0,Ie,he,ie.data)}else if(y.isDataArrayTexture)_e?(ue&&t.texStorage3D(35866,ge,C,V.width,V.height,V.depth),t.texSubImage3D(35866,0,0,0,0,V.width,V.height,V.depth,Ie,he,V.data)):t.texImage3D(35866,0,C,V.width,V.height,V.depth,0,Ie,he,V.data);else if(y.isData3DTexture)_e?(ue&&t.texStorage3D(32879,ge,C,V.width,V.height,V.depth),t.texSubImage3D(32879,0,0,0,0,V.width,V.height,V.depth,Ie,he,V.data)):t.texImage3D(32879,0,C,V.width,V.height,V.depth,0,Ie,he,V.data);else if(y.isFramebufferTexture){if(ue)if(_e)t.texStorage2D(3553,ge,C,V.width,V.height);else{let ee=V.width,xe=V.height;for(let He=0;He<ge;He++)t.texImage2D(3553,He,C,ee,xe,0,Ie,he,null),ee>>=1,xe>>=1}}else if(te.length>0&&Ae){_e&&ue&&t.texStorage2D(3553,ge,C,te[0].width,te[0].height);for(let ee=0,xe=te.length;ee<xe;ee++)ie=te[ee],_e?t.texSubImage2D(3553,ee,0,0,Ie,he,ie):t.texImage2D(3553,ee,C,Ie,he,ie);y.generateMipmaps=!1}else _e?(ue&&t.texStorage2D(3553,ge,C,V.width,V.height),t.texSubImage2D(3553,0,0,0,Ie,he,V)):t.texImage2D(3553,0,C,Ie,he,V);T(y,Ae)&&R(Z),le.__currentVersion=le.version,y.onUpdate&&y.onUpdate(y)}b.__version=y.version}function Ce(b,y,G){if(y.image.length!==6)return;const Z=We(b,y),ae=y.source;if(t.activeTexture(33984+G),t.bindTexture(34067,b.__webglTexture),ae.version!==ae.__currentVersion||Z===!0){n.pixelStorei(37440,y.flipY),n.pixelStorei(37441,y.premultiplyAlpha),n.pixelStorei(3317,y.unpackAlignment),n.pixelStorei(37443,0);const le=y.isCompressedTexture||y.image[0].isCompressedTexture,me=y.image[0]&&y.image[0].isDataTexture,V=[];for(let ee=0;ee<6;ee++)!le&&!me?V[ee]=M(y.image[ee],!1,!0,c):V[ee]=me?y.image[ee].image:y.image[ee],V[ee]=qe(y,V[ee]);const Ae=V[0],Ie=E(Ae)||a,he=s.convert(y.format,y.encoding),C=s.convert(y.type),ie=x(y.internalFormat,he,C,y.encoding),te=a&&y.isVideoTexture!==!0,_e=b.__version===void 0;let ue=A(y,Ae,Ie);F(34067,y,Ie);let ge;if(le){te&&_e&&t.texStorage2D(34067,ue,ie,Ae.width,Ae.height);for(let ee=0;ee<6;ee++){ge=V[ee].mipmaps;for(let xe=0;xe<ge.length;xe++){const He=ge[xe];y.format!==ui?he!==null?te?t.compressedTexSubImage2D(34069+ee,xe,0,0,He.width,He.height,he,He.data):t.compressedTexImage2D(34069+ee,xe,ie,He.width,He.height,0,He.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):te?t.texSubImage2D(34069+ee,xe,0,0,He.width,He.height,he,C,He.data):t.texImage2D(34069+ee,xe,ie,He.width,He.height,0,he,C,He.data)}}}else{ge=y.mipmaps,te&&_e&&(ge.length>0&&ue++,t.texStorage2D(34067,ue,ie,V[0].width,V[0].height));for(let ee=0;ee<6;ee++)if(me){te?t.texSubImage2D(34069+ee,0,0,0,V[ee].width,V[ee].height,he,C,V[ee].data):t.texImage2D(34069+ee,0,ie,V[ee].width,V[ee].height,0,he,C,V[ee].data);for(let xe=0;xe<ge.length;xe++){const Ne=ge[xe].image[ee].image;te?t.texSubImage2D(34069+ee,xe+1,0,0,Ne.width,Ne.height,he,C,Ne.data):t.texImage2D(34069+ee,xe+1,ie,Ne.width,Ne.height,0,he,C,Ne.data)}}else{te?t.texSubImage2D(34069+ee,0,0,0,he,C,V[ee]):t.texImage2D(34069+ee,0,ie,he,C,V[ee]);for(let xe=0;xe<ge.length;xe++){const He=ge[xe];te?t.texSubImage2D(34069+ee,xe+1,0,0,he,C,He.image[ee]):t.texImage2D(34069+ee,xe+1,ie,he,C,He.image[ee])}}}T(y,Ie)&&R(34067),ae.__currentVersion=ae.version,y.onUpdate&&y.onUpdate(y)}b.__version=y.version}function re(b,y,G,Z,ae){const le=s.convert(G.format,G.encoding),me=s.convert(G.type),V=x(G.internalFormat,le,me,G.encoding);i.get(y).__hasExternalTextures||(ae===32879||ae===35866?t.texImage3D(ae,0,V,y.width,y.height,y.depth,0,le,me,null):t.texImage2D(ae,0,V,y.width,y.height,0,le,me,null)),t.bindFramebuffer(36160,b),Te(y)?d.framebufferTexture2DMultisampleEXT(36160,Z,ae,i.get(G).__webglTexture,0,Oe(y)):n.framebufferTexture2D(36160,Z,ae,i.get(G).__webglTexture,0),t.bindFramebuffer(36160,null)}function ze(b,y,G){if(n.bindRenderbuffer(36161,b),y.depthBuffer&&!y.stencilBuffer){let Z=33189;if(G||Te(y)){const ae=y.depthTexture;ae&&ae.isDepthTexture&&(ae.type===ls?Z=36012:ae.type===Xh&&(Z=33190));const le=Oe(y);Te(y)?d.renderbufferStorageMultisampleEXT(36161,le,Z,y.width,y.height):n.renderbufferStorageMultisample(36161,le,Z,y.width,y.height)}else n.renderbufferStorage(36161,Z,y.width,y.height);n.framebufferRenderbuffer(36160,36096,36161,b)}else if(y.depthBuffer&&y.stencilBuffer){const Z=Oe(y);G&&Te(y)===!1?n.renderbufferStorageMultisample(36161,Z,35056,y.width,y.height):Te(y)?d.renderbufferStorageMultisampleEXT(36161,Z,35056,y.width,y.height):n.renderbufferStorage(36161,34041,y.width,y.height),n.framebufferRenderbuffer(36160,33306,36161,b)}else{const Z=y.isWebGLMultipleRenderTargets===!0?y.texture[0]:y.texture,ae=s.convert(Z.format,Z.encoding),le=s.convert(Z.type),me=x(Z.internalFormat,ae,le,Z.encoding),V=Oe(y);G&&Te(y)===!1?n.renderbufferStorageMultisample(36161,V,me,y.width,y.height):Te(y)?d.renderbufferStorageMultisampleEXT(36161,V,me,y.width,y.height):n.renderbufferStorage(36161,me,y.width,y.height)}n.bindRenderbuffer(36161,null)}function oe(b,y){if(y&&y.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,b),!(y.depthTexture&&y.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!i.get(y.depthTexture).__webglTexture||y.depthTexture.image.width!==y.width||y.depthTexture.image.height!==y.height)&&(y.depthTexture.image.width=y.width,y.depthTexture.image.height=y.height,y.depthTexture.needsUpdate=!0),k(y.depthTexture,0);const Z=i.get(y.depthTexture).__webglTexture,ae=Oe(y);if(y.depthTexture.format===oo)Te(y)?d.framebufferTexture2DMultisampleEXT(36160,36096,3553,Z,0,ae):n.framebufferTexture2D(36160,36096,3553,Z,0);else if(y.depthTexture.format===Ka)Te(y)?d.framebufferTexture2DMultisampleEXT(36160,33306,3553,Z,0,ae):n.framebufferTexture2D(36160,33306,3553,Z,0);else throw new Error("Unknown depthTexture format")}function ne(b){const y=i.get(b),G=b.isWebGLCubeRenderTarget===!0;if(b.depthTexture&&!y.__autoAllocateDepthBuffer){if(G)throw new Error("target.depthTexture not supported in Cube render targets");oe(y.__webglFramebuffer,b)}else if(G){y.__webglDepthbuffer=[];for(let Z=0;Z<6;Z++)t.bindFramebuffer(36160,y.__webglFramebuffer[Z]),y.__webglDepthbuffer[Z]=n.createRenderbuffer(),ze(y.__webglDepthbuffer[Z],b,!1)}else t.bindFramebuffer(36160,y.__webglFramebuffer),y.__webglDepthbuffer=n.createRenderbuffer(),ze(y.__webglDepthbuffer,b,!1);t.bindFramebuffer(36160,null)}function pe(b,y,G){const Z=i.get(b);y!==void 0&&re(Z.__webglFramebuffer,b,b.texture,36064,3553),G!==void 0&&ne(b)}function De(b){const y=b.texture,G=i.get(b),Z=i.get(y);b.addEventListener("dispose",J),b.isWebGLMultipleRenderTargets!==!0&&(Z.__webglTexture===void 0&&(Z.__webglTexture=n.createTexture()),Z.__version=y.version,o.memory.textures++);const ae=b.isWebGLCubeRenderTarget===!0,le=b.isWebGLMultipleRenderTargets===!0,me=E(b)||a;if(ae){G.__webglFramebuffer=[];for(let V=0;V<6;V++)G.__webglFramebuffer[V]=n.createFramebuffer()}else if(G.__webglFramebuffer=n.createFramebuffer(),le)if(r.drawBuffers){const V=b.texture;for(let Ae=0,Ie=V.length;Ae<Ie;Ae++){const he=i.get(V[Ae]);he.__webglTexture===void 0&&(he.__webglTexture=n.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(a&&b.samples>0&&Te(b)===!1){G.__webglMultisampledFramebuffer=n.createFramebuffer(),G.__webglColorRenderbuffer=n.createRenderbuffer(),n.bindRenderbuffer(36161,G.__webglColorRenderbuffer);const V=s.convert(y.format,y.encoding),Ae=s.convert(y.type),Ie=x(y.internalFormat,V,Ae,y.encoding),he=Oe(b);n.renderbufferStorageMultisample(36161,he,Ie,b.width,b.height),t.bindFramebuffer(36160,G.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064,36161,G.__webglColorRenderbuffer),n.bindRenderbuffer(36161,null),b.depthBuffer&&(G.__webglDepthRenderbuffer=n.createRenderbuffer(),ze(G.__webglDepthRenderbuffer,b,!0)),t.bindFramebuffer(36160,null)}if(ae){t.bindTexture(34067,Z.__webglTexture),F(34067,y,me);for(let V=0;V<6;V++)re(G.__webglFramebuffer[V],b,y,36064,34069+V);T(y,me)&&R(34067),t.unbindTexture()}else if(le){const V=b.texture;for(let Ae=0,Ie=V.length;Ae<Ie;Ae++){const he=V[Ae],C=i.get(he);t.bindTexture(3553,C.__webglTexture),F(3553,he,me),re(G.__webglFramebuffer,b,he,36064+Ae,3553),T(he,me)&&R(3553)}t.unbindTexture()}else{let V=3553;(b.isWebGL3DRenderTarget||b.isWebGLArrayRenderTarget)&&(a?V=b.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(V,Z.__webglTexture),F(V,y,me),re(G.__webglFramebuffer,b,y,36064,V),T(y,me)&&R(V),t.unbindTexture()}b.depthBuffer&&ne(b)}function Se(b){const y=E(b)||a,G=b.isWebGLMultipleRenderTargets===!0?b.texture:[b.texture];for(let Z=0,ae=G.length;Z<ae;Z++){const le=G[Z];if(T(le,y)){const me=b.isWebGLCubeRenderTarget?34067:3553,V=i.get(le).__webglTexture;t.bindTexture(me,V),R(me),t.unbindTexture()}}}function $e(b){if(a&&b.samples>0&&Te(b)===!1){const y=b.width,G=b.height;let Z=16384;const ae=[36064],le=b.stencilBuffer?33306:36096;b.depthBuffer&&ae.push(le);const me=i.get(b),V=me.__ignoreDepthValues!==void 0?me.__ignoreDepthValues:!1;V===!1&&(b.depthBuffer&&(Z|=256),b.stencilBuffer&&(Z|=1024)),t.bindFramebuffer(36008,me.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,me.__webglFramebuffer),V===!0&&(n.invalidateFramebuffer(36008,[le]),n.invalidateFramebuffer(36009,[le])),n.blitFramebuffer(0,0,y,G,0,0,y,G,Z,9728),p&&n.invalidateFramebuffer(36008,ae),t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,me.__webglMultisampledFramebuffer)}}function Oe(b){return Math.min(h,b.samples)}function Te(b){const y=i.get(b);return a&&b.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&y.__useRenderToTexture!==!1}function et(b){const y=o.render.frame;v.get(b)!==y&&(v.set(b,y),b.update())}function qe(b,y){const G=b.encoding,Z=b.format,ae=b.type;return b.isCompressedTexture===!0||b.isVideoTexture===!0||b.format===Vm||G!==bs&&(G===it?a===!1?e.has("EXT_sRGB")===!0&&Z===ui?(b.format=Vm,b.minFilter=mn,b.generateMipmaps=!1):y=Ao.sRGBToLinear(y):(Z!==ui||ae!==mo)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",G)),y}this.allocateTextureUnit=U,this.resetTextureUnits=W,this.setTexture2D=k,this.setTexture2DArray=Y,this.setTexture3D=j,this.setTextureCube=K,this.rebindTextures=pe,this.setupRenderTarget=De,this.updateRenderTargetMipmap=Se,this.updateMultisampleRenderTarget=$e,this.setupDepthRenderbuffer=ne,this.setupFrameBufferTexture=re,this.useMultisampledRTT=Te}function XL(n,e,t){const i=t.isWebGL2;function r(s,o=null){let a;if(s===mo)return 5121;if(s===RT)return 32819;if(s===LT)return 32820;if(s===TT)return 5120;if(s===AT)return 5122;if(s===Nc)return 5123;if(s===CT)return 5124;if(s===Xh)return 5125;if(s===ls)return 5126;if(s===Fc)return i?5131:(a=e.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(s===PT)return 6406;if(s===ui)return 6408;if(s===IT)return 6409;if(s===NT)return 6410;if(s===oo)return 6402;if(s===Ka)return 34041;if(s===FT)return 6403;if(s===DT)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(s===Vm)return a=e.get("EXT_sRGB"),a!==null?a.SRGB_ALPHA_EXT:null;if(s===UT)return 36244;if(s===OT)return 33319;if(s===BT)return 33320;if(s===zT)return 36249;if(s===Nf||s===Ff||s===Uf||s===Of)if(o===it)if(a=e.get("WEBGL_compressed_texture_s3tc_srgb"),a!==null){if(s===Nf)return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(s===Ff)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(s===Uf)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(s===Of)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(a=e.get("WEBGL_compressed_texture_s3tc"),a!==null){if(s===Nf)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===Ff)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===Uf)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===Of)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===Jv||s===Qv||s===e_||s===t_)if(a=e.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(s===Jv)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===Qv)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===e_)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===t_)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===kT)return a=e.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if(s===n_||s===i_)if(a=e.get("WEBGL_compressed_texture_etc"),a!==null){if(s===n_)return o===it?a.COMPRESSED_SRGB8_ETC2:a.COMPRESSED_RGB8_ETC2;if(s===i_)return o===it?a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(s===r_||s===s_||s===o_||s===a_||s===l_||s===c_||s===u_||s===h_||s===d_||s===f_||s===p_||s===m_||s===g_||s===v_)if(a=e.get("WEBGL_compressed_texture_astc"),a!==null){if(s===r_)return o===it?a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:a.COMPRESSED_RGBA_ASTC_4x4_KHR;if(s===s_)return o===it?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:a.COMPRESSED_RGBA_ASTC_5x4_KHR;if(s===o_)return o===it?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:a.COMPRESSED_RGBA_ASTC_5x5_KHR;if(s===a_)return o===it?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:a.COMPRESSED_RGBA_ASTC_6x5_KHR;if(s===l_)return o===it?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:a.COMPRESSED_RGBA_ASTC_6x6_KHR;if(s===c_)return o===it?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:a.COMPRESSED_RGBA_ASTC_8x5_KHR;if(s===u_)return o===it?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:a.COMPRESSED_RGBA_ASTC_8x6_KHR;if(s===h_)return o===it?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:a.COMPRESSED_RGBA_ASTC_8x8_KHR;if(s===d_)return o===it?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:a.COMPRESSED_RGBA_ASTC_10x5_KHR;if(s===f_)return o===it?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:a.COMPRESSED_RGBA_ASTC_10x6_KHR;if(s===p_)return o===it?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:a.COMPRESSED_RGBA_ASTC_10x8_KHR;if(s===m_)return o===it?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:a.COMPRESSED_RGBA_ASTC_10x10_KHR;if(s===g_)return o===it?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:a.COMPRESSED_RGBA_ASTC_12x10_KHR;if(s===v_)return o===it?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:a.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(s===__)if(a=e.get("EXT_texture_compression_bptc"),a!==null){if(s===__)return o===it?a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:a.COMPRESSED_RGBA_BPTC_UNORM_EXT}else return null;return s===Ua?i?34042:(a=e.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null):n[s]!==void 0?n[s]:null}return{convert:r}}class $S extends gn{constructor(e=[]){super(),this.cameras=e}}$S.prototype.isArrayCamera=!0;class yt extends at{constructor(){super(),this.type="Group"}}yt.prototype.isGroup=!0;const jL={type:"move"};class hp{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new yt,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new yt,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new B,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new B),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new yt,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new B,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new B),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,i){let r=null,s=null,o=null;const a=this._targetRay,l=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred")if(a!==null&&(r=t.getPose(e.targetRaySpace,i),r!==null&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(jL))),c&&e.hand){o=!0;for(const m of e.hand.values()){const f=t.getJointPose(m,i);if(c.joints[m.jointName]===void 0){const _=new yt;_.matrixAutoUpdate=!1,_.visible=!1,c.joints[m.jointName]=_,c.add(_)}const g=c.joints[m.jointName];f!==null&&(g.matrix.fromArray(f.transform.matrix),g.matrix.decompose(g.position,g.rotation,g.scale),g.jointRadius=f.radius),g.visible=f!==null}const u=c.joints["index-finger-tip"],h=c.joints["thumb-tip"],d=u.position.distanceTo(h.position),p=.02,v=.005;c.inputState.pinching&&d>p+v?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&d<=p-v&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(s=t.getPose(e.gripSpace,i),s!==null&&(l.matrix.fromArray(s.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),s.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(s.linearVelocity)):l.hasLinearVelocity=!1,s.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(s.angularVelocity)):l.hasAngularVelocity=!1));return a!==null&&(a.visible=r!==null),l!==null&&(l.visible=s!==null),c!==null&&(c.visible=o!==null),this}}class XS extends Ht{constructor(e,t,i,r,s,o,a,l,c,u){if(u=u!==void 0?u:oo,u!==oo&&u!==Ka)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");i===void 0&&u===oo&&(i=Nc),i===void 0&&u===Ka&&(i=Ua),super(null,r,s,o,a,l,u,i,c),this.image={width:e,height:t},this.magFilter=a!==void 0?a:$t,this.minFilter=l!==void 0?l:$t,this.flipY=!1,this.generateMipmaps=!1}}XS.prototype.isDepthTexture=!0;class qL extends To{constructor(e,t){super();const i=this;let r=null,s=1,o=null,a="local-floor",l=null,c=null,u=null,h=null,d=null,p=null;const v=t.getContextAttributes();let m=null,f=null;const g=[],_=new Map,M=new gn;M.layers.enable(1),M.viewport=new ut;const E=new gn;E.layers.enable(2),E.viewport=new ut;const S=[M,E],T=new $S;T.layers.enable(1),T.layers.enable(2);let R=null,x=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(P){let k=g[P];return k===void 0&&(k=new hp,g[P]=k),k.getTargetRaySpace()},this.getControllerGrip=function(P){let k=g[P];return k===void 0&&(k=new hp,g[P]=k),k.getGripSpace()},this.getHand=function(P){let k=g[P];return k===void 0&&(k=new hp,g[P]=k),k.getHandSpace()};function A(P){const k=_.get(P.inputSource);k&&k.dispatchEvent({type:P.type,data:P.inputSource})}function I(){_.forEach(function(P,k){P.disconnect(k)}),_.clear(),R=null,x=null,e.setRenderTarget(m),d=null,h=null,u=null,r=null,f=null,U.stop(),i.isPresenting=!1,i.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(P){s=P,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(P){a=P,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||o},this.setReferenceSpace=function(P){l=P},this.getBaseLayer=function(){return h!==null?h:d},this.getBinding=function(){return u},this.getFrame=function(){return p},this.getSession=function(){return r},this.setSession=async function(P){if(r=P,r!==null){if(m=e.getRenderTarget(),r.addEventListener("select",A),r.addEventListener("selectstart",A),r.addEventListener("selectend",A),r.addEventListener("squeeze",A),r.addEventListener("squeezestart",A),r.addEventListener("squeezeend",A),r.addEventListener("end",I),r.addEventListener("inputsourceschange",N),v.xrCompatible!==!0&&await t.makeXRCompatible(),r.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const k={antialias:r.renderState.layers===void 0?v.antialias:!0,alpha:v.alpha,depth:v.depth,stencil:v.stencil,framebufferScaleFactor:s};d=new XRWebGLLayer(r,t,k),r.updateRenderState({baseLayer:d}),f=new on(d.framebufferWidth,d.framebufferHeight,{format:ui,type:mo,encoding:e.outputEncoding})}else{let k=null,Y=null,j=null;v.depth&&(j=v.stencil?35056:33190,k=v.stencil?Ka:oo,Y=v.stencil?Ua:Nc);const K={colorFormat:e.outputEncoding===it?35907:32856,depthFormat:j,scaleFactor:s};u=new XRWebGLBinding(r,t),h=u.createProjectionLayer(K),r.updateRenderState({layers:[h]}),f=new on(h.textureWidth,h.textureHeight,{format:ui,type:mo,depthTexture:new XS(h.textureWidth,h.textureHeight,Y,void 0,void 0,void 0,void 0,void 0,void 0,k),stencilBuffer:v.stencil,encoding:e.outputEncoding,samples:v.antialias?4:0});const ce=e.properties.get(f);ce.__ignoreDepthValues=h.ignoreDepthValues}f.isXRRenderTarget=!0,this.setFoveation(1),o=await r.requestReferenceSpace(a),U.setContext(r),U.start(),i.isPresenting=!0,i.dispatchEvent({type:"sessionstart"})}};function N(P){const k=r.inputSources;for(let Y=0;Y<k.length;Y++){const j=k[Y].handedness==="right"?1:0;_.set(k[Y],g[j])}for(let Y=0;Y<P.removed.length;Y++){const j=P.removed[Y],K=_.get(j);K&&(K.dispatchEvent({type:"disconnected",data:j}),_.delete(j))}for(let Y=0;Y<P.added.length;Y++){const j=P.added[Y],K=_.get(j);K&&K.dispatchEvent({type:"connected",data:j})}}const J=new B,q=new B;function L(P,k,Y){J.setFromMatrixPosition(k.matrixWorld),q.setFromMatrixPosition(Y.matrixWorld);const j=J.distanceTo(q),K=k.projectionMatrix.elements,ce=Y.projectionMatrix.elements,de=K[14]/(K[10]-1),F=K[14]/(K[10]+1),We=(K[9]+1)/K[5],Me=(K[9]-1)/K[5],Ce=(K[8]-1)/K[0],re=(ce[8]+1)/ce[0],ze=de*Ce,oe=de*re,ne=j/(-Ce+re),pe=ne*-Ce;k.matrixWorld.decompose(P.position,P.quaternion,P.scale),P.translateX(pe),P.translateZ(ne),P.matrixWorld.compose(P.position,P.quaternion,P.scale),P.matrixWorldInverse.copy(P.matrixWorld).invert();const De=de+ne,Se=F+ne,$e=ze-pe,Oe=oe+(j-pe),Te=We*F/Se*De,et=Me*F/Se*De;P.projectionMatrix.makePerspective($e,Oe,Te,et,De,Se)}function $(P,k){k===null?P.matrixWorld.copy(P.matrix):P.matrixWorld.multiplyMatrices(k.matrixWorld,P.matrix),P.matrixWorldInverse.copy(P.matrixWorld).invert()}this.updateCamera=function(P){if(r===null)return;T.near=E.near=M.near=P.near,T.far=E.far=M.far=P.far,(R!==T.near||x!==T.far)&&(r.updateRenderState({depthNear:T.near,depthFar:T.far}),R=T.near,x=T.far);const k=P.parent,Y=T.cameras;$(T,k);for(let K=0;K<Y.length;K++)$(Y[K],k);T.matrixWorld.decompose(T.position,T.quaternion,T.scale),P.position.copy(T.position),P.quaternion.copy(T.quaternion),P.scale.copy(T.scale),P.matrix.copy(T.matrix),P.matrixWorld.copy(T.matrixWorld);const j=P.children;for(let K=0,ce=j.length;K<ce;K++)j[K].updateMatrixWorld(!0);Y.length===2?L(T,M,E):T.projectionMatrix.copy(M.projectionMatrix)},this.getCamera=function(){return T},this.getFoveation=function(){if(h!==null)return h.fixedFoveation;if(d!==null)return d.fixedFoveation},this.setFoveation=function(P){h!==null&&(h.fixedFoveation=P),d!==null&&d.fixedFoveation!==void 0&&(d.fixedFoveation=P)};let z=null;function W(P,k){if(c=k.getViewerPose(l||o),p=k,c!==null){const j=c.views;d!==null&&(e.setRenderTargetFramebuffer(f,d.framebuffer),e.setRenderTarget(f));let K=!1;j.length!==T.cameras.length&&(T.cameras.length=0,K=!0);for(let ce=0;ce<j.length;ce++){const de=j[ce];let F=null;if(d!==null)F=d.getViewport(de);else{const Me=u.getViewSubImage(h,de);F=Me.viewport,ce===0&&(e.setRenderTargetTextures(f,Me.colorTexture,h.ignoreDepthValues?void 0:Me.depthStencilTexture),e.setRenderTarget(f))}const We=S[ce];We.matrix.fromArray(de.transform.matrix),We.projectionMatrix.fromArray(de.projectionMatrix),We.viewport.set(F.x,F.y,F.width,F.height),ce===0&&T.matrix.copy(We.matrix),K===!0&&T.cameras.push(We)}}const Y=r.inputSources;for(let j=0;j<g.length;j++){const K=Y[j],ce=_.get(K);ce!==void 0&&ce.update(K,k,l||o)}z&&z(P,k),p=null}const U=new OS;U.setAnimationLoop(W),this.setAnimationLoop=function(P){z=P},this.dispose=function(){}}}function YL(n,e){function t(m,f){m.fogColor.value.copy(f.color),f.isFog?(m.fogNear.value=f.near,m.fogFar.value=f.far):f.isFogExp2&&(m.fogDensity.value=f.density)}function i(m,f,g,_,M){f.isMeshBasicMaterial||f.isMeshLambertMaterial?r(m,f):f.isMeshToonMaterial?(r(m,f),u(m,f)):f.isMeshPhongMaterial?(r(m,f),c(m,f)):f.isMeshStandardMaterial?(r(m,f),h(m,f),f.isMeshPhysicalMaterial&&d(m,f,M)):f.isMeshMatcapMaterial?(r(m,f),p(m,f)):f.isMeshDepthMaterial?r(m,f):f.isMeshDistanceMaterial?(r(m,f),v(m,f)):f.isMeshNormalMaterial?r(m,f):f.isLineBasicMaterial?(s(m,f),f.isLineDashedMaterial&&o(m,f)):f.isPointsMaterial?a(m,f,g,_):f.isSpriteMaterial?l(m,f):f.isShadowMaterial?(m.color.value.copy(f.color),m.opacity.value=f.opacity):f.isShaderMaterial&&(f.uniformsNeedUpdate=!1)}function r(m,f){m.opacity.value=f.opacity,f.color&&m.diffuse.value.copy(f.color),f.emissive&&m.emissive.value.copy(f.emissive).multiplyScalar(f.emissiveIntensity),f.map&&(m.map.value=f.map),f.alphaMap&&(m.alphaMap.value=f.alphaMap),f.bumpMap&&(m.bumpMap.value=f.bumpMap,m.bumpScale.value=f.bumpScale,f.side===Bi&&(m.bumpScale.value*=-1)),f.displacementMap&&(m.displacementMap.value=f.displacementMap,m.displacementScale.value=f.displacementScale,m.displacementBias.value=f.displacementBias),f.emissiveMap&&(m.emissiveMap.value=f.emissiveMap),f.normalMap&&(m.normalMap.value=f.normalMap,m.normalScale.value.copy(f.normalScale),f.side===Bi&&m.normalScale.value.negate()),f.specularMap&&(m.specularMap.value=f.specularMap),f.alphaTest>0&&(m.alphaTest.value=f.alphaTest);const g=e.get(f).envMap;if(g&&(m.envMap.value=g,m.flipEnvMap.value=g.isCubeTexture&&g.isRenderTargetTexture===!1?-1:1,m.reflectivity.value=f.reflectivity,m.ior.value=f.ior,m.refractionRatio.value=f.refractionRatio),f.lightMap){m.lightMap.value=f.lightMap;const E=n.physicallyCorrectLights!==!0?Math.PI:1;m.lightMapIntensity.value=f.lightMapIntensity*E}f.aoMap&&(m.aoMap.value=f.aoMap,m.aoMapIntensity.value=f.aoMapIntensity);let _;f.map?_=f.map:f.specularMap?_=f.specularMap:f.displacementMap?_=f.displacementMap:f.normalMap?_=f.normalMap:f.bumpMap?_=f.bumpMap:f.roughnessMap?_=f.roughnessMap:f.metalnessMap?_=f.metalnessMap:f.alphaMap?_=f.alphaMap:f.emissiveMap?_=f.emissiveMap:f.clearcoatMap?_=f.clearcoatMap:f.clearcoatNormalMap?_=f.clearcoatNormalMap:f.clearcoatRoughnessMap?_=f.clearcoatRoughnessMap:f.specularIntensityMap?_=f.specularIntensityMap:f.specularColorMap?_=f.specularColorMap:f.transmissionMap?_=f.transmissionMap:f.thicknessMap?_=f.thicknessMap:f.sheenColorMap?_=f.sheenColorMap:f.sheenRoughnessMap&&(_=f.sheenRoughnessMap),_!==void 0&&(_.isWebGLRenderTarget&&(_=_.texture),_.matrixAutoUpdate===!0&&_.updateMatrix(),m.uvTransform.value.copy(_.matrix));let M;f.aoMap?M=f.aoMap:f.lightMap&&(M=f.lightMap),M!==void 0&&(M.isWebGLRenderTarget&&(M=M.texture),M.matrixAutoUpdate===!0&&M.updateMatrix(),m.uv2Transform.value.copy(M.matrix))}function s(m,f){m.diffuse.value.copy(f.color),m.opacity.value=f.opacity}function o(m,f){m.dashSize.value=f.dashSize,m.totalSize.value=f.dashSize+f.gapSize,m.scale.value=f.scale}function a(m,f,g,_){m.diffuse.value.copy(f.color),m.opacity.value=f.opacity,m.size.value=f.size*g,m.scale.value=_*.5,f.map&&(m.map.value=f.map),f.alphaMap&&(m.alphaMap.value=f.alphaMap),f.alphaTest>0&&(m.alphaTest.value=f.alphaTest);let M;f.map?M=f.map:f.alphaMap&&(M=f.alphaMap),M!==void 0&&(M.matrixAutoUpdate===!0&&M.updateMatrix(),m.uvTransform.value.copy(M.matrix))}function l(m,f){m.diffuse.value.copy(f.color),m.opacity.value=f.opacity,m.rotation.value=f.rotation,f.map&&(m.map.value=f.map),f.alphaMap&&(m.alphaMap.value=f.alphaMap),f.alphaTest>0&&(m.alphaTest.value=f.alphaTest);let g;f.map?g=f.map:f.alphaMap&&(g=f.alphaMap),g!==void 0&&(g.matrixAutoUpdate===!0&&g.updateMatrix(),m.uvTransform.value.copy(g.matrix))}function c(m,f){m.specular.value.copy(f.specular),m.shininess.value=Math.max(f.shininess,1e-4)}function u(m,f){f.gradientMap&&(m.gradientMap.value=f.gradientMap)}function h(m,f){m.roughness.value=f.roughness,m.metalness.value=f.metalness,f.roughnessMap&&(m.roughnessMap.value=f.roughnessMap),f.metalnessMap&&(m.metalnessMap.value=f.metalnessMap),e.get(f).envMap&&(m.envMapIntensity.value=f.envMapIntensity)}function d(m,f,g){m.ior.value=f.ior,f.sheen>0&&(m.sheenColor.value.copy(f.sheenColor).multiplyScalar(f.sheen),m.sheenRoughness.value=f.sheenRoughness,f.sheenColorMap&&(m.sheenColorMap.value=f.sheenColorMap),f.sheenRoughnessMap&&(m.sheenRoughnessMap.value=f.sheenRoughnessMap)),f.clearcoat>0&&(m.clearcoat.value=f.clearcoat,m.clearcoatRoughness.value=f.clearcoatRoughness,f.clearcoatMap&&(m.clearcoatMap.value=f.clearcoatMap),f.clearcoatRoughnessMap&&(m.clearcoatRoughnessMap.value=f.clearcoatRoughnessMap),f.clearcoatNormalMap&&(m.clearcoatNormalScale.value.copy(f.clearcoatNormalScale),m.clearcoatNormalMap.value=f.clearcoatNormalMap,f.side===Bi&&m.clearcoatNormalScale.value.negate())),f.transmission>0&&(m.transmission.value=f.transmission,m.transmissionSamplerMap.value=g.texture,m.transmissionSamplerSize.value.set(g.width,g.height),f.transmissionMap&&(m.transmissionMap.value=f.transmissionMap),m.thickness.value=f.thickness,f.thicknessMap&&(m.thicknessMap.value=f.thicknessMap),m.attenuationDistance.value=f.attenuationDistance,m.attenuationColor.value.copy(f.attenuationColor)),m.specularIntensity.value=f.specularIntensity,m.specularColor.value.copy(f.specularColor),f.specularIntensityMap&&(m.specularIntensityMap.value=f.specularIntensityMap),f.specularColorMap&&(m.specularColorMap.value=f.specularColorMap)}function p(m,f){f.matcap&&(m.matcap.value=f.matcap)}function v(m,f){m.referencePosition.value.copy(f.referencePosition),m.nearDistance.value=f.nearDistance,m.farDistance.value=f.farDistance}return{refreshFogUniforms:t,refreshMaterialUniforms:i}}function KL(){const n=zc("canvas");return n.style.display="block",n}function ft(n={}){const e=n.canvas!==void 0?n.canvas:KL(),t=n.context!==void 0?n.context:null,i=n.depth!==void 0?n.depth:!0,r=n.stencil!==void 0?n.stencil:!0,s=n.antialias!==void 0?n.antialias:!1,o=n.premultipliedAlpha!==void 0?n.premultipliedAlpha:!0,a=n.preserveDrawingBuffer!==void 0?n.preserveDrawingBuffer:!1,l=n.powerPreference!==void 0?n.powerPreference:"default",c=n.failIfMajorPerformanceCaveat!==void 0?n.failIfMajorPerformanceCaveat:!1;let u;t!==null?u=t.getContextAttributes().alpha:u=n.alpha!==void 0?n.alpha:!1;let h=null,d=null;const p=[],v=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=bs,this.physicallyCorrectLights=!1,this.toneMapping=Ar,this.toneMappingExposure=1;const m=this;let f=!1,g=0,_=0,M=null,E=-1,S=null;const T=new ut,R=new ut;let x=null,A=e.width,I=e.height,N=1,J=null,q=null;const L=new ut(0,0,A,I),$=new ut(0,0,A,I);let z=!1;const W=new qd;let U=!1,P=!1,k=null;const Y=new Ve,j=new fe,K=new B,ce={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function de(){return M===null?N:1}let F=t;function We(w,D){for(let H=0;H<w.length;H++){const O=w[H],X=e.getContext(O,D);if(X!==null)return X}return null}try{const w={alpha:!0,depth:i,stencil:r,antialias:s,premultipliedAlpha:o,preserveDrawingBuffer:a,powerPreference:l,failIfMajorPerformanceCaveat:c};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${s0}`),e.addEventListener("webglcontextlost",C,!1),e.addEventListener("webglcontextrestored",ie,!1),F===null){const D=["webgl2","webgl","experimental-webgl"];if(m.isWebGL1Renderer===!0&&D.shift(),F=We(D,w),F===null)throw We(D)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}F.getShaderPrecisionFormat===void 0&&(F.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(w){throw console.error("THREE.WebGLRenderer: "+w.message),w}let Me,Ce,re,ze,oe,ne,pe,De,Se,$e,Oe,Te,et,qe,b,y,G,Z,ae,le,me,V,Ae;function Ie(){Me=new f2(F),Ce=new a2(F,Me,n),Me.init(Ce),V=new XL(F,Me,Ce),re=new WL(F,Me,Ce),ze=new g2(F),oe=new IL,ne=new $L(F,Me,re,oe,Ce,V,ze),pe=new c2(m),De=new d2(m),Se=new LA(F,Ce),Ae=new s2(F,Me,Se,Ce),$e=new p2(F,Se,ze,Ae),Oe=new y2(F,$e,Se,ze),ae=new x2(F,Ce,ne),y=new l2(oe),Te=new DL(m,pe,De,Me,Ce,Ae,y),et=new YL(m,oe),qe=new FL,b=new HL(Me,Ce),Z=new r2(m,pe,re,Oe,u,o),G=new WS(m,Oe,Ce),le=new o2(F,Me,ze,Ce),me=new m2(F,Me,ze,Ce),ze.programs=Te.programs,m.capabilities=Ce,m.extensions=Me,m.properties=oe,m.renderLists=qe,m.shadowMap=G,m.state=re,m.info=ze}Ie();const he=new qL(m,F);this.xr=he,this.getContext=function(){return F},this.getContextAttributes=function(){return F.getContextAttributes()},this.forceContextLoss=function(){const w=Me.get("WEBGL_lose_context");w&&w.loseContext()},this.forceContextRestore=function(){const w=Me.get("WEBGL_lose_context");w&&w.restoreContext()},this.getPixelRatio=function(){return N},this.setPixelRatio=function(w){w!==void 0&&(N=w,this.setSize(A,I,!1))},this.getSize=function(w){return w.set(A,I)},this.setSize=function(w,D,H){if(he.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}A=w,I=D,e.width=Math.floor(w*N),e.height=Math.floor(D*N),H!==!1&&(e.style.width=w+"px",e.style.height=D+"px"),this.setViewport(0,0,w,D)},this.getDrawingBufferSize=function(w){return w.set(A*N,I*N).floor()},this.setDrawingBufferSize=function(w,D,H){A=w,I=D,N=H,e.width=Math.floor(w*H),e.height=Math.floor(D*H),this.setViewport(0,0,w,D)},this.getCurrentViewport=function(w){return w.copy(T)},this.getViewport=function(w){return w.copy(L)},this.setViewport=function(w,D,H,O){w.isVector4?L.set(w.x,w.y,w.z,w.w):L.set(w,D,H,O),re.viewport(T.copy(L).multiplyScalar(N).floor())},this.getScissor=function(w){return w.copy($)},this.setScissor=function(w,D,H,O){w.isVector4?$.set(w.x,w.y,w.z,w.w):$.set(w,D,H,O),re.scissor(R.copy($).multiplyScalar(N).floor())},this.getScissorTest=function(){return z},this.setScissorTest=function(w){re.setScissorTest(z=w)},this.setOpaqueSort=function(w){J=w},this.setTransparentSort=function(w){q=w},this.getClearColor=function(w){return w.copy(Z.getClearColor())},this.setClearColor=function(){Z.setClearColor.apply(Z,arguments)},this.getClearAlpha=function(){return Z.getClearAlpha()},this.setClearAlpha=function(){Z.setClearAlpha.apply(Z,arguments)},this.clear=function(w=!0,D=!0,H=!0){let O=0;w&&(O|=16384),D&&(O|=256),H&&(O|=1024),F.clear(O)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",C,!1),e.removeEventListener("webglcontextrestored",ie,!1),qe.dispose(),b.dispose(),oe.dispose(),pe.dispose(),De.dispose(),Oe.dispose(),Ae.dispose(),Te.dispose(),he.dispose(),he.removeEventListener("sessionstart",xe),he.removeEventListener("sessionend",He),k&&(k.dispose(),k=null),Ne.stop()};function C(w){w.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),f=!0}function ie(){console.log("THREE.WebGLRenderer: Context Restored."),f=!1;const w=ze.autoReset,D=G.enabled,H=G.autoUpdate,O=G.needsUpdate,X=G.type;Ie(),ze.autoReset=w,G.enabled=D,G.autoUpdate=H,G.needsUpdate=O,G.type=X}function te(w){const D=w.target;D.removeEventListener("dispose",te),_e(D)}function _e(w){ue(w),oe.remove(w)}function ue(w){const D=oe.get(w).programs;D!==void 0&&(D.forEach(function(H){Te.releaseProgram(H)}),w.isShaderMaterial&&Te.releaseShaderCache(w))}this.renderBufferDirect=function(w,D,H,O,X,ye){D===null&&(D=ce);const Ee=X.isMesh&&X.matrixWorld.determinant()<0,Re=Pf(w,D,H,O,X);re.setMaterial(O,Ee);let be=H.index;const Ge=H.attributes.position;if(be===null){if(Ge===void 0||Ge.count===0)return}else if(be.count===0)return;let Fe=1;O.wireframe===!0&&(be=$e.getWireframeAttribute(H),Fe=2),Ae.setup(X,O,Re,H,be);let Be,Xe=le;be!==null&&(Be=Se.get(be),Xe=me,Xe.setIndex(Be));const Sn=be!==null?be.count:Ge.count,Hn=H.drawRange.start*Fe,Gn=H.drawRange.count*Fe,Dt=ye!==null?ye.start*Fe:0,ke=ye!==null?ye.count*Fe:1/0,Vn=Math.max(Hn,Dt),je=Math.min(Sn,Hn+Gn,Dt+ke)-1,It=Math.max(0,je-Vn+1);if(It!==0){if(X.isMesh)O.wireframe===!0?(re.setLineWidth(O.wireframeLinewidth*de()),Xe.setMode(1)):Xe.setMode(4);else if(X.isLine){let Qt=O.linewidth;Qt===void 0&&(Qt=1),re.setLineWidth(Qt*de()),X.isLineSegments?Xe.setMode(1):X.isLineLoop?Xe.setMode(2):Xe.setMode(3)}else X.isPoints?Xe.setMode(0):X.isSprite&&Xe.setMode(4);if(X.isInstancedMesh)Xe.renderInstances(Vn,It,X.count);else if(H.isInstancedBufferGeometry){const Qt=Math.min(H.instanceCount,H._maxInstanceCount);Xe.renderInstances(Vn,It,Qt)}else Xe.render(Vn,It)}},this.compile=function(w,D){d=b.get(w),d.init(),v.push(d),w.traverseVisible(function(H){H.isLight&&H.layers.test(D.layers)&&(d.pushLight(H),H.castShadow&&d.pushShadow(H))}),d.setupLights(m.physicallyCorrectLights),w.traverse(function(H){const O=H.material;if(O)if(Array.isArray(O))for(let X=0;X<O.length;X++){const ye=O[X];Os(ye,w,H)}else Os(O,w,H)}),v.pop(),d=null};let ge=null;function ee(w){ge&&ge(w)}function xe(){Ne.stop()}function He(){Ne.start()}const Ne=new OS;Ne.setAnimationLoop(ee),typeof self!="undefined"&&Ne.setContext(self),this.setAnimationLoop=function(w){ge=w,he.setAnimationLoop(w),w===null?Ne.stop():Ne.start()},he.addEventListener("sessionstart",xe),he.addEventListener("sessionend",He),this.render=function(w,D){if(D!==void 0&&D.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(f===!0)return;w.autoUpdate===!0&&w.updateMatrixWorld(),D.parent===null&&D.updateMatrixWorld(),he.enabled===!0&&he.isPresenting===!0&&(he.cameraAutoUpdate===!0&&he.updateCamera(D),D=he.getCamera()),w.isScene===!0&&w.onBeforeRender(m,w,D,M),d=b.get(w,v.length),d.init(),v.push(d),Y.multiplyMatrices(D.projectionMatrix,D.matrixWorldInverse),W.setFromProjectionMatrix(Y),P=this.localClippingEnabled,U=y.init(this.clippingPlanes,P,D),h=qe.get(w,p.length),h.init(),p.push(h),Lt(w,D,0,m.sortObjects),h.finish(),m.sortObjects===!0&&h.sort(J,q),U===!0&&y.beginShadows();const H=d.state.shadowsArray;if(G.render(H,w,D),U===!0&&y.endShadows(),this.info.autoReset===!0&&this.info.reset(),Z.render(h,w),d.setupLights(m.physicallyCorrectLights),D.isArrayCamera){const O=D.cameras;for(let X=0,ye=O.length;X<ye;X++){const Ee=O[X];Pt(h,w,Ee,Ee.viewport)}}else Pt(h,w,D);M!==null&&(ne.updateMultisampleRenderTarget(M),ne.updateRenderTargetMipmap(M)),w.isScene===!0&&w.onAfterRender(m,w,D),Ae.resetDefaultState(),E=-1,S=null,v.pop(),v.length>0?d=v[v.length-1]:d=null,p.pop(),p.length>0?h=p[p.length-1]:h=null};function Lt(w,D,H,O){if(w.visible===!1)return;if(w.layers.test(D.layers)){if(w.isGroup)H=w.renderOrder;else if(w.isLOD)w.autoUpdate===!0&&w.update(D);else if(w.isLight)d.pushLight(w),w.castShadow&&d.pushShadow(w);else if(w.isSprite){if(!w.frustumCulled||W.intersectsSprite(w)){O&&K.setFromMatrixPosition(w.matrixWorld).applyMatrix4(Y);const Ee=Oe.update(w),Re=w.material;Re.visible&&h.push(w,Ee,Re,H,K.z,null)}}else if((w.isMesh||w.isLine||w.isPoints)&&(w.isSkinnedMesh&&w.skeleton.frame!==ze.render.frame&&(w.skeleton.update(),w.skeleton.frame=ze.render.frame),!w.frustumCulled||W.intersectsObject(w))){O&&K.setFromMatrixPosition(w.matrixWorld).applyMatrix4(Y);const Ee=Oe.update(w),Re=w.material;if(Array.isArray(Re)){const be=Ee.groups;for(let Ge=0,Fe=be.length;Ge<Fe;Ge++){const Be=be[Ge],Xe=Re[Be.materialIndex];Xe&&Xe.visible&&h.push(w,Ee,Xe,H,K.z,Be)}}else Re.visible&&h.push(w,Ee,Re,H,K.z,null)}}const ye=w.children;for(let Ee=0,Re=ye.length;Ee<Re;Ee++)Lt(ye[Ee],D,H,O)}function Pt(w,D,H,O){const X=w.opaque,ye=w.transmissive,Ee=w.transparent;d.setupLightsView(H),ye.length>0&&Rf(X,D,H),O&&re.viewport(T.copy(O)),X.length>0&&ir(X,D,H),ye.length>0&&ir(ye,D,H),Ee.length>0&&ir(Ee,D,H),re.buffers.depth.setTest(!0),re.buffers.depth.setMask(!0),re.buffers.color.setMask(!0),re.setPolygonOffset(!1)}function Rf(w,D,H){const O=Ce.isWebGL2;k===null&&(k=new on(1,1,{generateMipmaps:!0,type:Me.has("EXT_color_buffer_half_float")?Fc:mo,minFilter:_l,samples:O&&s===!0?4:0})),m.getDrawingBufferSize(j),O?k.setSize(j.x,j.y):k.setSize(pd(j.x),pd(j.y));const X=m.getRenderTarget();m.setRenderTarget(k),m.clear();const ye=m.toneMapping;m.toneMapping=Ar,ir(w,D,H),m.toneMapping=ye,ne.updateMultisampleRenderTarget(k),ne.updateRenderTargetMipmap(k),m.setRenderTarget(X)}function ir(w,D,H){const O=D.isScene===!0?D.overrideMaterial:null;for(let X=0,ye=w.length;X<ye;X++){const Ee=w[X],Re=Ee.object,be=Ee.geometry,Ge=O===null?Ee.material:O,Fe=Ee.group;Re.layers.test(H.layers)&&Lf(Re,D,H,be,Ge,Fe)}}function Lf(w,D,H,O,X,ye){w.onBeforeRender(m,D,H,O,X,ye),w.modelViewMatrix.multiplyMatrices(H.matrixWorldInverse,w.matrixWorld),w.normalMatrix.getNormalMatrix(w.modelViewMatrix),X.onBeforeRender(m,D,H,O,w,ye),X.transparent===!0&&X.side===po?(X.side=Bi,X.needsUpdate=!0,m.renderBufferDirect(H,D,O,X,w,ye),X.side=Xa,X.needsUpdate=!0,m.renderBufferDirect(H,D,O,X,w,ye),X.side=po):m.renderBufferDirect(H,D,O,X,w,ye),w.onAfterRender(m,D,H,O,X,ye)}function Os(w,D,H){D.isScene!==!0&&(D=ce);const O=oe.get(w),X=d.state.lights,ye=d.state.shadowsArray,Ee=X.state.version,Re=Te.getParameters(w,X.state,ye,D,H),be=Te.getProgramCacheKey(Re);let Ge=O.programs;O.environment=w.isMeshStandardMaterial?D.environment:null,O.fog=D.fog,O.envMap=(w.isMeshStandardMaterial?De:pe).get(w.envMap||O.environment),Ge===void 0&&(w.addEventListener("dispose",te),Ge=new Map,O.programs=Ge);let Fe=Ge.get(be);if(Fe!==void 0){if(O.currentProgram===Fe&&O.lightsStateVersion===Ee)return Ol(w,Re),Fe}else Re.uniforms=Te.getUniforms(w),w.onBuild(H,Re,m),w.onBeforeCompile(Re,m),Fe=Te.acquireProgram(Re,be),Ge.set(be,Fe),O.uniforms=Re.uniforms;const Be=O.uniforms;(!w.isShaderMaterial&&!w.isRawShaderMaterial||w.clipping===!0)&&(Be.clippingPlanes=y.uniform),Ol(w,Re),O.needsLights=If(w),O.lightsStateVersion=Ee,O.needsLights&&(Be.ambientLightColor.value=X.state.ambient,Be.lightProbe.value=X.state.probe,Be.directionalLights.value=X.state.directional,Be.directionalLightShadows.value=X.state.directionalShadow,Be.spotLights.value=X.state.spot,Be.spotLightShadows.value=X.state.spotShadow,Be.rectAreaLights.value=X.state.rectArea,Be.ltc_1.value=X.state.rectAreaLTC1,Be.ltc_2.value=X.state.rectAreaLTC2,Be.pointLights.value=X.state.point,Be.pointLightShadows.value=X.state.pointShadow,Be.hemisphereLights.value=X.state.hemi,Be.directionalShadowMap.value=X.state.directionalShadowMap,Be.directionalShadowMatrix.value=X.state.directionalShadowMatrix,Be.spotShadowMap.value=X.state.spotShadowMap,Be.spotShadowMatrix.value=X.state.spotShadowMatrix,Be.pointShadowMap.value=X.state.pointShadowMap,Be.pointShadowMatrix.value=X.state.pointShadowMatrix);const Xe=Fe.getUniforms(),Sn=ds.seqWithValue(Xe.seq,Be);return O.currentProgram=Fe,O.uniformsList=Sn,Fe}function Ol(w,D){const H=oe.get(w);H.outputEncoding=D.outputEncoding,H.instancing=D.instancing,H.skinning=D.skinning,H.morphTargets=D.morphTargets,H.morphNormals=D.morphNormals,H.morphColors=D.morphColors,H.morphTargetsCount=D.morphTargetsCount,H.numClippingPlanes=D.numClippingPlanes,H.numIntersection=D.numClipIntersection,H.vertexAlphas=D.vertexAlphas,H.vertexTangents=D.vertexTangents,H.toneMapping=D.toneMapping}function Pf(w,D,H,O,X){D.isScene!==!0&&(D=ce),ne.resetTextureUnits();const ye=D.fog,Ee=O.isMeshStandardMaterial?D.environment:null,Re=M===null?m.outputEncoding:M.isXRRenderTarget===!0?M.texture.encoding:bs,be=(O.isMeshStandardMaterial?De:pe).get(O.envMap||Ee),Ge=O.vertexColors===!0&&!!H.attributes.color&&H.attributes.color.itemSize===4,Fe=!!O.normalMap&&!!H.attributes.tangent,Be=!!H.morphAttributes.position,Xe=!!H.morphAttributes.normal,Sn=!!H.morphAttributes.color,Hn=O.toneMapped?m.toneMapping:Ar,Gn=H.morphAttributes.position||H.morphAttributes.normal||H.morphAttributes.color,Dt=Gn!==void 0?Gn.length:0,ke=oe.get(O),Vn=d.state.lights;if(U===!0&&(P===!0||w!==S)){const Nt=w===S&&O.id===E;y.setState(O,w,Nt)}let je=!1;O.version===ke.__version?(ke.needsLights&&ke.lightsStateVersion!==Vn.state.version||ke.outputEncoding!==Re||X.isInstancedMesh&&ke.instancing===!1||!X.isInstancedMesh&&ke.instancing===!0||X.isSkinnedMesh&&ke.skinning===!1||!X.isSkinnedMesh&&ke.skinning===!0||ke.envMap!==be||O.fog===!0&&ke.fog!==ye||ke.numClippingPlanes!==void 0&&(ke.numClippingPlanes!==y.numPlanes||ke.numIntersection!==y.numIntersection)||ke.vertexAlphas!==Ge||ke.vertexTangents!==Fe||ke.morphTargets!==Be||ke.morphNormals!==Xe||ke.morphColors!==Sn||ke.toneMapping!==Hn||Ce.isWebGL2===!0&&ke.morphTargetsCount!==Dt)&&(je=!0):(je=!0,ke.__version=O.version);let It=ke.currentProgram;je===!0&&(It=Os(O,D,X));let Qt=!1,xi=!1,Bs=!1;const nt=It.getUniforms(),yi=ke.uniforms;if(re.useProgram(It.program)&&(Qt=!0,xi=!0,Bs=!0),O.id!==E&&(E=O.id,xi=!0),Qt||S!==w){if(nt.setValue(F,"projectionMatrix",w.projectionMatrix),Ce.logarithmicDepthBuffer&&nt.setValue(F,"logDepthBufFC",2/(Math.log(w.far+1)/Math.LN2)),S!==w&&(S=w,xi=!0,Bs=!0),O.isShaderMaterial||O.isMeshPhongMaterial||O.isMeshToonMaterial||O.isMeshStandardMaterial||O.envMap){const Nt=nt.map.cameraPosition;Nt!==void 0&&Nt.setValue(F,K.setFromMatrixPosition(w.matrixWorld))}(O.isMeshPhongMaterial||O.isMeshToonMaterial||O.isMeshLambertMaterial||O.isMeshBasicMaterial||O.isMeshStandardMaterial||O.isShaderMaterial)&&nt.setValue(F,"isOrthographic",w.isOrthographicCamera===!0),(O.isMeshPhongMaterial||O.isMeshToonMaterial||O.isMeshLambertMaterial||O.isMeshBasicMaterial||O.isMeshStandardMaterial||O.isShaderMaterial||O.isShadowMaterial||X.isSkinnedMesh)&&nt.setValue(F,"viewMatrix",w.matrixWorldInverse)}if(X.isSkinnedMesh){nt.setOptional(F,X,"bindMatrix"),nt.setOptional(F,X,"bindMatrixInverse");const Nt=X.skeleton;Nt&&(Ce.floatVertexTextures?(Nt.boneTexture===null&&Nt.computeBoneTexture(),nt.setValue(F,"boneTexture",Nt.boneTexture,ne),nt.setValue(F,"boneTextureSize",Nt.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const zs=H.morphAttributes;return(zs.position!==void 0||zs.normal!==void 0||zs.color!==void 0&&Ce.isWebGL2===!0)&&ae.update(X,H,O,It),(xi||ke.receiveShadow!==X.receiveShadow)&&(ke.receiveShadow=X.receiveShadow,nt.setValue(F,"receiveShadow",X.receiveShadow)),xi&&(nt.setValue(F,"toneMappingExposure",m.toneMappingExposure),ke.needsLights&&Df(yi,Bs),ye&&O.fog===!0&&et.refreshFogUniforms(yi,ye),et.refreshMaterialUniforms(yi,O,N,I,k),ds.upload(F,ke.uniformsList,yi,ne)),O.isShaderMaterial&&O.uniformsNeedUpdate===!0&&(ds.upload(F,ke.uniformsList,yi,ne),O.uniformsNeedUpdate=!1),O.isSpriteMaterial&&nt.setValue(F,"center",X.center),nt.setValue(F,"modelViewMatrix",X.modelViewMatrix),nt.setValue(F,"normalMatrix",X.normalMatrix),nt.setValue(F,"modelMatrix",X.matrixWorld),It}function Df(w,D){w.ambientLightColor.needsUpdate=D,w.lightProbe.needsUpdate=D,w.directionalLights.needsUpdate=D,w.directionalLightShadows.needsUpdate=D,w.pointLights.needsUpdate=D,w.pointLightShadows.needsUpdate=D,w.spotLights.needsUpdate=D,w.spotLightShadows.needsUpdate=D,w.rectAreaLights.needsUpdate=D,w.hemisphereLights.needsUpdate=D}function If(w){return w.isMeshLambertMaterial||w.isMeshToonMaterial||w.isMeshPhongMaterial||w.isMeshStandardMaterial||w.isShadowMaterial||w.isShaderMaterial&&w.lights===!0}this.getActiveCubeFace=function(){return g},this.getActiveMipmapLevel=function(){return _},this.getRenderTarget=function(){return M},this.setRenderTargetTextures=function(w,D,H){oe.get(w.texture).__webglTexture=D,oe.get(w.depthTexture).__webglTexture=H;const O=oe.get(w);O.__hasExternalTextures=!0,O.__hasExternalTextures&&(O.__autoAllocateDepthBuffer=H===void 0,O.__autoAllocateDepthBuffer||Me.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),O.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(w,D){const H=oe.get(w);H.__webglFramebuffer=D,H.__useDefaultFramebuffer=D===void 0},this.setRenderTarget=function(w,D=0,H=0){M=w,g=D,_=H;let O=!0;if(w){const be=oe.get(w);be.__useDefaultFramebuffer!==void 0?(re.bindFramebuffer(36160,null),O=!1):be.__webglFramebuffer===void 0?ne.setupRenderTarget(w):be.__hasExternalTextures&&ne.rebindTextures(w,oe.get(w.texture).__webglTexture,oe.get(w.depthTexture).__webglTexture)}let X=null,ye=!1,Ee=!1;if(w){const be=w.texture;(be.isData3DTexture||be.isDataArrayTexture)&&(Ee=!0);const Ge=oe.get(w).__webglFramebuffer;w.isWebGLCubeRenderTarget?(X=Ge[D],ye=!0):Ce.isWebGL2&&w.samples>0&&ne.useMultisampledRTT(w)===!1?X=oe.get(w).__webglMultisampledFramebuffer:X=Ge,T.copy(w.viewport),R.copy(w.scissor),x=w.scissorTest}else T.copy(L).multiplyScalar(N).floor(),R.copy($).multiplyScalar(N).floor(),x=z;if(re.bindFramebuffer(36160,X)&&Ce.drawBuffers&&O&&re.drawBuffers(w,X),re.viewport(T),re.scissor(R),re.setScissorTest(x),ye){const be=oe.get(w.texture);F.framebufferTexture2D(36160,36064,34069+D,be.__webglTexture,H)}else if(Ee){const be=oe.get(w.texture),Ge=D||0;F.framebufferTextureLayer(36160,36064,be.__webglTexture,H||0,Ge)}E=-1},this.readRenderTargetPixels=function(w,D,H,O,X,ye,Ee){if(!(w&&w.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Re=oe.get(w).__webglFramebuffer;if(w.isWebGLCubeRenderTarget&&Ee!==void 0&&(Re=Re[Ee]),Re){re.bindFramebuffer(36160,Re);try{const be=w.texture,Ge=be.format,Fe=be.type;if(Ge!==ui&&V.convert(Ge)!==F.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Be=Fe===Fc&&(Me.has("EXT_color_buffer_half_float")||Ce.isWebGL2&&Me.has("EXT_color_buffer_float"));if(Fe!==mo&&V.convert(Fe)!==F.getParameter(35738)&&!(Fe===ls&&(Ce.isWebGL2||Me.has("OES_texture_float")||Me.has("WEBGL_color_buffer_float")))&&!Be){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}D>=0&&D<=w.width-O&&H>=0&&H<=w.height-X&&F.readPixels(D,H,O,X,V.convert(Ge),V.convert(Fe),ye)}finally{const be=M!==null?oe.get(M).__webglFramebuffer:null;re.bindFramebuffer(36160,be)}}},this.copyFramebufferToTexture=function(w,D,H=0){if(D.isFramebufferTexture!==!0){console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");return}const O=Math.pow(2,-H),X=Math.floor(D.image.width*O),ye=Math.floor(D.image.height*O);ne.setTexture2D(D,0),F.copyTexSubImage2D(3553,H,0,0,w.x,w.y,X,ye),re.unbindTexture()},this.copyTextureToTexture=function(w,D,H,O=0){const X=D.image.width,ye=D.image.height,Ee=V.convert(H.format),Re=V.convert(H.type);ne.setTexture2D(H,0),F.pixelStorei(37440,H.flipY),F.pixelStorei(37441,H.premultiplyAlpha),F.pixelStorei(3317,H.unpackAlignment),D.isDataTexture?F.texSubImage2D(3553,O,w.x,w.y,X,ye,Ee,Re,D.image.data):D.isCompressedTexture?F.compressedTexSubImage2D(3553,O,w.x,w.y,D.mipmaps[0].width,D.mipmaps[0].height,Ee,D.mipmaps[0].data):F.texSubImage2D(3553,O,w.x,w.y,Ee,Re,D.image),O===0&&H.generateMipmaps&&F.generateMipmap(3553),re.unbindTexture()},this.copyTextureToTexture3D=function(w,D,H,O,X=0){if(m.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const ye=w.max.x-w.min.x+1,Ee=w.max.y-w.min.y+1,Re=w.max.z-w.min.z+1,be=V.convert(O.format),Ge=V.convert(O.type);let Fe;if(O.isData3DTexture)ne.setTexture3D(O,0),Fe=32879;else if(O.isDataArrayTexture)ne.setTexture2DArray(O,0),Fe=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}F.pixelStorei(37440,O.flipY),F.pixelStorei(37441,O.premultiplyAlpha),F.pixelStorei(3317,O.unpackAlignment);const Be=F.getParameter(3314),Xe=F.getParameter(32878),Sn=F.getParameter(3316),Hn=F.getParameter(3315),Gn=F.getParameter(32877),Dt=H.isCompressedTexture?H.mipmaps[0]:H.image;F.pixelStorei(3314,Dt.width),F.pixelStorei(32878,Dt.height),F.pixelStorei(3316,w.min.x),F.pixelStorei(3315,w.min.y),F.pixelStorei(32877,w.min.z),H.isDataTexture||H.isData3DTexture?F.texSubImage3D(Fe,X,D.x,D.y,D.z,ye,Ee,Re,be,Ge,Dt.data):H.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),F.compressedTexSubImage3D(Fe,X,D.x,D.y,D.z,ye,Ee,Re,be,Dt.data)):F.texSubImage3D(Fe,X,D.x,D.y,D.z,ye,Ee,Re,be,Ge,Dt),F.pixelStorei(3314,Be),F.pixelStorei(32878,Xe),F.pixelStorei(3316,Sn),F.pixelStorei(3315,Hn),F.pixelStorei(32877,Gn),X===0&&O.generateMipmaps&&F.generateMipmap(Fe),re.unbindTexture()},this.initTexture=function(w){ne.setTexture2D(w,0),re.unbindTexture()},this.resetState=function(){g=0,_=0,M=null,re.reset(),Ae.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}ft.prototype.isWebGLRenderer=!0;class ZL extends ft{}ZL.prototype.isWebGL1Renderer=!0;class p0 extends at{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}p0.prototype.isScene=!0;class Sl{constructor(e,t){this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=Oc,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=di()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,i){e*=this.stride,i*=t.stride;for(let r=0,s=this.stride;r<s;r++)this.array[e+r]=t.array[i+r];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=di()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(t,this.stride);return i.setUsage(this.usage),i}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=di()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}Sl.prototype.isInterleavedBuffer=!0;const wn=new B;class Qa{constructor(e,t,i,r=!1){this.name="",this.data=e,this.itemSize=t,this.offset=i,this.normalized=r===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,i=this.data.count;t<i;t++)wn.fromBufferAttribute(this,t),wn.applyMatrix4(e),this.setXYZ(t,wn.x,wn.y,wn.z);return this}applyNormalMatrix(e){for(let t=0,i=this.count;t<i;t++)wn.fromBufferAttribute(this,t),wn.applyNormalMatrix(e),this.setXYZ(t,wn.x,wn.y,wn.z);return this}transformDirection(e){for(let t=0,i=this.count;t<i;t++)wn.fromBufferAttribute(this,t),wn.transformDirection(e),this.setXYZ(t,wn.x,wn.y,wn.z);return this}setX(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){return this.data.array[e*this.data.stride+this.offset]}getY(e){return this.data.array[e*this.data.stride+this.offset+1]}getZ(e){return this.data.array[e*this.data.stride+this.offset+2]}getW(e){return this.data.array[e*this.data.stride+this.offset+3]}setXY(e,t,i){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=i,this}setXYZ(e,t,i,r){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=i,this.data.array[e+2]=r,this}setXYZW(e,t,i,r,s){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=i,this.data.array[e+2]=r,this.data.array[e+3]=s,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let i=0;i<this.count;i++){const r=i*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[r+s])}return new Ut(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Qa(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let i=0;i<this.count;i++){const r=i*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[r+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}Qa.prototype.isInterleavedBufferAttribute=!0;class m0 extends Rt{constructor(e){super(),this.type="SpriteMaterial",this.color=new we(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}m0.prototype.isSpriteMaterial=!0;let jo;const Hl=new B,qo=new B,Yo=new B,Ko=new fe,Gl=new fe,jS=new Ve,Yu=new B,Vl=new B,Ku=new B,ex=new fe,dp=new fe,tx=new fe;class JL extends at{constructor(e){if(super(),this.type="Sprite",jo===void 0){jo=new lt;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),i=new Sl(t,5);jo.setIndex([0,1,2,0,2,3]),jo.setAttribute("position",new Qa(i,3,0,!1)),jo.setAttribute("uv",new Qa(i,2,3,!1))}this.geometry=jo,this.material=e!==void 0?e:new m0,this.center=new fe(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),qo.setFromMatrixScale(this.matrixWorld),jS.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Yo.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&qo.multiplyScalar(-Yo.z);const i=this.material.rotation;let r,s;i!==0&&(s=Math.cos(i),r=Math.sin(i));const o=this.center;Zu(Yu.set(-.5,-.5,0),Yo,o,qo,r,s),Zu(Vl.set(.5,-.5,0),Yo,o,qo,r,s),Zu(Ku.set(.5,.5,0),Yo,o,qo,r,s),ex.set(0,0),dp.set(1,0),tx.set(1,1);let a=e.ray.intersectTriangle(Yu,Vl,Ku,!1,Hl);if(a===null&&(Zu(Vl.set(-.5,.5,0),Yo,o,qo,r,s),dp.set(0,1),a=e.ray.intersectTriangle(Yu,Ku,Vl,!1,Hl),a===null))return;const l=e.ray.origin.distanceTo(Hl);l<e.near||l>e.far||t.push({distance:l,point:Hl.clone(),uv:zt.getUV(Hl,Yu,Vl,Ku,ex,dp,tx,new fe),face:null,object:this})}copy(e){return super.copy(e),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}JL.prototype.isSprite=!0;function Zu(n,e,t,i,r,s){Ko.subVectors(n,t).addScalar(.5).multiply(i),r!==void 0?(Gl.x=s*Ko.x-r*Ko.y,Gl.y=r*Ko.x+s*Ko.y):Gl.copy(Ko),n.copy(e),n.x+=Gl.x,n.y+=Gl.y,n.applyMatrix4(jS)}const nx=new B,ix=new ut,rx=new ut,QL=new B,sx=new Ve;class g0 extends dt{constructor(e,t){super(e,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Ve,this.bindMatrixInverse=new Ve}copy(e){return super.copy(e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new ut,t=this.geometry.attributes.skinWeight;for(let i=0,r=t.count;i<r;i++){e.fromBufferAttribute(t,i);const s=1/e.manhattanLength();s!==1/0?e.multiplyScalar(s):e.set(1,0,0,0),t.setXYZW(i,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const i=this.skeleton,r=this.geometry;ix.fromBufferAttribute(r.attributes.skinIndex,e),rx.fromBufferAttribute(r.attributes.skinWeight,e),nx.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let s=0;s<4;s++){const o=rx.getComponent(s);if(o!==0){const a=ix.getComponent(s);sx.multiplyMatrices(i.bones[a].matrixWorld,i.boneInverses[a]),t.addScaledVector(QL.copy(nx).applyMatrix4(sx),o)}}return t.applyMatrix4(this.bindMatrixInverse)}}g0.prototype.isSkinnedMesh=!0;class v0 extends at{constructor(){super(),this.type="Bone"}}v0.prototype.isBone=!0;class qS extends Ht{constructor(e=null,t=1,i=1,r,s,o,a,l,c=$t,u=$t,h,d){super(null,o,a,l,c,u,r,s,h,d),this.image={data:e,width:t,height:i},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}qS.prototype.isDataTexture=!0;const ox=new Ve,eP=new Ve;class _0{constructor(e=[],t=[]){this.uuid=di(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let i=0,r=this.bones.length;i<r;i++)this.boneInverses.push(new Ve)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const i=new Ve;this.bones[e]&&i.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(i)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const i=this.bones[e];i&&i.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const i=this.bones[e];i&&(i.parent&&i.parent.isBone?(i.matrix.copy(i.parent.matrixWorld).invert(),i.matrix.multiply(i.matrixWorld)):i.matrix.copy(i.matrixWorld),i.matrix.decompose(i.position,i.quaternion,i.scale))}}update(){const e=this.bones,t=this.boneInverses,i=this.boneMatrices,r=this.boneTexture;for(let s=0,o=e.length;s<o;s++){const a=e[s]?e[s].matrixWorld:eP;ox.multiplyMatrices(a,t[s]),ox.toArray(i,s*16)}r!==null&&(r.needsUpdate=!0)}clone(){return new _0(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=RS(e),e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const i=new qS(t,e,e,ui,ls);return i.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=i,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,i=this.bones.length;t<i;t++){const r=this.bones[t];if(r.name===e)return r}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let i=0,r=e.bones.length;i<r;i++){const s=e.bones[i];let o=t[s];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",s),o=new v0),this.bones.push(o),this.boneInverses.push(new Ve().fromArray(e.boneInverses[i]))}return this.init(),this}toJSON(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,i=this.boneInverses;for(let r=0,s=t.length;r<s;r++){const o=t[r];e.bones.push(o.uuid);const a=i[r];e.boneInverses.push(a.toArray())}return e}}class Xm extends Ut{constructor(e,t,i,r=1){typeof i=="number"&&(r=i,i=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(e,t,i),this.meshPerAttribute=r}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}Xm.prototype.isInstancedBufferAttribute=!0;const ax=new Ve,lx=new Ve,Ju=[],Wl=new dt;class tP extends dt{constructor(e,t,i){super(e,t),this.instanceMatrix=new Xm(new Float32Array(i*16),16),this.instanceColor=null,this.count=i,this.frustumCulled=!1}copy(e){return super.copy(e),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const i=this.matrixWorld,r=this.count;if(Wl.geometry=this.geometry,Wl.material=this.material,Wl.material!==void 0)for(let s=0;s<r;s++){this.getMatrixAt(s,ax),lx.multiplyMatrices(i,ax),Wl.matrixWorld=lx,Wl.raycast(e,Ju);for(let o=0,a=Ju.length;o<a;o++){const l=Ju[o];l.instanceId=s,l.object=this,t.push(l)}Ju.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new Xm(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}tP.prototype.isInstancedMesh=!0;class Ro extends Rt{constructor(e){super(),this.type="LineBasicMaterial",this.color=new we(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}Ro.prototype.isLineBasicMaterial=!0;const cx=new B,ux=new B,hx=new Ve,fp=new xl,Qu=new Gi;class Zd extends at{constructor(e=new lt,t=new Ro){super(),this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,i=[0];for(let r=1,s=t.count;r<s;r++)cx.fromBufferAttribute(t,r-1),ux.fromBufferAttribute(t,r),i[r]=i[r-1],i[r]+=cx.distanceTo(ux);e.setAttribute("lineDistance",new rt(i,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(e,t){const i=this.geometry,r=this.matrixWorld,s=e.params.Line.threshold,o=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),Qu.copy(i.boundingSphere),Qu.applyMatrix4(r),Qu.radius+=s,e.ray.intersectsSphere(Qu)===!1)return;hx.copy(r).invert(),fp.copy(e.ray).applyMatrix4(hx);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=new B,u=new B,h=new B,d=new B,p=this.isLineSegments?2:1;if(i.isBufferGeometry){const v=i.index,f=i.attributes.position;if(v!==null){const g=Math.max(0,o.start),_=Math.min(v.count,o.start+o.count);for(let M=g,E=_-1;M<E;M+=p){const S=v.getX(M),T=v.getX(M+1);if(c.fromBufferAttribute(f,S),u.fromBufferAttribute(f,T),fp.distanceSqToSegment(c,u,d,h)>l)continue;d.applyMatrix4(this.matrixWorld);const x=e.ray.origin.distanceTo(d);x<e.near||x>e.far||t.push({distance:x,point:h.clone().applyMatrix4(this.matrixWorld),index:M,face:null,faceIndex:null,object:this})}}else{const g=Math.max(0,o.start),_=Math.min(f.count,o.start+o.count);for(let M=g,E=_-1;M<E;M+=p){if(c.fromBufferAttribute(f,M),u.fromBufferAttribute(f,M+1),fp.distanceSqToSegment(c,u,d,h)>l)continue;d.applyMatrix4(this.matrixWorld);const T=e.ray.origin.distanceTo(d);T<e.near||T>e.far||t.push({distance:T,point:h.clone().applyMatrix4(this.matrixWorld),index:M,face:null,faceIndex:null,object:this})}}}else i.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,i=Object.keys(t);if(i.length>0){const r=t[i[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=r.length;s<o;s++){const a=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Zd.prototype.isLine=!0;const dx=new B,fx=new B;class Jd extends Zd{constructor(e,t){super(e,t),this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,i=[];for(let r=0,s=t.count;r<s;r+=2)dx.fromBufferAttribute(t,r),fx.fromBufferAttribute(t,r+1),i[r]=r===0?0:i[r-1],i[r+1]=i[r]+dx.distanceTo(fx);e.setAttribute("lineDistance",new rt(i,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}Jd.prototype.isLineSegments=!0;class YS extends Zd{constructor(e,t){super(e,t),this.type="LineLoop"}}YS.prototype.isLineLoop=!0;class Qd extends Rt{constructor(e){super(),this.type="PointsMaterial",this.color=new we(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}Qd.prototype.isPointsMaterial=!0;const px=new Ve,jm=new xl,eh=new Gi,th=new B;class KS extends at{constructor(e=new lt,t=new Qd){super(),this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const i=this.geometry,r=this.matrixWorld,s=e.params.Points.threshold,o=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),eh.copy(i.boundingSphere),eh.applyMatrix4(r),eh.radius+=s,e.ray.intersectsSphere(eh)===!1)return;px.copy(r).invert(),jm.copy(e.ray).applyMatrix4(px);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a;if(i.isBufferGeometry){const c=i.index,h=i.attributes.position;if(c!==null){const d=Math.max(0,o.start),p=Math.min(c.count,o.start+o.count);for(let v=d,m=p;v<m;v++){const f=c.getX(v);th.fromBufferAttribute(h,f),mx(th,f,l,r,e,t,this)}}else{const d=Math.max(0,o.start),p=Math.min(h.count,o.start+o.count);for(let v=d,m=p;v<m;v++)th.fromBufferAttribute(h,v),mx(th,v,l,r,e,t,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,i=Object.keys(t);if(i.length>0){const r=t[i[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=r.length;s<o;s++){const a=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}KS.prototype.isPoints=!0;function mx(n,e,t,i,r,s,o){const a=jm.distanceSqToPoint(n);if(a<t){const l=new B;jm.closestPointToPoint(n,l),l.applyMatrix4(i);const c=r.ray.origin.distanceTo(l);if(c<r.near||c>r.far)return;s.push({distance:c,distanceToRay:Math.sqrt(a),point:l,index:e,face:null,object:o})}}class nP extends Ht{constructor(e,t,i,r,s,o,a,l,c){super(e,t,i,r,s,o,a,l,c),this.minFilter=o!==void 0?o:mn,this.magFilter=s!==void 0?s:mn,this.generateMipmaps=!1;const u=this;function h(){u.needsUpdate=!0,e.requestVideoFrameCallback(h)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(h)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}nP.prototype.isVideoTexture=!0;class iP extends Ht{constructor(e,t,i){super({width:e,height:t}),this.format=i,this.magFilter=$t,this.minFilter=$t,this.generateMipmaps=!1,this.needsUpdate=!0}}iP.prototype.isFramebufferTexture=!0;class rP extends Ht{constructor(e,t,i,r,s,o,a,l,c,u,h,d){super(null,o,a,l,c,u,r,s,h,d),this.image={width:t,height:i},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}rP.prototype.isCompressedTexture=!0;class sP extends Ht{constructor(e,t,i,r,s,o,a,l,c){super(e,t,i,r,s,o,a,l,c),this.needsUpdate=!0}}sP.prototype.isCanvasTexture=!0;class mi{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const i=this.getUtoTmapping(e);return this.getPoint(i,t)}getPoints(e=5){const t=[];for(let i=0;i<=e;i++)t.push(this.getPoint(i/e));return t}getSpacedPoints(e=5){const t=[];for(let i=0;i<=e;i++)t.push(this.getPointAt(i/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let i,r=this.getPoint(0),s=0;t.push(0);for(let o=1;o<=e;o++)i=this.getPoint(o/e),s+=i.distanceTo(r),t.push(s),r=i;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const i=this.getLengths();let r=0;const s=i.length;let o;t?o=t:o=e*i[s-1];let a=0,l=s-1,c;for(;a<=l;)if(r=Math.floor(a+(l-a)/2),c=i[r]-o,c<0)a=r+1;else if(c>0)l=r-1;else{l=r;break}if(r=l,i[r]===o)return r/(s-1);const u=i[r],d=i[r+1]-u,p=(o-u)/d;return(r+p)/(s-1)}getTangent(e,t){let r=e-1e-4,s=e+1e-4;r<0&&(r=0),s>1&&(s=1);const o=this.getPoint(r),a=this.getPoint(s),l=t||(o.isVector2?new fe:new B);return l.copy(a).sub(o).normalize(),l}getTangentAt(e,t){const i=this.getUtoTmapping(e);return this.getTangent(i,t)}computeFrenetFrames(e,t){const i=new B,r=[],s=[],o=[],a=new B,l=new Ve;for(let p=0;p<=e;p++){const v=p/e;r[p]=this.getTangentAt(v,new B)}s[0]=new B,o[0]=new B;let c=Number.MAX_VALUE;const u=Math.abs(r[0].x),h=Math.abs(r[0].y),d=Math.abs(r[0].z);u<=c&&(c=u,i.set(1,0,0)),h<=c&&(c=h,i.set(0,1,0)),d<=c&&i.set(0,0,1),a.crossVectors(r[0],i).normalize(),s[0].crossVectors(r[0],a),o[0].crossVectors(r[0],s[0]);for(let p=1;p<=e;p++){if(s[p]=s[p-1].clone(),o[p]=o[p-1].clone(),a.crossVectors(r[p-1],r[p]),a.length()>Number.EPSILON){a.normalize();const v=Math.acos(rn(r[p-1].dot(r[p]),-1,1));s[p].applyMatrix4(l.makeRotationAxis(a,v))}o[p].crossVectors(r[p],s[p])}if(t===!0){let p=Math.acos(rn(s[0].dot(s[e]),-1,1));p/=e,r[0].dot(a.crossVectors(s[0],s[e]))>0&&(p=-p);for(let v=1;v<=e;v++)s[v].applyMatrix4(l.makeRotationAxis(r[v],p*v)),o[v].crossVectors(r[v],s[v])}return{tangents:r,normals:s,binormals:o}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class ef extends mi{constructor(e=0,t=0,i=1,r=1,s=0,o=Math.PI*2,a=!1,l=0){super(),this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=i,this.yRadius=r,this.aStartAngle=s,this.aEndAngle=o,this.aClockwise=a,this.aRotation=l}getPoint(e,t){const i=t||new fe,r=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const o=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=r;for(;s>r;)s-=r;s<Number.EPSILON&&(o?s=0:s=r),this.aClockwise===!0&&!o&&(s===r?s=-r:s=s-r);const a=this.aStartAngle+e*s;let l=this.aX+this.xRadius*Math.cos(a),c=this.aY+this.yRadius*Math.sin(a);if(this.aRotation!==0){const u=Math.cos(this.aRotation),h=Math.sin(this.aRotation),d=l-this.aX,p=c-this.aY;l=d*u-p*h+this.aX,c=d*h+p*u+this.aY}return i.set(l,c)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}ef.prototype.isEllipseCurve=!0;class ZS extends ef{constructor(e,t,i,r,s,o){super(e,t,i,i,r,s,o),this.type="ArcCurve"}}ZS.prototype.isArcCurve=!0;function x0(){let n=0,e=0,t=0,i=0;function r(s,o,a,l){n=s,e=a,t=-3*s+3*o-2*a-l,i=2*s-2*o+a+l}return{initCatmullRom:function(s,o,a,l,c){r(o,a,c*(a-s),c*(l-o))},initNonuniformCatmullRom:function(s,o,a,l,c,u,h){let d=(o-s)/c-(a-s)/(c+u)+(a-o)/u,p=(a-o)/u-(l-o)/(u+h)+(l-a)/h;d*=u,p*=u,r(o,a,d,p)},calc:function(s){const o=s*s,a=o*s;return n+e*s+t*o+i*a}}}const nh=new B,pp=new x0,mp=new x0,gp=new x0;class JS extends mi{constructor(e=[],t=!1,i="centripetal",r=.5){super(),this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=i,this.tension=r}getPoint(e,t=new B){const i=t,r=this.points,s=r.length,o=(s-(this.closed?0:1))*e;let a=Math.floor(o),l=o-a;this.closed?a+=a>0?0:(Math.floor(Math.abs(a)/s)+1)*s:l===0&&a===s-1&&(a=s-2,l=1);let c,u;this.closed||a>0?c=r[(a-1)%s]:(nh.subVectors(r[0],r[1]).add(r[0]),c=nh);const h=r[a%s],d=r[(a+1)%s];if(this.closed||a+2<s?u=r[(a+2)%s]:(nh.subVectors(r[s-1],r[s-2]).add(r[s-1]),u=nh),this.curveType==="centripetal"||this.curveType==="chordal"){const p=this.curveType==="chordal"?.5:.25;let v=Math.pow(c.distanceToSquared(h),p),m=Math.pow(h.distanceToSquared(d),p),f=Math.pow(d.distanceToSquared(u),p);m<1e-4&&(m=1),v<1e-4&&(v=m),f<1e-4&&(f=m),pp.initNonuniformCatmullRom(c.x,h.x,d.x,u.x,v,m,f),mp.initNonuniformCatmullRom(c.y,h.y,d.y,u.y,v,m,f),gp.initNonuniformCatmullRom(c.z,h.z,d.z,u.z,v,m,f)}else this.curveType==="catmullrom"&&(pp.initCatmullRom(c.x,h.x,d.x,u.x,this.tension),mp.initCatmullRom(c.y,h.y,d.y,u.y,this.tension),gp.initCatmullRom(c.z,h.z,d.z,u.z,this.tension));return i.set(pp.calc(l),mp.calc(l),gp.calc(l)),i}copy(e){super.copy(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const r=e.points[t];this.points.push(r.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,i=this.points.length;t<i;t++){const r=this.points[t];e.points.push(r.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const r=e.points[t];this.points.push(new B().fromArray(r))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}JS.prototype.isCatmullRomCurve3=!0;function gx(n,e,t,i,r){const s=(i-e)*.5,o=(r-t)*.5,a=n*n,l=n*a;return(2*t-2*i+s+o)*l+(-3*t+3*i-2*s-o)*a+s*n+t}function oP(n,e){const t=1-n;return t*t*e}function aP(n,e){return 2*(1-n)*n*e}function lP(n,e){return n*n*e}function wc(n,e,t,i){return oP(n,e)+aP(n,t)+lP(n,i)}function cP(n,e){const t=1-n;return t*t*t*e}function uP(n,e){const t=1-n;return 3*t*t*n*e}function hP(n,e){return 3*(1-n)*n*n*e}function dP(n,e){return n*n*n*e}function Ec(n,e,t,i,r){return cP(n,e)+uP(n,t)+hP(n,i)+dP(n,r)}class y0 extends mi{constructor(e=new fe,t=new fe,i=new fe,r=new fe){super(),this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=i,this.v3=r}getPoint(e,t=new fe){const i=t,r=this.v0,s=this.v1,o=this.v2,a=this.v3;return i.set(Ec(e,r.x,s.x,o.x,a.x),Ec(e,r.y,s.y,o.y,a.y)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}y0.prototype.isCubicBezierCurve=!0;class QS extends mi{constructor(e=new B,t=new B,i=new B,r=new B){super(),this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=i,this.v3=r}getPoint(e,t=new B){const i=t,r=this.v0,s=this.v1,o=this.v2,a=this.v3;return i.set(Ec(e,r.x,s.x,o.x,a.x),Ec(e,r.y,s.y,o.y,a.y),Ec(e,r.z,s.z,o.z,a.z)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}QS.prototype.isCubicBezierCurve3=!0;class tf extends mi{constructor(e=new fe,t=new fe){super(),this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new fe){const i=t;return e===1?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(e).add(this.v1)),i}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){const i=t||new fe;return i.copy(this.v2).sub(this.v1).normalize(),i}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}tf.prototype.isLineCurve=!0;class fP extends mi{constructor(e=new B,t=new B){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=e,this.v2=t}getPoint(e,t=new B){const i=t;return e===1?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(e).add(this.v1)),i}getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class M0 extends mi{constructor(e=new fe,t=new fe,i=new fe){super(),this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=i}getPoint(e,t=new fe){const i=t,r=this.v0,s=this.v1,o=this.v2;return i.set(wc(e,r.x,s.x,o.x),wc(e,r.y,s.y,o.y)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}M0.prototype.isQuadraticBezierCurve=!0;class ew extends mi{constructor(e=new B,t=new B,i=new B){super(),this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=i}getPoint(e,t=new B){const i=t,r=this.v0,s=this.v1,o=this.v2;return i.set(wc(e,r.x,s.x,o.x),wc(e,r.y,s.y,o.y),wc(e,r.z,s.z,o.z)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}ew.prototype.isQuadraticBezierCurve3=!0;class S0 extends mi{constructor(e=[]){super(),this.type="SplineCurve",this.points=e}getPoint(e,t=new fe){const i=t,r=this.points,s=(r.length-1)*e,o=Math.floor(s),a=s-o,l=r[o===0?o:o-1],c=r[o],u=r[o>r.length-2?r.length-1:o+1],h=r[o>r.length-3?r.length-1:o+2];return i.set(gx(a,l.x,c.x,u.x,h.x),gx(a,l.y,c.y,u.y,h.y)),i}copy(e){super.copy(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const r=e.points[t];this.points.push(r.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,i=this.points.length;t<i;t++){const r=this.points[t];e.points.push(r.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const r=e.points[t];this.points.push(new fe().fromArray(r))}return this}}S0.prototype.isSplineCurve=!0;var tw=Object.freeze({__proto__:null,ArcCurve:ZS,CatmullRomCurve3:JS,CubicBezierCurve:y0,CubicBezierCurve3:QS,EllipseCurve:ef,LineCurve:tf,LineCurve3:fP,QuadraticBezierCurve:M0,QuadraticBezierCurve3:ew,SplineCurve:S0});class pP extends mi{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new tf(t,e))}getPoint(e,t){const i=e*this.getLength(),r=this.getCurveLengths();let s=0;for(;s<r.length;){if(r[s]>=i){const o=r[s]-i,a=this.curves[s],l=a.getLength(),c=l===0?0:1-o/l;return a.getPointAt(c,t)}s++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let i=0,r=this.curves.length;i<r;i++)t+=this.curves[i].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let i=0;i<=e;i++)t.push(this.getPoint(i/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let i;for(let r=0,s=this.curves;r<s.length;r++){const o=s[r],a=o.isEllipseCurve?e*2:o.isLineCurve||o.isLineCurve3?1:o.isSplineCurve?e*o.points.length:e,l=o.getPoints(a);for(let c=0;c<l.length;c++){const u=l[c];i&&i.equals(u)||(t.push(u),i=u)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,i=e.curves.length;t<i;t++){const r=e.curves[t];this.curves.push(r.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,i=this.curves.length;t<i;t++){const r=this.curves[t];e.curves.push(r.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,i=e.curves.length;t<i;t++){const r=e.curves[t];this.curves.push(new tw[r.type]().fromJSON(r))}return this}}class qm extends pP{constructor(e){super(),this.type="Path",this.currentPoint=new fe,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,i=e.length;t<i;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const i=new tf(this.currentPoint.clone(),new fe(e,t));return this.curves.push(i),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,i,r){const s=new M0(this.currentPoint.clone(),new fe(e,t),new fe(i,r));return this.curves.push(s),this.currentPoint.set(i,r),this}bezierCurveTo(e,t,i,r,s,o){const a=new y0(this.currentPoint.clone(),new fe(e,t),new fe(i,r),new fe(s,o));return this.curves.push(a),this.currentPoint.set(s,o),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),i=new S0(t);return this.curves.push(i),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,i,r,s,o){const a=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(e+a,t+l,i,r,s,o),this}absarc(e,t,i,r,s,o){return this.absellipse(e,t,i,i,r,s,o),this}ellipse(e,t,i,r,s,o,a,l){const c=this.currentPoint.x,u=this.currentPoint.y;return this.absellipse(e+c,t+u,i,r,s,o,a,l),this}absellipse(e,t,i,r,s,o,a,l){const c=new ef(e,t,i,r,s,o,a,l);if(this.curves.length>0){const h=c.getPoint(0);h.equals(this.currentPoint)||this.lineTo(h.x,h.y)}this.curves.push(c);const u=c.getPoint(1);return this.currentPoint.copy(u),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class vu extends lt{constructor(e=1,t=1,i=1,r=8,s=1,o=!1,a=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:i,radialSegments:r,heightSegments:s,openEnded:o,thetaStart:a,thetaLength:l};const c=this;r=Math.floor(r),s=Math.floor(s);const u=[],h=[],d=[],p=[];let v=0;const m=[],f=i/2;let g=0;_(),o===!1&&(e>0&&M(!0),t>0&&M(!1)),this.setIndex(u),this.setAttribute("position",new rt(h,3)),this.setAttribute("normal",new rt(d,3)),this.setAttribute("uv",new rt(p,2));function _(){const E=new B,S=new B;let T=0;const R=(t-e)/i;for(let x=0;x<=s;x++){const A=[],I=x/s,N=I*(t-e)+e;for(let J=0;J<=r;J++){const q=J/r,L=q*l+a,$=Math.sin(L),z=Math.cos(L);S.x=N*$,S.y=-I*i+f,S.z=N*z,h.push(S.x,S.y,S.z),E.set($,R,z).normalize(),d.push(E.x,E.y,E.z),p.push(q,1-I),A.push(v++)}m.push(A)}for(let x=0;x<r;x++)for(let A=0;A<s;A++){const I=m[A][x],N=m[A+1][x],J=m[A+1][x+1],q=m[A][x+1];u.push(I,N,q),u.push(N,J,q),T+=6}c.addGroup(g,T,0),g+=T}function M(E){const S=v,T=new fe,R=new B;let x=0;const A=E===!0?e:t,I=E===!0?1:-1;for(let J=1;J<=r;J++)h.push(0,f*I,0),d.push(0,I,0),p.push(.5,.5),v++;const N=v;for(let J=0;J<=r;J++){const L=J/r*l+a,$=Math.cos(L),z=Math.sin(L);R.x=A*z,R.y=f*I,R.z=A*$,h.push(R.x,R.y,R.z),d.push(0,I,0),T.x=$*.5+.5,T.y=z*.5*I+.5,p.push(T.x,T.y),v++}for(let J=0;J<r;J++){const q=S+J,L=N+J;E===!0?u.push(L,L+1,q):u.push(L+1,L,q),x+=3}c.addGroup(g,x,E===!0?1:2),g+=x}}static fromJSON(e){return new vu(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}new B;new B;new B;new zt;class _u extends qm{constructor(e){super(e),this.uuid=di(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let i=0,r=this.holes.length;i<r;i++)t[i]=this.holes[i].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,i=e.holes.length;t<i;t++){const r=e.holes[t];this.holes.push(r.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,i=this.holes.length;t<i;t++){const r=this.holes[t];e.holes.push(r.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,i=e.holes.length;t<i;t++){const r=e.holes[t];this.holes.push(new qm().fromJSON(r))}return this}}const mP={triangulate:function(n,e,t=2){const i=e&&e.length,r=i?e[0]*t:n.length;let s=nw(n,0,r,t,!0);const o=[];if(!s||s.next===s.prev)return o;let a,l,c,u,h,d,p;if(i&&(s=yP(n,e,s,t)),n.length>80*t){a=c=n[0],l=u=n[1];for(let v=t;v<r;v+=t)h=n[v],d=n[v+1],h<a&&(a=h),d<l&&(l=d),h>c&&(c=h),d>u&&(u=d);p=Math.max(c-a,u-l),p=p!==0?1/p:0}return kc(s,o,t,a,l,p),o}};function nw(n,e,t,i,r){let s,o;if(r===PP(n,e,t,i)>0)for(s=e;s<t;s+=i)o=vx(s,n[s],n[s+1],o);else for(s=t-i;s>=e;s-=i)o=vx(s,n[s],n[s+1],o);return o&&nf(o,o.next)&&(Gc(o),o=o.next),o}function Ts(n,e){if(!n)return n;e||(e=n);let t=n,i;do if(i=!1,!t.steiner&&(nf(t,t.next)||bt(t.prev,t,t.next)===0)){if(Gc(t),t=e=t.prev,t===t.next)break;i=!0}else t=t.next;while(i||t!==e);return e}function kc(n,e,t,i,r,s,o){if(!n)return;!o&&s&&bP(n,i,r,s);let a=n,l,c;for(;n.prev!==n.next;){if(l=n.prev,c=n.next,s?vP(n,i,r,s):gP(n)){e.push(l.i/t),e.push(n.i/t),e.push(c.i/t),Gc(n),n=c.next,a=c.next;continue}if(n=c,n===a){o?o===1?(n=_P(Ts(n),e,t),kc(n,e,t,i,r,s,2)):o===2&&xP(n,e,t,i,r,s):kc(Ts(n),e,t,i,r,s,1);break}}}function gP(n){const e=n.prev,t=n,i=n.next;if(bt(e,t,i)>=0)return!1;let r=n.next.next;for(;r!==n.prev;){if(Ma(e.x,e.y,t.x,t.y,i.x,i.y,r.x,r.y)&&bt(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function vP(n,e,t,i){const r=n.prev,s=n,o=n.next;if(bt(r,s,o)>=0)return!1;const a=r.x<s.x?r.x<o.x?r.x:o.x:s.x<o.x?s.x:o.x,l=r.y<s.y?r.y<o.y?r.y:o.y:s.y<o.y?s.y:o.y,c=r.x>s.x?r.x>o.x?r.x:o.x:s.x>o.x?s.x:o.x,u=r.y>s.y?r.y>o.y?r.y:o.y:s.y>o.y?s.y:o.y,h=Ym(a,l,e,t,i),d=Ym(c,u,e,t,i);let p=n.prevZ,v=n.nextZ;for(;p&&p.z>=h&&v&&v.z<=d;){if(p!==n.prev&&p!==n.next&&Ma(r.x,r.y,s.x,s.y,o.x,o.y,p.x,p.y)&&bt(p.prev,p,p.next)>=0||(p=p.prevZ,v!==n.prev&&v!==n.next&&Ma(r.x,r.y,s.x,s.y,o.x,o.y,v.x,v.y)&&bt(v.prev,v,v.next)>=0))return!1;v=v.nextZ}for(;p&&p.z>=h;){if(p!==n.prev&&p!==n.next&&Ma(r.x,r.y,s.x,s.y,o.x,o.y,p.x,p.y)&&bt(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;v&&v.z<=d;){if(v!==n.prev&&v!==n.next&&Ma(r.x,r.y,s.x,s.y,o.x,o.y,v.x,v.y)&&bt(v.prev,v,v.next)>=0)return!1;v=v.nextZ}return!0}function _P(n,e,t){let i=n;do{const r=i.prev,s=i.next.next;!nf(r,s)&&iw(r,i,i.next,s)&&Hc(r,s)&&Hc(s,r)&&(e.push(r.i/t),e.push(i.i/t),e.push(s.i/t),Gc(i),Gc(i.next),i=n=s),i=i.next}while(i!==n);return Ts(i)}function xP(n,e,t,i,r,s){let o=n;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&CP(o,a)){let l=rw(o,a);o=Ts(o,o.next),l=Ts(l,l.next),kc(o,e,t,i,r,s),kc(l,e,t,i,r,s);return}a=a.next}o=o.next}while(o!==n)}function yP(n,e,t,i){const r=[];let s,o,a,l,c;for(s=0,o=e.length;s<o;s++)a=e[s]*i,l=s<o-1?e[s+1]*i:n.length,c=nw(n,a,l,i,!1),c===c.next&&(c.steiner=!0),r.push(AP(c));for(r.sort(MP),s=0;s<r.length;s++)SP(r[s],t),t=Ts(t,t.next);return t}function MP(n,e){return n.x-e.x}function SP(n,e){if(e=wP(n,e),e){const t=rw(e,n);Ts(e,e.next),Ts(t,t.next)}}function wP(n,e){let t=e;const i=n.x,r=n.y;let s=-1/0,o;do{if(r<=t.y&&r>=t.next.y&&t.next.y!==t.y){const d=t.x+(r-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(d<=i&&d>s){if(s=d,d===i){if(r===t.y)return t;if(r===t.next.y)return t.next}o=t.x<t.next.x?t:t.next}}t=t.next}while(t!==e);if(!o)return null;if(i===s)return o;const a=o,l=o.x,c=o.y;let u=1/0,h;t=o;do i>=t.x&&t.x>=l&&i!==t.x&&Ma(r<c?i:s,r,l,c,r<c?s:i,r,t.x,t.y)&&(h=Math.abs(r-t.y)/(i-t.x),Hc(t,n)&&(h<u||h===u&&(t.x>o.x||t.x===o.x&&EP(o,t)))&&(o=t,u=h)),t=t.next;while(t!==a);return o}function EP(n,e){return bt(n.prev,n,e.prev)<0&&bt(e.next,n,n.next)<0}function bP(n,e,t,i){let r=n;do r.z===null&&(r.z=Ym(r.x,r.y,e,t,i)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next;while(r!==n);r.prevZ.nextZ=null,r.prevZ=null,TP(r)}function TP(n){let e,t,i,r,s,o,a,l,c=1;do{for(t=n,n=null,s=null,o=0;t;){for(o++,i=t,a=0,e=0;e<c&&(a++,i=i.nextZ,!!i);e++);for(l=c;a>0||l>0&&i;)a!==0&&(l===0||!i||t.z<=i.z)?(r=t,t=t.nextZ,a--):(r=i,i=i.nextZ,l--),s?s.nextZ=r:n=r,r.prevZ=s,s=r;t=i}s.nextZ=null,c*=2}while(o>1);return n}function Ym(n,e,t,i,r){return n=32767*(n-t)*r,e=32767*(e-i)*r,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,n|e<<1}function AP(n){let e=n,t=n;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==n);return t}function Ma(n,e,t,i,r,s,o,a){return(r-o)*(e-a)-(n-o)*(s-a)>=0&&(n-o)*(i-a)-(t-o)*(e-a)>=0&&(t-o)*(s-a)-(r-o)*(i-a)>=0}function CP(n,e){return n.next.i!==e.i&&n.prev.i!==e.i&&!RP(n,e)&&(Hc(n,e)&&Hc(e,n)&&LP(n,e)&&(bt(n.prev,n,e.prev)||bt(n,e.prev,e))||nf(n,e)&&bt(n.prev,n,n.next)>0&&bt(e.prev,e,e.next)>0)}function bt(n,e,t){return(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y)}function nf(n,e){return n.x===e.x&&n.y===e.y}function iw(n,e,t,i){const r=rh(bt(n,e,t)),s=rh(bt(n,e,i)),o=rh(bt(t,i,n)),a=rh(bt(t,i,e));return!!(r!==s&&o!==a||r===0&&ih(n,t,e)||s===0&&ih(n,i,e)||o===0&&ih(t,n,i)||a===0&&ih(t,e,i))}function ih(n,e,t){return e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y)}function rh(n){return n>0?1:n<0?-1:0}function RP(n,e){let t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&iw(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1}function Hc(n,e){return bt(n.prev,n,n.next)<0?bt(n,e,n.next)>=0&&bt(n,n.prev,e)>=0:bt(n,e,n.prev)<0||bt(n,n.next,e)<0}function LP(n,e){let t=n,i=!1;const r=(n.x+e.x)/2,s=(n.y+e.y)/2;do t.y>s!=t.next.y>s&&t.next.y!==t.y&&r<(t.next.x-t.x)*(s-t.y)/(t.next.y-t.y)+t.x&&(i=!i),t=t.next;while(t!==n);return i}function rw(n,e){const t=new Km(n.i,n.x,n.y),i=new Km(e.i,e.x,e.y),r=n.next,s=e.prev;return n.next=e,e.prev=n,t.next=r,r.prev=t,i.next=t,t.prev=i,s.next=i,i.prev=s,i}function vx(n,e,t,i){const r=new Km(n,e,t);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function Gc(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function Km(n,e,t){this.i=n,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function PP(n,e,t,i){let r=0;for(let s=e,o=t-i;s<t;s+=i)r+=(n[o]-n[s])*(n[s+1]+n[o+1]),o=s;return r}class fs{static area(e){const t=e.length;let i=0;for(let r=t-1,s=0;s<t;r=s++)i+=e[r].x*e[s].y-e[s].x*e[r].y;return i*.5}static isClockWise(e){return fs.area(e)<0}static triangulateShape(e,t){const i=[],r=[],s=[];_x(e),xx(i,e);let o=e.length;t.forEach(_x);for(let l=0;l<t.length;l++)r.push(o),o+=t[l].length,xx(i,t[l]);const a=mP.triangulate(i,r);for(let l=0;l<a.length;l+=3)s.push(a.slice(l,l+3));return s}}function _x(n){const e=n.length;e>2&&n[e-1].equals(n[0])&&n.pop()}function xx(n,e){for(let t=0;t<e.length;t++)n.push(e[t].x),n.push(e[t].y)}class wl extends lt{constructor(e=new _u([new fe(.5,.5),new fe(-.5,.5),new fe(-.5,-.5),new fe(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const i=this,r=[],s=[];for(let a=0,l=e.length;a<l;a++){const c=e[a];o(c)}this.setAttribute("position",new rt(r,3)),this.setAttribute("uv",new rt(s,2)),this.computeVertexNormals();function o(a){const l=[],c=t.curveSegments!==void 0?t.curveSegments:12,u=t.steps!==void 0?t.steps:1;let h=t.depth!==void 0?t.depth:1,d=t.bevelEnabled!==void 0?t.bevelEnabled:!0,p=t.bevelThickness!==void 0?t.bevelThickness:.2,v=t.bevelSize!==void 0?t.bevelSize:p-.1,m=t.bevelOffset!==void 0?t.bevelOffset:0,f=t.bevelSegments!==void 0?t.bevelSegments:3;const g=t.extrudePath,_=t.UVGenerator!==void 0?t.UVGenerator:DP;t.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),h=t.amount);let M,E=!1,S,T,R,x;g&&(M=g.getSpacedPoints(u),E=!0,d=!1,S=g.computeFrenetFrames(u,!1),T=new B,R=new B,x=new B),d||(f=0,p=0,v=0,m=0);const A=a.extractPoints(c);let I=A.shape;const N=A.holes;if(!fs.isClockWise(I)){I=I.reverse();for(let oe=0,ne=N.length;oe<ne;oe++){const pe=N[oe];fs.isClockWise(pe)&&(N[oe]=pe.reverse())}}const q=fs.triangulateShape(I,N),L=I;for(let oe=0,ne=N.length;oe<ne;oe++){const pe=N[oe];I=I.concat(pe)}function $(oe,ne,pe){return ne||console.error("THREE.ExtrudeGeometry: vec does not exist"),ne.clone().multiplyScalar(pe).add(oe)}const z=I.length,W=q.length;function U(oe,ne,pe){let De,Se,$e;const Oe=oe.x-ne.x,Te=oe.y-ne.y,et=pe.x-oe.x,qe=pe.y-oe.y,b=Oe*Oe+Te*Te,y=Oe*qe-Te*et;if(Math.abs(y)>Number.EPSILON){const G=Math.sqrt(b),Z=Math.sqrt(et*et+qe*qe),ae=ne.x-Te/G,le=ne.y+Oe/G,me=pe.x-qe/Z,V=pe.y+et/Z,Ae=((me-ae)*qe-(V-le)*et)/(Oe*qe-Te*et);De=ae+Oe*Ae-oe.x,Se=le+Te*Ae-oe.y;const Ie=De*De+Se*Se;if(Ie<=2)return new fe(De,Se);$e=Math.sqrt(Ie/2)}else{let G=!1;Oe>Number.EPSILON?et>Number.EPSILON&&(G=!0):Oe<-Number.EPSILON?et<-Number.EPSILON&&(G=!0):Math.sign(Te)===Math.sign(qe)&&(G=!0),G?(De=-Te,Se=Oe,$e=Math.sqrt(b)):(De=Oe,Se=Te,$e=Math.sqrt(b/2))}return new fe(De/$e,Se/$e)}const P=[];for(let oe=0,ne=L.length,pe=ne-1,De=oe+1;oe<ne;oe++,pe++,De++)pe===ne&&(pe=0),De===ne&&(De=0),P[oe]=U(L[oe],L[pe],L[De]);const k=[];let Y,j=P.concat();for(let oe=0,ne=N.length;oe<ne;oe++){const pe=N[oe];Y=[];for(let De=0,Se=pe.length,$e=Se-1,Oe=De+1;De<Se;De++,$e++,Oe++)$e===Se&&($e=0),Oe===Se&&(Oe=0),Y[De]=U(pe[De],pe[$e],pe[Oe]);k.push(Y),j=j.concat(Y)}for(let oe=0;oe<f;oe++){const ne=oe/f,pe=p*Math.cos(ne*Math.PI/2),De=v*Math.sin(ne*Math.PI/2)+m;for(let Se=0,$e=L.length;Se<$e;Se++){const Oe=$(L[Se],P[Se],De);We(Oe.x,Oe.y,-pe)}for(let Se=0,$e=N.length;Se<$e;Se++){const Oe=N[Se];Y=k[Se];for(let Te=0,et=Oe.length;Te<et;Te++){const qe=$(Oe[Te],Y[Te],De);We(qe.x,qe.y,-pe)}}}const K=v+m;for(let oe=0;oe<z;oe++){const ne=d?$(I[oe],j[oe],K):I[oe];E?(R.copy(S.normals[0]).multiplyScalar(ne.x),T.copy(S.binormals[0]).multiplyScalar(ne.y),x.copy(M[0]).add(R).add(T),We(x.x,x.y,x.z)):We(ne.x,ne.y,0)}for(let oe=1;oe<=u;oe++)for(let ne=0;ne<z;ne++){const pe=d?$(I[ne],j[ne],K):I[ne];E?(R.copy(S.normals[oe]).multiplyScalar(pe.x),T.copy(S.binormals[oe]).multiplyScalar(pe.y),x.copy(M[oe]).add(R).add(T),We(x.x,x.y,x.z)):We(pe.x,pe.y,h/u*oe)}for(let oe=f-1;oe>=0;oe--){const ne=oe/f,pe=p*Math.cos(ne*Math.PI/2),De=v*Math.sin(ne*Math.PI/2)+m;for(let Se=0,$e=L.length;Se<$e;Se++){const Oe=$(L[Se],P[Se],De);We(Oe.x,Oe.y,h+pe)}for(let Se=0,$e=N.length;Se<$e;Se++){const Oe=N[Se];Y=k[Se];for(let Te=0,et=Oe.length;Te<et;Te++){const qe=$(Oe[Te],Y[Te],De);E?We(qe.x,qe.y+M[u-1].y,M[u-1].x+pe):We(qe.x,qe.y,h+pe)}}}ce(),de();function ce(){const oe=r.length/3;if(d){let ne=0,pe=z*ne;for(let De=0;De<W;De++){const Se=q[De];Me(Se[2]+pe,Se[1]+pe,Se[0]+pe)}ne=u+f*2,pe=z*ne;for(let De=0;De<W;De++){const Se=q[De];Me(Se[0]+pe,Se[1]+pe,Se[2]+pe)}}else{for(let ne=0;ne<W;ne++){const pe=q[ne];Me(pe[2],pe[1],pe[0])}for(let ne=0;ne<W;ne++){const pe=q[ne];Me(pe[0]+z*u,pe[1]+z*u,pe[2]+z*u)}}i.addGroup(oe,r.length/3-oe,0)}function de(){const oe=r.length/3;let ne=0;F(L,ne),ne+=L.length;for(let pe=0,De=N.length;pe<De;pe++){const Se=N[pe];F(Se,ne),ne+=Se.length}i.addGroup(oe,r.length/3-oe,1)}function F(oe,ne){let pe=oe.length;for(;--pe>=0;){const De=pe;let Se=pe-1;Se<0&&(Se=oe.length-1);for(let $e=0,Oe=u+f*2;$e<Oe;$e++){const Te=z*$e,et=z*($e+1),qe=ne+De+Te,b=ne+Se+Te,y=ne+Se+et,G=ne+De+et;Ce(qe,b,y,G)}}}function We(oe,ne,pe){l.push(oe),l.push(ne),l.push(pe)}function Me(oe,ne,pe){re(oe),re(ne),re(pe);const De=r.length/3,Se=_.generateTopUV(i,r,De-3,De-2,De-1);ze(Se[0]),ze(Se[1]),ze(Se[2])}function Ce(oe,ne,pe,De){re(oe),re(ne),re(De),re(ne),re(pe),re(De);const Se=r.length/3,$e=_.generateSideWallUV(i,r,Se-6,Se-3,Se-2,Se-1);ze($e[0]),ze($e[1]),ze($e[3]),ze($e[1]),ze($e[2]),ze($e[3])}function re(oe){r.push(l[oe*3+0]),r.push(l[oe*3+1]),r.push(l[oe*3+2])}function ze(oe){s.push(oe.x),s.push(oe.y)}}}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,i=this.parameters.options;return IP(t,i,e)}static fromJSON(e,t){const i=[];for(let s=0,o=e.shapes.length;s<o;s++){const a=t[e.shapes[s]];i.push(a)}const r=e.options.extrudePath;return r!==void 0&&(e.options.extrudePath=new tw[r.type]().fromJSON(r)),new wl(i,e.options)}}const DP={generateTopUV:function(n,e,t,i,r){const s=e[t*3],o=e[t*3+1],a=e[i*3],l=e[i*3+1],c=e[r*3],u=e[r*3+1];return[new fe(s,o),new fe(a,l),new fe(c,u)]},generateSideWallUV:function(n,e,t,i,r,s){const o=e[t*3],a=e[t*3+1],l=e[t*3+2],c=e[i*3],u=e[i*3+1],h=e[i*3+2],d=e[r*3],p=e[r*3+1],v=e[r*3+2],m=e[s*3],f=e[s*3+1],g=e[s*3+2];return Math.abs(a-u)<Math.abs(o-c)?[new fe(o,1-l),new fe(c,1-h),new fe(d,1-v),new fe(m,1-g)]:[new fe(a,1-l),new fe(u,1-h),new fe(p,1-v),new fe(f,1-g)]}};function IP(n,e,t){if(t.shapes=[],Array.isArray(n))for(let i=0,r=n.length;i<r;i++){const s=n[i];t.shapes.push(s.uuid)}else t.shapes.push(n.uuid);return e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class w0 extends lt{constructor(e=new _u([new fe(0,.5),new fe(-.5,-.5),new fe(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const i=[],r=[],s=[],o=[];let a=0,l=0;if(Array.isArray(e)===!1)c(e);else for(let u=0;u<e.length;u++)c(e[u]),this.addGroup(a,l,u),a+=l,l=0;this.setIndex(i),this.setAttribute("position",new rt(r,3)),this.setAttribute("normal",new rt(s,3)),this.setAttribute("uv",new rt(o,2));function c(u){const h=r.length/3,d=u.extractPoints(t);let p=d.shape;const v=d.holes;fs.isClockWise(p)===!1&&(p=p.reverse());for(let f=0,g=v.length;f<g;f++){const _=v[f];fs.isClockWise(_)===!0&&(v[f]=_.reverse())}const m=fs.triangulateShape(p,v);for(let f=0,g=v.length;f<g;f++){const _=v[f];p=p.concat(_)}for(let f=0,g=p.length;f<g;f++){const _=p[f];r.push(_.x,_.y,0),s.push(0,0,1),o.push(_.x,_.y)}for(let f=0,g=m.length;f<g;f++){const _=m[f],M=_[0]+h,E=_[1]+h,S=_[2]+h;i.push(M,E,S),l+=3}}}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return NP(t,e)}static fromJSON(e,t){const i=[];for(let r=0,s=e.shapes.length;r<s;r++){const o=t[e.shapes[r]];i.push(o)}return new w0(i,e.curveSegments)}}function NP(n,e){if(e.shapes=[],Array.isArray(n))for(let t=0,i=n.length;t<i;t++){const r=n[t];e.shapes.push(r.uuid)}else e.shapes.push(n.uuid);return e}class E0 extends lt{constructor(e=1,t=32,i=16,r=0,s=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:i,phiStart:r,phiLength:s,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),i=Math.max(2,Math.floor(i));const l=Math.min(o+a,Math.PI);let c=0;const u=[],h=new B,d=new B,p=[],v=[],m=[],f=[];for(let g=0;g<=i;g++){const _=[],M=g/i;let E=0;g==0&&o==0?E=.5/t:g==i&&l==Math.PI&&(E=-.5/t);for(let S=0;S<=t;S++){const T=S/t;h.x=-e*Math.cos(r+T*s)*Math.sin(o+M*a),h.y=e*Math.cos(o+M*a),h.z=e*Math.sin(r+T*s)*Math.sin(o+M*a),v.push(h.x,h.y,h.z),d.copy(h).normalize(),m.push(d.x,d.y,d.z),f.push(T+E,1-M),_.push(c++)}u.push(_)}for(let g=0;g<i;g++)for(let _=0;_<t;_++){const M=u[g][_+1],E=u[g][_],S=u[g+1][_],T=u[g+1][_+1];(g!==0||o>0)&&p.push(M,E,T),(g!==i-1||l<Math.PI)&&p.push(E,S,T)}this.setIndex(p),this.setAttribute("position",new rt(v,3)),this.setAttribute("normal",new rt(m,3)),this.setAttribute("uv",new rt(f,2))}static fromJSON(e){return new E0(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class b0 extends lt{constructor(e=1,t=.4,i=8,r=6,s=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:i,tubularSegments:r,arc:s},i=Math.floor(i),r=Math.floor(r);const o=[],a=[],l=[],c=[],u=new B,h=new B,d=new B;for(let p=0;p<=i;p++)for(let v=0;v<=r;v++){const m=v/r*s,f=p/i*Math.PI*2;h.x=(e+t*Math.cos(f))*Math.cos(m),h.y=(e+t*Math.cos(f))*Math.sin(m),h.z=t*Math.sin(f),a.push(h.x,h.y,h.z),u.x=e*Math.cos(m),u.y=e*Math.sin(m),d.subVectors(h,u).normalize(),l.push(d.x,d.y,d.z),c.push(v/r),c.push(p/i)}for(let p=1;p<=i;p++)for(let v=1;v<=r;v++){const m=(r+1)*p+v-1,f=(r+1)*(p-1)+v-1,g=(r+1)*(p-1)+v,_=(r+1)*p+v;o.push(m,f,_),o.push(f,g,_)}this.setIndex(o),this.setAttribute("position",new rt(a,3)),this.setAttribute("normal",new rt(l,3)),this.setAttribute("uv",new rt(c,2))}static fromJSON(e){return new b0(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class sw extends Rt{constructor(e){super(),this.type="ShadowMaterial",this.color=new we(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}sw.prototype.isShadowMaterial=!0;class ow extends Zt{constructor(e){super(e),this.type="RawShaderMaterial"}}ow.prototype.isRawShaderMaterial=!0;class Ls extends Rt{constructor(e){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new we(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new we(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=bo,this.normalScale=new fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}Ls.prototype.isMeshStandardMaterial=!0;class Ps extends Ls{constructor(e){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new fe(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return rn(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.sheenColor=new we(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new we(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new we(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(e)}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}Ps.prototype.isMeshPhysicalMaterial=!0;class el extends Rt{constructor(e){super(),this.type="MeshPhongMaterial",this.color=new we(16777215),this.specular=new we(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new we(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=bo,this.normalScale=new fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Wd,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}el.prototype.isMeshPhongMaterial=!0;class aw extends Rt{constructor(e){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new we(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new we(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=bo,this.normalScale=new fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}aw.prototype.isMeshToonMaterial=!0;class lw extends Rt{constructor(e){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=bo,this.normalScale=new fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}lw.prototype.isMeshNormalMaterial=!0;class cw extends Rt{constructor(e){super(),this.type="MeshLambertMaterial",this.color=new we(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new we(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Wd,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}cw.prototype.isMeshLambertMaterial=!0;class uw extends Rt{constructor(e){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new we(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=bo,this.normalScale=new fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}uw.prototype.isMeshMatcapMaterial=!0;class hw extends Ro{constructor(e){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}hw.prototype.isLineDashedMaterial=!0;const FP={ShadowMaterial:sw,SpriteMaterial:m0,RawShaderMaterial:ow,ShaderMaterial:Zt,PointsMaterial:Qd,MeshPhysicalMaterial:Ps,MeshStandardMaterial:Ls,MeshPhongMaterial:el,MeshToonMaterial:aw,MeshNormalMaterial:lw,MeshLambertMaterial:cw,MeshDepthMaterial:d0,MeshDistanceMaterial:f0,MeshBasicMaterial:Fn,MeshMatcapMaterial:uw,LineDashedMaterial:hw,LineBasicMaterial:Ro,Material:Rt};Rt.fromType=function(n){return new FP[n]};const _t={arraySlice:function(n,e,t){return _t.isTypedArray(n)?new n.constructor(n.subarray(e,t!==void 0?t:n.length)):n.slice(e,t)},convertArray:function(n,e,t){return!n||!t&&n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)},isTypedArray:function(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)},getKeyframeOrder:function(n){function e(r,s){return n[r]-n[s]}const t=n.length,i=new Array(t);for(let r=0;r!==t;++r)i[r]=r;return i.sort(e),i},sortedArray:function(n,e,t){const i=n.length,r=new n.constructor(i);for(let s=0,o=0;o!==i;++s){const a=t[s]*e;for(let l=0;l!==e;++l)r[o++]=n[a+l]}return r},flattenJSON:function(n,e,t,i){let r=1,s=n[0];for(;s!==void 0&&s[i]===void 0;)s=n[r++];if(s===void 0)return;let o=s[i];if(o!==void 0)if(Array.isArray(o))do o=s[i],o!==void 0&&(e.push(s.time),t.push.apply(t,o)),s=n[r++];while(s!==void 0);else if(o.toArray!==void 0)do o=s[i],o!==void 0&&(e.push(s.time),o.toArray(t,t.length)),s=n[r++];while(s!==void 0);else do o=s[i],o!==void 0&&(e.push(s.time),t.push(o)),s=n[r++];while(s!==void 0)},subclip:function(n,e,t,i,r=30){const s=n.clone();s.name=e;const o=[];for(let l=0;l<s.tracks.length;++l){const c=s.tracks[l],u=c.getValueSize(),h=[],d=[];for(let p=0;p<c.times.length;++p){const v=c.times[p]*r;if(!(v<t||v>=i)){h.push(c.times[p]);for(let m=0;m<u;++m)d.push(c.values[p*u+m])}}h.length!==0&&(c.times=_t.convertArray(h,c.times.constructor),c.values=_t.convertArray(d,c.values.constructor),o.push(c))}s.tracks=o;let a=1/0;for(let l=0;l<s.tracks.length;++l)a>s.tracks[l].times[0]&&(a=s.tracks[l].times[0]);for(let l=0;l<s.tracks.length;++l)s.tracks[l].shift(-1*a);return s.resetDuration(),s},makeClipAdditive:function(n,e=0,t=n,i=30){i<=0&&(i=30);const r=t.tracks.length,s=e/i;for(let o=0;o<r;++o){const a=t.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const c=n.tracks.find(function(g){return g.name===a.name&&g.ValueTypeName===l});if(c===void 0)continue;let u=0;const h=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=h/3);let d=0;const p=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=p/3);const v=a.times.length-1;let m;if(s<=a.times[0]){const g=u,_=h-u;m=_t.arraySlice(a.values,g,_)}else if(s>=a.times[v]){const g=v*h+u,_=g+h-u;m=_t.arraySlice(a.values,g,_)}else{const g=a.createInterpolant(),_=u,M=h-u;g.evaluate(s),m=_t.arraySlice(g.resultBuffer,_,M)}l==="quaternion"&&new bn().fromArray(m).normalize().conjugate().toArray(m);const f=c.times.length;for(let g=0;g<f;++g){const _=g*p+d;if(l==="quaternion")bn.multiplyQuaternionsFlat(c.values,_,m,0,c.values,_);else{const M=p-d*2;for(let E=0;E<M;++E)c.values[_+E]-=m[E]}}}return n.blendMode=AS,n}};class Pr{constructor(e,t,i,r){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=r!==void 0?r:new t.constructor(i),this.sampleValues=t,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let i=this._cachedIndex,r=t[i],s=t[i-1];e:{t:{let o;n:{i:if(!(e<r)){for(let a=i+2;;){if(r===void 0){if(e<s)break i;return i=t.length,this._cachedIndex=i,this.afterEnd_(i-1,e,s)}if(i===a)break;if(s=r,r=t[++i],e<r)break t}o=t.length;break n}if(!(e>=s)){const a=t[1];e<a&&(i=2,s=a);for(let l=i-2;;){if(s===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,r);if(i===l)break;if(r=s,s=t[--i-1],e>=s)break t}o=i,i=0;break n}break e}for(;i<o;){const a=i+o>>>1;e<t[a]?o=a:i=a+1}if(r=t[i],s=t[i-1],s===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,r);if(r===void 0)return i=t.length,this._cachedIndex=i,this.afterEnd_(i-1,s,e)}this._cachedIndex=i,this.intervalChanged_(i,s,r)}return this.interpolate_(i,s,e,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,i=this.sampleValues,r=this.valueSize,s=e*r;for(let o=0;o!==r;++o)t[o]=i[s+o];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}Pr.prototype.beforeStart_=Pr.prototype.copySampleValue_;Pr.prototype.afterEnd_=Pr.prototype.copySampleValue_;class UP extends Pr{constructor(e,t,i,r){super(e,t,i,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:_a,endingEnd:_a}}intervalChanged_(e,t,i){const r=this.parameterPositions;let s=e-2,o=e+1,a=r[s],l=r[o];if(a===void 0)switch(this.getSettings_().endingStart){case xa:s=e,a=2*t-i;break;case dd:s=r.length-2,a=t+r[s]-r[s+1];break;default:s=e,a=i}if(l===void 0)switch(this.getSettings_().endingEnd){case xa:o=e,l=2*i-t;break;case dd:o=1,l=i+r[1]-r[0];break;default:o=e-1,l=t}const c=(i-t)*.5,u=this.valueSize;this._weightPrev=c/(t-a),this._weightNext=c/(l-i),this._offsetPrev=s*u,this._offsetNext=o*u}interpolate_(e,t,i,r){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,c=l-a,u=this._offsetPrev,h=this._offsetNext,d=this._weightPrev,p=this._weightNext,v=(i-t)/(r-t),m=v*v,f=m*v,g=-d*f+2*d*m-d*v,_=(1+d)*f+(-1.5-2*d)*m+(-.5+d)*v+1,M=(-1-p)*f+(1.5+p)*m+.5*v,E=p*f-p*m;for(let S=0;S!==a;++S)s[S]=g*o[u+S]+_*o[c+S]+M*o[l+S]+E*o[h+S];return s}}class dw extends Pr{constructor(e,t,i,r){super(e,t,i,r)}interpolate_(e,t,i,r){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,c=l-a,u=(i-t)/(r-t),h=1-u;for(let d=0;d!==a;++d)s[d]=o[c+d]*h+o[l+d]*u;return s}}class OP extends Pr{constructor(e,t,i,r){super(e,t,i,r)}interpolate_(e){return this.copySampleValue_(e-1)}}class nr{constructor(e,t,i,r){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=_t.convertArray(t,this.TimeBufferType),this.values=_t.convertArray(i,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let i;if(t.toJSON!==this.toJSON)i=t.toJSON(e);else{i={name:e.name,times:_t.convertArray(e.times,Array),values:_t.convertArray(e.values,Array)};const r=e.getInterpolation();r!==e.DefaultInterpolation&&(i.interpolation=r)}return i.type=e.ValueTypeName,i}InterpolantFactoryMethodDiscrete(e){return new OP(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new dw(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new UP(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case Uc:t=this.InterpolantFactoryMethodDiscrete;break;case Za:t=this.InterpolantFactoryMethodLinear;break;case Bf:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const i="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(i);return console.warn("THREE.KeyframeTrack:",i),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Uc;case this.InterpolantFactoryMethodLinear:return Za;case this.InterpolantFactoryMethodSmooth:return Bf}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let i=0,r=t.length;i!==r;++i)t[i]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let i=0,r=t.length;i!==r;++i)t[i]*=e}return this}trim(e,t){const i=this.times,r=i.length;let s=0,o=r-1;for(;s!==r&&i[s]<e;)++s;for(;o!==-1&&i[o]>t;)--o;if(++o,s!==0||o!==r){s>=o&&(o=Math.max(o,1),s=o-1);const a=this.getValueSize();this.times=_t.arraySlice(i,s,o),this.values=_t.arraySlice(this.values,s*a,o*a)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const i=this.times,r=this.values,s=i.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let o=null;for(let a=0;a!==s;a++){const l=i[a];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,l),e=!1;break}if(o!==null&&o>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,l,o),e=!1;break}o=l}if(r!==void 0&&_t.isTypedArray(r))for(let a=0,l=r.length;a!==l;++a){const c=r[a];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,c),e=!1;break}}return e}optimize(){const e=_t.arraySlice(this.times),t=_t.arraySlice(this.values),i=this.getValueSize(),r=this.getInterpolation()===Bf,s=e.length-1;let o=1;for(let a=1;a<s;++a){let l=!1;const c=e[a],u=e[a+1];if(c!==u&&(a!==1||c!==e[0]))if(r)l=!0;else{const h=a*i,d=h-i,p=h+i;for(let v=0;v!==i;++v){const m=t[h+v];if(m!==t[d+v]||m!==t[p+v]){l=!0;break}}}if(l){if(a!==o){e[o]=e[a];const h=a*i,d=o*i;for(let p=0;p!==i;++p)t[d+p]=t[h+p]}++o}}if(s>0){e[o]=e[s];for(let a=s*i,l=o*i,c=0;c!==i;++c)t[l+c]=t[a+c];++o}return o!==e.length?(this.times=_t.arraySlice(e,0,o),this.values=_t.arraySlice(t,0,o*i)):(this.times=e,this.values=t),this}clone(){const e=_t.arraySlice(this.times,0),t=_t.arraySlice(this.values,0),i=this.constructor,r=new i(this.name,e,t);return r.createInterpolant=this.createInterpolant,r}}nr.prototype.TimeBufferType=Float32Array;nr.prototype.ValueBufferType=Float32Array;nr.prototype.DefaultInterpolation=Za;class El extends nr{}El.prototype.ValueTypeName="bool";El.prototype.ValueBufferType=Array;El.prototype.DefaultInterpolation=Uc;El.prototype.InterpolantFactoryMethodLinear=void 0;El.prototype.InterpolantFactoryMethodSmooth=void 0;class fw extends nr{}fw.prototype.ValueTypeName="color";class Vc extends nr{}Vc.prototype.ValueTypeName="number";class BP extends Pr{constructor(e,t,i,r){super(e,t,i,r)}interpolate_(e,t,i,r){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=(i-t)/(r-t);let c=e*a;for(let u=c+a;c!==u;c+=4)bn.slerpFlat(s,0,o,c-a,o,c,l);return s}}class go extends nr{InterpolantFactoryMethodLinear(e){return new BP(this.times,this.values,this.getValueSize(),e)}}go.prototype.ValueTypeName="quaternion";go.prototype.DefaultInterpolation=Za;go.prototype.InterpolantFactoryMethodSmooth=void 0;class bl extends nr{}bl.prototype.ValueTypeName="string";bl.prototype.ValueBufferType=Array;bl.prototype.DefaultInterpolation=Uc;bl.prototype.InterpolantFactoryMethodLinear=void 0;bl.prototype.InterpolantFactoryMethodSmooth=void 0;class Wc extends nr{}Wc.prototype.ValueTypeName="vector";class Zm{constructor(e,t=-1,i,r=o0){this.name=e,this.tracks=i,this.duration=t,this.blendMode=r,this.uuid=di(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],i=e.tracks,r=1/(e.fps||1);for(let o=0,a=i.length;o!==a;++o)t.push(kP(i[o]).scale(r));const s=new this(e.name,e.duration,t,e.blendMode);return s.uuid=e.uuid,s}static toJSON(e){const t=[],i=e.tracks,r={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let s=0,o=i.length;s!==o;++s)t.push(nr.toJSON(i[s]));return r}static CreateFromMorphTargetSequence(e,t,i,r){const s=t.length,o=[];for(let a=0;a<s;a++){let l=[],c=[];l.push((a+s-1)%s,a,(a+1)%s),c.push(0,1,0);const u=_t.getKeyframeOrder(l);l=_t.sortedArray(l,1,u),c=_t.sortedArray(c,1,u),!r&&l[0]===0&&(l.push(s),c.push(c[0])),o.push(new Vc(".morphTargetInfluences["+t[a].name+"]",l,c).scale(1/i))}return new this(e,-1,o)}static findByName(e,t){let i=e;if(!Array.isArray(e)){const r=e;i=r.geometry&&r.geometry.animations||r.animations}for(let r=0;r<i.length;r++)if(i[r].name===t)return i[r];return null}static CreateClipsFromMorphTargetSequences(e,t,i){const r={},s=/^([\w-]*?)([\d]+)$/;for(let a=0,l=e.length;a<l;a++){const c=e[a],u=c.name.match(s);if(u&&u.length>1){const h=u[1];let d=r[h];d||(r[h]=d=[]),d.push(c)}}const o=[];for(const a in r)o.push(this.CreateFromMorphTargetSequence(a,r[a],t,i));return o}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const i=function(h,d,p,v,m){if(p.length!==0){const f=[],g=[];_t.flattenJSON(p,f,g,v),f.length!==0&&m.push(new h(d,f,g))}},r=[],s=e.name||"default",o=e.fps||30,a=e.blendMode;let l=e.length||-1;const c=e.hierarchy||[];for(let h=0;h<c.length;h++){const d=c[h].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const p={};let v;for(v=0;v<d.length;v++)if(d[v].morphTargets)for(let m=0;m<d[v].morphTargets.length;m++)p[d[v].morphTargets[m]]=-1;for(const m in p){const f=[],g=[];for(let _=0;_!==d[v].morphTargets.length;++_){const M=d[v];f.push(M.time),g.push(M.morphTarget===m?1:0)}r.push(new Vc(".morphTargetInfluence["+m+"]",f,g))}l=p.length*o}else{const p=".bones["+t[h].name+"]";i(Wc,p+".position",d,"pos",r),i(go,p+".quaternion",d,"rot",r),i(Wc,p+".scale",d,"scl",r)}}return r.length===0?null:new this(s,l,r,a)}resetDuration(){const e=this.tracks;let t=0;for(let i=0,r=e.length;i!==r;++i){const s=this.tracks[i];t=Math.max(t,s.times[s.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function zP(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Vc;case"vector":case"vector2":case"vector3":case"vector4":return Wc;case"color":return fw;case"quaternion":return go;case"bool":case"boolean":return El;case"string":return bl}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function kP(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=zP(n.type);if(n.times===void 0){const t=[],i=[];_t.flattenJSON(n.keys,t,i,"value"),n.times=t,n.values=i}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}const tl={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class HP{constructor(e,t,i){const r=this;let s=!1,o=0,a=0,l;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=i,this.itemStart=function(u){a++,s===!1&&r.onStart!==void 0&&r.onStart(u,o,a),s=!0},this.itemEnd=function(u){o++,r.onProgress!==void 0&&r.onProgress(u,o,a),o===a&&(s=!1,r.onLoad!==void 0&&r.onLoad())},this.itemError=function(u){r.onError!==void 0&&r.onError(u)},this.resolveURL=function(u){return l?l(u):u},this.setURLModifier=function(u){return l=u,this},this.addHandler=function(u,h){return c.push(u,h),this},this.removeHandler=function(u){const h=c.indexOf(u);return h!==-1&&c.splice(h,2),this},this.getHandler=function(u){for(let h=0,d=c.length;h<d;h+=2){const p=c[h],v=c[h+1];if(p.global&&(p.lastIndex=0),p.test(u))return v}return null}}}const GP=new HP;class Ur{constructor(e){this.manager=e!==void 0?e:GP,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const i=this;return new Promise(function(r,s){i.load(e,r,t,s)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}const cr={};class T0 extends Ur{constructor(e){super(e)}load(e,t,i,r){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=tl.get(e);if(s!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(s),this.manager.itemEnd(e)},0),s;if(cr[e]!==void 0){cr[e].push({onLoad:t,onProgress:i,onError:r});return}cr[e]=[],cr[e].push({onLoad:t,onProgress:i,onError:r});const o=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,l=this.responseType;fetch(o).then(c=>{if(c.status===200||c.status===0){if(c.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream=="undefined"||c.body===void 0||c.body.getReader===void 0)return c;const u=cr[e],h=c.body.getReader(),d=c.headers.get("Content-Length"),p=d?parseInt(d):0,v=p!==0;let m=0;const f=new ReadableStream({start(g){_();function _(){h.read().then(({done:M,value:E})=>{if(M)g.close();else{m+=E.byteLength;const S=new ProgressEvent("progress",{lengthComputable:v,loaded:m,total:p});for(let T=0,R=u.length;T<R;T++){const x=u[T];x.onProgress&&x.onProgress(S)}g.enqueue(E),_()}})}}});return new Response(f)}else throw Error(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`)}).then(c=>{switch(l){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(u=>new DOMParser().parseFromString(u,a));case"json":return c.json();default:if(a===void 0)return c.text();{const h=/charset="?([^;"\s]*)"?/i.exec(a),d=h&&h[1]?h[1].toLowerCase():void 0,p=new TextDecoder(d);return c.arrayBuffer().then(v=>p.decode(v))}}}).then(c=>{tl.add(e,c);const u=cr[e];delete cr[e];for(let h=0,d=u.length;h<d;h++){const p=u[h];p.onLoad&&p.onLoad(c)}}).catch(c=>{const u=cr[e];if(u===void 0)throw this.manager.itemError(e),c;delete cr[e];for(let h=0,d=u.length;h<d;h++){const p=u[h];p.onError&&p.onError(c)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class pw extends Ur{constructor(e){super(e)}load(e,t,i,r){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,o=tl.get(e);if(o!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(o),s.manager.itemEnd(e)},0),o;const a=zc("img");function l(){u(),tl.add(e,this),t&&t(this),s.manager.itemEnd(e)}function c(h){u(),r&&r(h),s.manager.itemError(e),s.manager.itemEnd(e)}function u(){a.removeEventListener("load",l,!1),a.removeEventListener("error",c,!1)}return a.addEventListener("load",l,!1),a.addEventListener("error",c,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),s.manager.itemStart(e),a.src=e,a}}class VP extends Ur{constructor(e){super(e)}load(e,t,i,r){const s=new jd,o=new pw(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let a=0;function l(c){o.load(e[c],function(u){s.images[c]=u,a++,a===6&&(s.needsUpdate=!0,t&&t(s))},void 0,r)}for(let c=0;c<e.length;++c)l(c);return s}}class A0 extends Ur{constructor(e){super(e)}load(e,t,i,r){const s=new Ht,o=new pw(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(a){s.image=a,s.needsUpdate=!0,t!==void 0&&t(s)},i,r),s}}class tr extends at{constructor(e,t=1){super(),this.type="Light",this.color=new we(e),this.intensity=t}dispose(){}copy(e){return super.copy(e),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}tr.prototype.isLight=!0;class WP extends tr{constructor(e,t,i){super(e,i),this.type="HemisphereLight",this.position.copy(at.DefaultUp),this.updateMatrix(),this.groundColor=new we(t)}copy(e){return tr.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}WP.prototype.isHemisphereLight=!0;const yx=new Ve,Mx=new B,Sx=new B;class C0{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new fe(512,512),this.map=null,this.mapPass=null,this.matrix=new Ve,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new qd,this._frameExtents=new fe(1,1),this._viewportCount=1,this._viewports=[new ut(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,i=this.matrix;Mx.setFromMatrixPosition(e.matrixWorld),t.position.copy(Mx),Sx.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(Sx),t.updateMatrixWorld(),yx.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(yx),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(t.projectionMatrix),i.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class mw extends C0{constructor(){super(new gn(50,1,.5,500)),this.focus=1}updateMatrices(e){const t=this.camera,i=Bc*2*e.angle*this.focus,r=this.mapSize.width/this.mapSize.height,s=e.distance||t.far;(i!==t.fov||r!==t.aspect||s!==t.far)&&(t.fov=i,t.aspect=r,t.far=s,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}mw.prototype.isSpotLightShadow=!0;class gw extends tr{constructor(e,t,i=0,r=Math.PI/3,s=0,o=1){super(e,t),this.type="SpotLight",this.position.copy(at.DefaultUp),this.updateMatrix(),this.target=new at,this.distance=i,this.angle=r,this.penumbra=s,this.decay=o,this.shadow=new mw}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}gw.prototype.isSpotLight=!0;const wx=new Ve,$l=new B,vp=new B;class vw extends C0{constructor(){super(new gn(90,1,.5,500)),this._frameExtents=new fe(4,2),this._viewportCount=6,this._viewports=[new ut(2,1,1,1),new ut(0,1,1,1),new ut(3,1,1,1),new ut(1,1,1,1),new ut(3,0,1,1),new ut(1,0,1,1)],this._cubeDirections=[new B(1,0,0),new B(-1,0,0),new B(0,0,1),new B(0,0,-1),new B(0,1,0),new B(0,-1,0)],this._cubeUps=[new B(0,1,0),new B(0,1,0),new B(0,1,0),new B(0,1,0),new B(0,0,1),new B(0,0,-1)]}updateMatrices(e,t=0){const i=this.camera,r=this.matrix,s=e.distance||i.far;s!==i.far&&(i.far=s,i.updateProjectionMatrix()),$l.setFromMatrixPosition(e.matrixWorld),i.position.copy($l),vp.copy(i.position),vp.add(this._cubeDirections[t]),i.up.copy(this._cubeUps[t]),i.lookAt(vp),i.updateMatrixWorld(),r.makeTranslation(-$l.x,-$l.y,-$l.z),wx.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(wx)}}vw.prototype.isPointLightShadow=!0;class Jn extends tr{constructor(e,t,i=0,r=1){super(e,t),this.type="PointLight",this.distance=i,this.decay=r,this.shadow=new vw}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}Jn.prototype.isPointLight=!0;class _w extends C0{constructor(){super(new yl(-5,5,5,-5,.5,500))}}_w.prototype.isDirectionalLightShadow=!0;class xw extends tr{constructor(e,t){super(e,t),this.type="DirectionalLight",this.position.copy(at.DefaultUp),this.updateMatrix(),this.target=new at,this.shadow=new _w}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}xw.prototype.isDirectionalLight=!0;class yw extends tr{constructor(e,t){super(e,t),this.type="AmbientLight"}}yw.prototype.isAmbientLight=!0;class $P extends tr{constructor(e,t,i=10,r=10){super(e,t),this.type="RectAreaLight",this.width=i,this.height=r}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}$P.prototype.isRectAreaLight=!0;class Mw{constructor(){this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new B)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const i=e.x,r=e.y,s=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*r),t.addScaledVector(o[2],.488603*s),t.addScaledVector(o[3],.488603*i),t.addScaledVector(o[4],1.092548*(i*r)),t.addScaledVector(o[5],1.092548*(r*s)),t.addScaledVector(o[6],.315392*(3*s*s-1)),t.addScaledVector(o[7],1.092548*(i*s)),t.addScaledVector(o[8],.546274*(i*i-r*r)),t}getIrradianceAt(e,t){const i=e.x,r=e.y,s=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],2*.511664*r),t.addScaledVector(o[2],2*.511664*s),t.addScaledVector(o[3],2*.511664*i),t.addScaledVector(o[4],2*.429043*i*r),t.addScaledVector(o[5],2*.429043*r*s),t.addScaledVector(o[6],.743125*s*s-.247708),t.addScaledVector(o[7],2*.429043*i*s),t.addScaledVector(o[8],.429043*(i*i-r*r)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(e.coefficients[i],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let i=0;i<9;i++)this.coefficients[i].lerp(e.coefficients[i],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const i=this.coefficients;for(let r=0;r<9;r++)i[r].fromArray(e,t+r*3);return this}toArray(e=[],t=0){const i=this.coefficients;for(let r=0;r<9;r++)i[r].toArray(e,t+r*3);return e}static getBasisAt(e,t){const i=e.x,r=e.y,s=e.z;t[0]=.282095,t[1]=.488603*r,t[2]=.488603*s,t[3]=.488603*i,t[4]=1.092548*i*r,t[5]=1.092548*r*s,t[6]=.315392*(3*s*s-1),t[7]=1.092548*i*s,t[8]=.546274*(i*i-r*r)}}Mw.prototype.isSphericalHarmonics3=!0;class R0 extends tr{constructor(e=new Mw,t=1){super(void 0,t),this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}R0.prototype.isLightProbe=!0;class ps{static decodeText(e){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(e);let t="";for(let i=0,r=e.length;i<r;i++)t+=String.fromCharCode(e[i]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class XP extends lt{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const e=super.toJSON(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}XP.prototype.isInstancedBufferGeometry=!0;class Sw extends Ur{constructor(e){super(e),typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,i,r){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,o=tl.get(e);if(o!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(o),s.manager.itemEnd(e)},0),o;const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader,fetch(e,a).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(l){tl.add(e,l),t&&t(l),s.manager.itemEnd(e)}).catch(function(l){r&&r(l),s.manager.itemError(e),s.manager.itemEnd(e)}),s.manager.itemStart(e)}}Sw.prototype.isImageBitmapLoader=!0;let sh;const jP={getContext:function(){return sh===void 0&&(sh=new(window.AudioContext||window.webkitAudioContext)),sh},setContext:function(n){sh=n}};class qP extends Ur{constructor(e){super(e)}load(e,t,i,r){const s=this,o=new T0(this.manager);o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(a){try{const l=a.slice(0);jP.getContext().decodeAudioData(l,function(u){t(u)})}catch(l){r?r(l):console.error(l),s.manager.itemError(e)}},i,r)}}class YP extends R0{constructor(e,t,i=1){super(void 0,i);const r=new we().set(e),s=new we().set(t),o=new B(r.r,r.g,r.b),a=new B(s.r,s.g,s.b),l=Math.sqrt(Math.PI),c=l*Math.sqrt(.75);this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c)}}YP.prototype.isHemisphereLightProbe=!0;class KP extends R0{constructor(e,t=1){super(void 0,t);const i=new we().set(e);this.sh.coefficients[0].set(i.r,i.g,i.b).multiplyScalar(2*Math.sqrt(Math.PI))}}KP.prototype.isAmbientLightProbe=!0;class ZP{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Ex(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=Ex();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function Ex(){return(typeof performance=="undefined"?Date:performance).now()}class JP extends at{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}class QP{constructor(e,t,i){this.binding=e,this.valueSize=i;let r,s,o;switch(t){case"quaternion":r=this._slerp,s=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(i*6),this._workIndex=5;break;case"string":case"bool":r=this._select,s=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(i*5);break;default:r=this._lerp,s=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(i*5)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=s,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const i=this.buffer,r=this.valueSize,s=e*r+r;let o=this.cumulativeWeight;if(o===0){for(let a=0;a!==r;++a)i[s+a]=i[a];o=t}else{o+=t;const a=t/o;this._mixBufferRegion(i,s,0,a,r)}this.cumulativeWeight=o}accumulateAdditive(e){const t=this.buffer,i=this.valueSize,r=i*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,r,0,e,i),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,i=this.buffer,r=e*t+t,s=this.cumulativeWeight,o=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const l=t*this._origIndex;this._mixBufferRegion(i,r,l,1-s,t)}o>0&&this._mixBufferRegionAdditive(i,r,this._addIndex*t,1,t);for(let l=t,c=t+t;l!==c;++l)if(i[l]!==i[l+t]){a.setValue(i,r);break}}saveOriginalState(){const e=this.binding,t=this.buffer,i=this.valueSize,r=i*this._origIndex;e.getValue(t,r);for(let s=i,o=r;s!==o;++s)t[s]=t[r+s%i];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let i=e;i<t;i++)this.buffer[i]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let i=0;i<this.valueSize;i++)this.buffer[t+i]=this.buffer[e+i]}_select(e,t,i,r,s){if(r>=.5)for(let o=0;o!==s;++o)e[t+o]=e[i+o]}_slerp(e,t,i,r){bn.slerpFlat(e,t,e,t,e,i,r)}_slerpAdditive(e,t,i,r,s){const o=this._workIndex*s;bn.multiplyQuaternionsFlat(e,o,e,t,e,i),bn.slerpFlat(e,t,e,t,e,o,r)}_lerp(e,t,i,r,s){const o=1-r;for(let a=0;a!==s;++a){const l=t+a;e[l]=e[l]*o+e[i+a]*r}}_lerpAdditive(e,t,i,r,s){for(let o=0;o!==s;++o){const a=t+o;e[a]=e[a]+e[i+o]*r}}}const L0="\\[\\]\\.:\\/",e3=new RegExp("["+L0+"]","g"),P0="[^"+L0+"]",t3="[^"+L0.replace("\\.","")+"]",n3=/((?:WC+[\/:])*)/.source.replace("WC",P0),i3=/(WCOD+)?/.source.replace("WCOD",t3),r3=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",P0),s3=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",P0),o3=new RegExp("^"+n3+i3+r3+s3+"$"),a3=["material","materials","bones"];class l3{constructor(e,t,i){const r=i||ot.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,r)}getValue(e,t){this.bind();const i=this._targetGroup.nCachedObjects_,r=this._bindings[i];r!==void 0&&r.getValue(e,t)}setValue(e,t){const i=this._bindings;for(let r=this._targetGroup.nCachedObjects_,s=i.length;r!==s;++r)i[r].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,i=e.length;t!==i;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,i=e.length;t!==i;++t)e[t].unbind()}}class ot{constructor(e,t,i){this.path=t,this.parsedPath=i||ot.parseTrackName(t),this.node=ot.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,i){return e&&e.isAnimationObjectGroup?new ot.Composite(e,t,i):new ot(e,t,i)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(e3,"")}static parseTrackName(e){const t=o3.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const i={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},r=i.nodeName&&i.nodeName.lastIndexOf(".");if(r!==void 0&&r!==-1){const s=i.nodeName.substring(r+1);a3.indexOf(s)!==-1&&(i.nodeName=i.nodeName.substring(0,r),i.objectName=s)}if(i.propertyName===null||i.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return i}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const i=e.skeleton.getBoneByName(t);if(i!==void 0)return i}if(e.children){const i=function(s){for(let o=0;o<s.length;o++){const a=s[o];if(a.name===t||a.uuid===t)return a;const l=i(a.children);if(l)return l}return null},r=i(e.children);if(r)return r}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)e[t++]=i[r]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)i[r]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)i[r]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)i[r]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,i=t.objectName,r=t.propertyName;let s=t.propertyIndex;if(e||(e=ot.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(i){let c=t.objectIndex;switch(i){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let u=0;u<e.length;u++)if(e[u].name===c){c=u;break}break;default:if(e[i]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[i]}if(c!==void 0){if(e[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[c]}}const o=e[r];if(o===void 0){const c=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+r+" but it wasn't found.",e);return}let a=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(s!==void 0){if(r==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(e.geometry.isBufferGeometry){if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[s]!==void 0&&(s=e.morphTargetDictionary[s])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}l=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=s}else o.fromArray!==void 0&&o.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(l=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=r;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}ot.Composite=l3;ot.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};ot.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};ot.prototype.GetterByBindingType=[ot.prototype._getValue_direct,ot.prototype._getValue_array,ot.prototype._getValue_arrayElement,ot.prototype._getValue_toArray];ot.prototype.SetterByBindingTypeAndVersioning=[[ot.prototype._setValue_direct,ot.prototype._setValue_direct_setNeedsUpdate,ot.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[ot.prototype._setValue_array,ot.prototype._setValue_array_setNeedsUpdate,ot.prototype._setValue_array_setMatrixWorldNeedsUpdate],[ot.prototype._setValue_arrayElement,ot.prototype._setValue_arrayElement_setNeedsUpdate,ot.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[ot.prototype._setValue_fromArray,ot.prototype._setValue_fromArray_setNeedsUpdate,ot.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class c3{constructor(e,t,i=null,r=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=i,this.blendMode=r;const s=t.tracks,o=s.length,a=new Array(o),l={endingStart:_a,endingEnd:_a};for(let c=0;c!==o;++c){const u=s[c].createInterpolant(null);a[c]=u,u.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=GT,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,i){if(e.fadeOut(t),this.fadeIn(t),i){const r=this._clip.duration,s=e._clip.duration,o=s/r,a=r/s;e.warp(1,o,t),this.warp(a,1,t)}return this}crossFadeTo(e,t,i){return e.crossFadeFrom(this,t,i)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,i){const r=this._mixer,s=r.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=r._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,c=a.sampleValues;return l[0]=s,l[1]=s+i,c[0]=e/o,c[1]=t/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,i,r){if(!this.enabled){this._updateWeight(e);return}const s=this._startTime;if(s!==null){const l=(e-s)*i;if(l<0||i===0)return;this._startTime=null,t=i*l}t*=this._updateTimeScale(e);const o=this._updateTime(t),a=this._updateWeight(e);if(a>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case AS:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(o),c[u].accumulateAdditive(a);break;case o0:default:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(o),c[u].accumulate(r,a)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const i=this._weightInterpolant;if(i!==null){const r=i.evaluate(e)[0];t*=r,e>i.parameterPositions[1]&&(this.stopFading(),r===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const i=this._timeScaleInterpolant;i!==null&&(t*=i.evaluate(e)[0],e>i.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t))}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,i=this.loop;let r=this.time+e,s=this._loopCount;const o=i===VT;if(e===0)return s===-1?r:o&&(s&1)===1?t-r:r;if(i===HT){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(r>=t)r=t;else if(r<0)r=0;else{this.time=r;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(s===-1&&(e>=0?(s=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),r>=t||r<0){const a=Math.floor(r/t);r-=t*a,s+=Math.abs(a);const l=this.repetitions-s;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=e>0?t:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const c=e<0;this._setEndings(c,!c,o)}else this._setEndings(!1,!1,o);this._loopCount=s,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=r;if(o&&(s&1)===1)return t-r}return r}_setEndings(e,t,i){const r=this._interpolantSettings;i?(r.endingStart=xa,r.endingEnd=xa):(e?r.endingStart=this.zeroSlopeAtStart?xa:_a:r.endingStart=dd,t?r.endingEnd=this.zeroSlopeAtEnd?xa:_a:r.endingEnd=dd)}_scheduleFading(e,t,i){const r=this._mixer,s=r.time;let o=this._weightInterpolant;o===null&&(o=r._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=s,l[0]=t,a[1]=s+e,l[1]=i,this}}class u3 extends To{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const i=e._localRoot||this._root,r=e._clip.tracks,s=r.length,o=e._propertyBindings,a=e._interpolants,l=i.uuid,c=this._bindingsByRootAndName;let u=c[l];u===void 0&&(u={},c[l]=u);for(let h=0;h!==s;++h){const d=r[h],p=d.name;let v=u[p];if(v!==void 0)++v.referenceCount,o[h]=v;else{if(v=o[h],v!==void 0){v._cacheIndex===null&&(++v.referenceCount,this._addInactiveBinding(v,l,p));continue}const m=t&&t._propertyBindings[h].binding.parsedPath;v=new QP(ot.create(i,p,m),d.ValueTypeName,d.getValueSize()),++v.referenceCount,this._addInactiveBinding(v,l,p),o[h]=v}a[h].resultBuffer=v.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const i=(e._localRoot||this._root).uuid,r=e._clip.uuid,s=this._actionsByClip[r];this._bindAction(e,s&&s.knownActions[0]),this._addInactiveAction(e,r,i)}const t=e._propertyBindings;for(let i=0,r=t.length;i!==r;++i){const s=t[i];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let i=0,r=t.length;i!==r;++i){const s=t[i];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,i){const r=this._actions,s=this._actionsByClip;let o=s[t];if(o===void 0)o={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,s[t]=o;else{const a=o.knownActions;e._byClipCacheIndex=a.length,a.push(e)}e._cacheIndex=r.length,r.push(e),o.actionByRoot[i]=e}_removeInactiveAction(e){const t=this._actions,i=t[t.length-1],r=e._cacheIndex;i._cacheIndex=r,t[r]=i,t.pop(),e._cacheIndex=null;const s=e._clip.uuid,o=this._actionsByClip,a=o[s],l=a.knownActions,c=l[l.length-1],u=e._byClipCacheIndex;c._byClipCacheIndex=u,l[u]=c,l.pop(),e._byClipCacheIndex=null;const h=a.actionByRoot,d=(e._localRoot||this._root).uuid;delete h[d],l.length===0&&delete o[s],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let i=0,r=t.length;i!==r;++i){const s=t[i];--s.referenceCount===0&&this._removeInactiveBinding(s)}}_lendAction(e){const t=this._actions,i=e._cacheIndex,r=this._nActiveActions++,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=i,t[i]=s}_takeBackAction(e){const t=this._actions,i=e._cacheIndex,r=--this._nActiveActions,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=i,t[i]=s}_addInactiveBinding(e,t,i){const r=this._bindingsByRootAndName,s=this._bindings;let o=r[t];o===void 0&&(o={},r[t]=o),o[i]=e,e._cacheIndex=s.length,s.push(e)}_removeInactiveBinding(e){const t=this._bindings,i=e.binding,r=i.rootNode.uuid,s=i.path,o=this._bindingsByRootAndName,a=o[r],l=t[t.length-1],c=e._cacheIndex;l._cacheIndex=c,t[c]=l,t.pop(),delete a[s],Object.keys(a).length===0&&delete o[r]}_lendBinding(e){const t=this._bindings,i=e._cacheIndex,r=this._nActiveBindings++,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=i,t[i]=s}_takeBackBinding(e){const t=this._bindings,i=e._cacheIndex,r=--this._nActiveBindings,s=t[r];e._cacheIndex=r,t[r]=e,s._cacheIndex=i,t[i]=s}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let i=e[t];return i===void 0&&(i=new dw(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),i.__cacheIndex=t,e[t]=i),i}_takeBackControlInterpolant(e){const t=this._controlInterpolants,i=e.__cacheIndex,r=--this._nActiveControlInterpolants,s=t[r];e.__cacheIndex=r,t[r]=e,s.__cacheIndex=i,t[i]=s}clipAction(e,t,i){const r=t||this._root,s=r.uuid;let o=typeof e=="string"?Zm.findByName(r,e):e;const a=o!==null?o.uuid:e,l=this._actionsByClip[a];let c=null;if(i===void 0&&(o!==null?i=o.blendMode:i=o0),l!==void 0){const h=l.actionByRoot[s];if(h!==void 0&&h.blendMode===i)return h;c=l.knownActions[0],o===null&&(o=c._clip)}if(o===null)return null;const u=new c3(this,o,t,i);return this._bindAction(u,c),this._addInactiveAction(u,a,s),u}existingAction(e,t){const i=t||this._root,r=i.uuid,s=typeof e=="string"?Zm.findByName(i,e):e,o=s?s.uuid:e,a=this._actionsByClip[o];return a!==void 0&&a.actionByRoot[r]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let i=t-1;i>=0;--i)e[i].stop();return this}update(e){e*=this.timeScale;const t=this._actions,i=this._nActiveActions,r=this.time+=e,s=Math.sign(e),o=this._accuIndex^=1;for(let c=0;c!==i;++c)t[c]._update(r,e,s,o);const a=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)a[c].apply(o);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,i=e.uuid,r=this._actionsByClip,s=r[i];if(s!==void 0){const o=s.knownActions;for(let a=0,l=o.length;a!==l;++a){const c=o[a];this._deactivateAction(c);const u=c._cacheIndex,h=t[t.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,h._cacheIndex=u,t[u]=h,t.pop(),this._removeInactiveBindingsForAction(c)}delete r[i]}}uncacheRoot(e){const t=e.uuid,i=this._actionsByClip;for(const o in i){const a=i[o].actionByRoot,l=a[t];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const r=this._bindingsByRootAndName,s=r[t];if(s!==void 0)for(const o in s){const a=s[o];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(e,t){const i=this.existingAction(e,t);i!==null&&(this._deactivateAction(i),this._removeInactiveAction(i))}}u3.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class h3 extends Sl{constructor(e,t,i=1){super(e,t),this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}h3.prototype.isInstancedInterleavedBuffer=!0;const $r=new B,oh=new Ve,_p=new Ve;class d3 extends Jd{constructor(e){const t=ww(e),i=new lt,r=[],s=[],o=new we(0,0,1),a=new we(0,1,0);for(let c=0;c<t.length;c++){const u=t[c];u.parent&&u.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),s.push(o.r,o.g,o.b),s.push(a.r,a.g,a.b))}i.setAttribute("position",new rt(r,3)),i.setAttribute("color",new rt(s,3));const l=new Ro({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(i,l),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,i=this.geometry,r=i.getAttribute("position");_p.copy(this.root.matrixWorld).invert();for(let s=0,o=0;s<t.length;s++){const a=t[s];a.parent&&a.parent.isBone&&(oh.multiplyMatrices(_p,a.matrixWorld),$r.setFromMatrixPosition(oh),r.setXYZ(o,$r.x,$r.y,$r.z),oh.multiplyMatrices(_p,a.parent.matrixWorld),$r.setFromMatrixPosition(oh),r.setXYZ(o+1,$r.x,$r.y,$r.z),o+=2)}i.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function ww(n){const e=[];n.isBone===!0&&e.push(n);for(let t=0;t<n.children.length;t++)e.push.apply(e,ww(n.children[t]));return e}class f3 extends Jd{constructor(e=10,t=10,i=4473924,r=8947848){i=new we(i),r=new we(r);const s=t/2,o=e/t,a=e/2,l=[],c=[];for(let d=0,p=0,v=-a;d<=t;d++,v+=o){l.push(-a,0,v,a,0,v),l.push(v,0,-a,v,0,a);const m=d===s?i:r;m.toArray(c,p),p+=3,m.toArray(c,p),p+=3,m.toArray(c,p),p+=3,m.toArray(c,p),p+=3}const u=new lt;u.setAttribute("position",new rt(l,3)),u.setAttribute("color",new rt(c,3));const h=new Ro({vertexColors:!0,toneMapped:!1});super(u,h),this.type="GridHelper"}}const $i=new Uint32Array(512),Xi=new Uint32Array(512);for(let n=0;n<256;++n){const e=n-127;e<-27?($i[n]=0,$i[n|256]=32768,Xi[n]=24,Xi[n|256]=24):e<-14?($i[n]=1024>>-e-14,$i[n|256]=1024>>-e-14|32768,Xi[n]=-e-1,Xi[n|256]=-e-1):e<=15?($i[n]=e+15<<10,$i[n|256]=e+15<<10|32768,Xi[n]=13,Xi[n|256]=13):e<128?($i[n]=31744,$i[n|256]=64512,Xi[n]=24,Xi[n|256]=24):($i[n]=31744,$i[n|256]=64512,Xi[n]=13,Xi[n|256]=13)}const Ew=new Uint32Array(2048),xu=new Uint32Array(64),p3=new Uint32Array(64);for(let n=1;n<1024;++n){let e=n<<13,t=0;for(;(e&8388608)===0;)e<<=1,t-=8388608;e&=-8388609,t+=947912704,Ew[n]=e|t}for(let n=1024;n<2048;++n)Ew[n]=939524096+(n-1024<<13);for(let n=1;n<31;++n)xu[n]=n<<23;xu[31]=1199570944;xu[32]=2147483648;for(let n=33;n<63;++n)xu[n]=2147483648+(n-32<<23);xu[63]=3347054592;for(let n=1;n<64;++n)n!==32&&(p3[n]=1024);mi.create=function(n,e){return console.log("THREE.Curve.create() has been deprecated"),n.prototype=Object.create(mi.prototype),n.prototype.constructor=n,n.prototype.getPoint=e,n};qm.prototype.fromPoints=function(n){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(n)};f3.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};d3.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};Ur.prototype.extractUrlBase=function(n){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),ps.extractUrlBase(n)};Ur.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};Mn.prototype.center=function(n){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(n)};Mn.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};Mn.prototype.isIntersectionBox=function(n){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)};Mn.prototype.isIntersectionSphere=function(n){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(n)};Mn.prototype.size=function(n){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(n)};Co.prototype.toVector3=function(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")};Gi.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};qd.prototype.setFromMatrix=function(n){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(n)};sn.prototype.flattenToArrayOffset=function(n,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(n,e)};sn.prototype.multiplyVector3=function(n){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),n.applyMatrix3(this)};sn.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};sn.prototype.applyToBufferAttribute=function(n){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),n.applyMatrix3(this)};sn.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};sn.prototype.getInverse=function(n){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(n).invert()};Ve.prototype.extractPosition=function(n){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(n)};Ve.prototype.flattenToArrayOffset=function(n,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(n,e)};Ve.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new B().setFromMatrixColumn(this,3)};Ve.prototype.setRotationFromQuaternion=function(n){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(n)};Ve.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};Ve.prototype.multiplyVector3=function(n){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)};Ve.prototype.multiplyVector4=function(n){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)};Ve.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};Ve.prototype.rotateAxis=function(n){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),n.transformDirection(this)};Ve.prototype.crossVector=function(n){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)};Ve.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};Ve.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};Ve.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};Ve.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};Ve.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};Ve.prototype.applyToBufferAttribute=function(n){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)};Ve.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};Ve.prototype.makeFrustum=function(n,e,t,i,r,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(n,e,i,t,r,s)};Ve.prototype.getInverse=function(n){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(n).invert()};Mr.prototype.isIntersectionLine=function(n){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(n)};bn.prototype.multiplyVector3=function(n){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),n.applyQuaternion(this)};bn.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};xl.prototype.isIntersectionBox=function(n){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)};xl.prototype.isIntersectionPlane=function(n){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(n)};xl.prototype.isIntersectionSphere=function(n){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(n)};zt.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};zt.prototype.barycoordFromPoint=function(n,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(n,e)};zt.prototype.midpoint=function(n){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(n)};zt.prototypenormal=function(n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(n)};zt.prototype.plane=function(n){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(n)};zt.barycoordFromPoint=function(n,e,t,i,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),zt.getBarycoord(n,e,t,i,r)};zt.normal=function(n,e,t,i){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),zt.getNormal(n,e,t,i)};_u.prototype.extractAllPoints=function(n){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(n)};_u.prototype.extrude=function(n){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new wl(this,n)};_u.prototype.makeGeometry=function(n){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new w0(this,n)};fe.prototype.fromAttribute=function(n,e,t){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)};fe.prototype.distanceToManhattan=function(n){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(n)};fe.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};B.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};B.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};B.prototype.getPositionFromMatrix=function(n){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(n)};B.prototype.getScaleFromMatrix=function(n){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(n)};B.prototype.getColumnFromMatrix=function(n,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,n)};B.prototype.applyProjection=function(n){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(n)};B.prototype.fromAttribute=function(n,e,t){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)};B.prototype.distanceToManhattan=function(n){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(n)};B.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};ut.prototype.fromAttribute=function(n,e,t){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)};ut.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};at.prototype.getChildByName=function(n){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(n)};at.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};at.prototype.translate=function(n,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,n)};at.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};at.prototype.applyMatrix=function(n){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(n)};Object.defineProperties(at.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(n){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=n}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});dt.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(dt.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),WT},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});g0.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};gn.prototype.setLens=function(n,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),e!==void 0&&(this.filmGauge=e),this.setFocalLength(n)};Object.defineProperties(tr.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(n){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=n}},shadowCameraLeft:{set:function(n){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=n}},shadowCameraRight:{set:function(n){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=n}},shadowCameraTop:{set:function(n){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=n}},shadowCameraBottom:{set:function(n){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=n}},shadowCameraNear:{set:function(n){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=n}},shadowCameraFar:{set:function(n){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=n}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(n){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=n}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(n){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=n}},shadowMapHeight:{set:function(n){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=n}}});Object.defineProperties(Ut.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===fd},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(fd)}}});Ut.prototype.setDynamic=function(n){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(n===!0?fd:Oc),this};Ut.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},Ut.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};lt.prototype.addIndex=function(n){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(n)};lt.prototype.addAttribute=function(n,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(e&&e.isBufferAttribute)&&!(e&&e.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(n,new Ut(arguments[1],arguments[2]))):n==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(n,e)};lt.prototype.addDrawCall=function(n,e,t){t!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(n,e)};lt.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};lt.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};lt.prototype.removeAttribute=function(n){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(n)};lt.prototype.applyMatrix=function(n){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(n)};Object.defineProperties(lt.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});Sl.prototype.setDynamic=function(n){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(n===!0?fd:Oc),this};Sl.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};wl.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};wl.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};wl.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};p0.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};Object.defineProperties(Rt.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new we}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(n){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===SS}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(n){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=n}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}});Object.defineProperties(Zt.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(n){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=n}}});ft.prototype.clearTarget=function(n,e,t,i){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(n),this.clear(e,t,i)};ft.prototype.animate=function(n){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(n)};ft.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};ft.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};ft.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};ft.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};ft.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};ft.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};ft.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};ft.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};ft.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};ft.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};ft.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};ft.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};ft.prototype.enableScissorTest=function(n){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(n)};ft.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};ft.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};ft.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};ft.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};ft.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};ft.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};ft.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};ft.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};ft.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};ft.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(ft.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(n){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=n}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(n){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=n}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(n){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=n===!0?it:bs}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}},gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});Object.defineProperties(WS.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(on.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(n){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=n}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(n){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=n}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(n){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=n}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(n){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=n}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(n){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=n}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(n){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=n}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(n){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=n}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(n){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=n}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(n){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=n}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(n){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=n}}});JP.prototype.load=function(n){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return new qP().load(n,function(i){e.setBuffer(i)}),this};u0.prototype.updateCubeMap=function(n,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(n,e)};u0.prototype.clear=function(n,e,t,i){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(n,e,t,i)};Ao.crossOrigin=void 0;Ao.loadTexture=function(n,e,t,i){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const r=new A0;r.setCrossOrigin(this.crossOrigin);const s=r.load(n,t,void 0,i);return e&&(s.mapping=e),s};Ao.loadTextureCube=function(n,e,t,i){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const r=new VP;r.setCrossOrigin(this.crossOrigin);const s=r.load(n,t,void 0,i);return e&&(s.mapping=e),s};Ao.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};Ao.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:s0}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=s0);var wt={exports:{}},Qe={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var yu=Symbol.for("react.element"),m3=Symbol.for("react.portal"),g3=Symbol.for("react.fragment"),v3=Symbol.for("react.strict_mode"),_3=Symbol.for("react.profiler"),x3=Symbol.for("react.provider"),y3=Symbol.for("react.context"),M3=Symbol.for("react.forward_ref"),S3=Symbol.for("react.suspense"),w3=Symbol.for("react.memo"),E3=Symbol.for("react.lazy"),bx=Symbol.iterator;function b3(n){return n===null||typeof n!="object"?null:(n=bx&&n[bx]||n["@@iterator"],typeof n=="function"?n:null)}var bw={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},Tw=Object.assign,Aw={};function Tl(n,e,t){this.props=n,this.context=e,this.refs=Aw,this.updater=t||bw}Tl.prototype.isReactComponent={};Tl.prototype.setState=function(n,e){if(typeof n!="object"&&typeof n!="function"&&n!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,n,e,"setState")};Tl.prototype.forceUpdate=function(n){this.updater.enqueueForceUpdate(this,n,"forceUpdate")};function Cw(){}Cw.prototype=Tl.prototype;function D0(n,e,t){this.props=n,this.context=e,this.refs=Aw,this.updater=t||bw}var I0=D0.prototype=new Cw;I0.constructor=D0;Tw(I0,Tl.prototype);I0.isPureReactComponent=!0;var Tx=Array.isArray,Rw=Object.prototype.hasOwnProperty,N0={current:null},Lw={key:!0,ref:!0,__self:!0,__source:!0};function Pw(n,e,t){var i,r={},s=null,o=null;if(e!=null)for(i in e.ref!==void 0&&(o=e.ref),e.key!==void 0&&(s=""+e.key),e)Rw.call(e,i)&&!Lw.hasOwnProperty(i)&&(r[i]=e[i]);var a=arguments.length-2;if(a===1)r.children=t;else if(1<a){for(var l=Array(a),c=0;c<a;c++)l[c]=arguments[c+2];r.children=l}if(n&&n.defaultProps)for(i in a=n.defaultProps,a)r[i]===void 0&&(r[i]=a[i]);return{$$typeof:yu,type:n,key:s,ref:o,props:r,_owner:N0.current}}function T3(n,e){return{$$typeof:yu,type:n.type,key:e,ref:n.ref,props:n.props,_owner:n._owner}}function F0(n){return typeof n=="object"&&n!==null&&n.$$typeof===yu}function A3(n){var e={"=":"=0",":":"=2"};return"$"+n.replace(/[=:]/g,function(t){return e[t]})}var Ax=/\/+/g;function xp(n,e){return typeof n=="object"&&n!==null&&n.key!=null?A3(""+n.key):e.toString(36)}function qh(n,e,t,i,r){var s=typeof n;(s==="undefined"||s==="boolean")&&(n=null);var o=!1;if(n===null)o=!0;else switch(s){case"string":case"number":o=!0;break;case"object":switch(n.$$typeof){case yu:case m3:o=!0}}if(o)return o=n,r=r(o),n=i===""?"."+xp(o,0):i,Tx(r)?(t="",n!=null&&(t=n.replace(Ax,"$&/")+"/"),qh(r,e,t,"",function(c){return c})):r!=null&&(F0(r)&&(r=T3(r,t+(!r.key||o&&o.key===r.key?"":(""+r.key).replace(Ax,"$&/")+"/")+n)),e.push(r)),1;if(o=0,i=i===""?".":i+":",Tx(n))for(var a=0;a<n.length;a++){s=n[a];var l=i+xp(s,a);o+=qh(s,e,t,l,r)}else if(l=b3(n),typeof l=="function")for(n=l.call(n),a=0;!(s=n.next()).done;)s=s.value,l=i+xp(s,a++),o+=qh(s,e,t,l,r);else if(s==="object")throw e=String(n),Error("Objects are not valid as a React child (found: "+(e==="[object Object]"?"object with keys {"+Object.keys(n).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.");return o}function ah(n,e,t){if(n==null)return n;var i=[],r=0;return qh(n,i,"","",function(s){return e.call(t,s,r++)}),i}function C3(n){if(n._status===-1){var e=n._result;e=e(),e.then(function(t){(n._status===0||n._status===-1)&&(n._status=1,n._result=t)},function(t){(n._status===0||n._status===-1)&&(n._status=2,n._result=t)}),n._status===-1&&(n._status=0,n._result=e)}if(n._status===1)return n._result.default;throw n._result}var Pn={current:null},Yh={transition:null},R3={ReactCurrentDispatcher:Pn,ReactCurrentBatchConfig:Yh,ReactCurrentOwner:N0};Qe.Children={map:ah,forEach:function(n,e,t){ah(n,function(){e.apply(this,arguments)},t)},count:function(n){var e=0;return ah(n,function(){e++}),e},toArray:function(n){return ah(n,function(e){return e})||[]},only:function(n){if(!F0(n))throw Error("React.Children.only expected to receive a single React element child.");return n}};Qe.Component=Tl;Qe.Fragment=g3;Qe.Profiler=_3;Qe.PureComponent=D0;Qe.StrictMode=v3;Qe.Suspense=S3;Qe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=R3;Qe.cloneElement=function(n,e,t){if(n==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+n+".");var i=Tw({},n.props),r=n.key,s=n.ref,o=n._owner;if(e!=null){if(e.ref!==void 0&&(s=e.ref,o=N0.current),e.key!==void 0&&(r=""+e.key),n.type&&n.type.defaultProps)var a=n.type.defaultProps;for(l in e)Rw.call(e,l)&&!Lw.hasOwnProperty(l)&&(i[l]=e[l]===void 0&&a!==void 0?a[l]:e[l])}var l=arguments.length-2;if(l===1)i.children=t;else if(1<l){a=Array(l);for(var c=0;c<l;c++)a[c]=arguments[c+2];i.children=a}return{$$typeof:yu,type:n.type,key:r,ref:s,props:i,_owner:o}};Qe.createContext=function(n){return n={$$typeof:y3,_currentValue:n,_currentValue2:n,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},n.Provider={$$typeof:x3,_context:n},n.Consumer=n};Qe.createElement=Pw;Qe.createFactory=function(n){var e=Pw.bind(null,n);return e.type=n,e};Qe.createRef=function(){return{current:null}};Qe.forwardRef=function(n){return{$$typeof:M3,render:n}};Qe.isValidElement=F0;Qe.lazy=function(n){return{$$typeof:E3,_payload:{_status:-1,_result:n},_init:C3}};Qe.memo=function(n,e){return{$$typeof:w3,type:n,compare:e===void 0?null:e}};Qe.startTransition=function(n){var e=Yh.transition;Yh.transition={};try{n()}finally{Yh.transition=e}};Qe.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")};Qe.useCallback=function(n,e){return Pn.current.useCallback(n,e)};Qe.useContext=function(n){return Pn.current.useContext(n)};Qe.useDebugValue=function(){};Qe.useDeferredValue=function(n){return Pn.current.useDeferredValue(n)};Qe.useEffect=function(n,e){return Pn.current.useEffect(n,e)};Qe.useId=function(){return Pn.current.useId()};Qe.useImperativeHandle=function(n,e,t){return Pn.current.useImperativeHandle(n,e,t)};Qe.useInsertionEffect=function(n,e){return Pn.current.useInsertionEffect(n,e)};Qe.useLayoutEffect=function(n,e){return Pn.current.useLayoutEffect(n,e)};Qe.useMemo=function(n,e){return Pn.current.useMemo(n,e)};Qe.useReducer=function(n,e,t){return Pn.current.useReducer(n,e,t)};Qe.useRef=function(n){return Pn.current.useRef(n)};Qe.useState=function(n){return Pn.current.useState(n)};Qe.useSyncExternalStore=function(n,e,t){return Pn.current.useSyncExternalStore(n,e,t)};Qe.useTransition=function(){return Pn.current.useTransition()};Qe.version="18.2.0";wt.exports=Qe;var Q=wt.exports,Dw={exports:{}},ti={},Iw={exports:{}},Nw={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(n){function e(U,P){var k=U.length;U.push(P);e:for(;0<k;){var Y=k-1>>>1,j=U[Y];if(0<r(j,P))U[Y]=P,U[k]=j,k=Y;else break e}}function t(U){return U.length===0?null:U[0]}function i(U){if(U.length===0)return null;var P=U[0],k=U.pop();if(k!==P){U[0]=k;e:for(var Y=0,j=U.length,K=j>>>1;Y<K;){var ce=2*(Y+1)-1,de=U[ce],F=ce+1,We=U[F];if(0>r(de,k))F<j&&0>r(We,de)?(U[Y]=We,U[F]=k,Y=F):(U[Y]=de,U[ce]=k,Y=ce);else if(F<j&&0>r(We,k))U[Y]=We,U[F]=k,Y=F;else break e}}return P}function r(U,P){var k=U.sortIndex-P.sortIndex;return k!==0?k:U.id-P.id}if(typeof performance=="object"&&typeof performance.now=="function"){var s=performance;n.unstable_now=function(){return s.now()}}else{var o=Date,a=o.now();n.unstable_now=function(){return o.now()-a}}var l=[],c=[],u=1,h=null,d=3,p=!1,v=!1,m=!1,f=typeof setTimeout=="function"?setTimeout:null,g=typeof clearTimeout=="function"?clearTimeout:null,_=typeof setImmediate!="undefined"?setImmediate:null;typeof navigator!="undefined"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function M(U){for(var P=t(c);P!==null;){if(P.callback===null)i(c);else if(P.startTime<=U)i(c),P.sortIndex=P.expirationTime,e(l,P);else break;P=t(c)}}function E(U){if(m=!1,M(U),!v)if(t(l)!==null)v=!0,z(S);else{var P=t(c);P!==null&&W(E,P.startTime-U)}}function S(U,P){v=!1,m&&(m=!1,g(x),x=-1),p=!0;var k=d;try{for(M(P),h=t(l);h!==null&&(!(h.expirationTime>P)||U&&!N());){var Y=h.callback;if(typeof Y=="function"){h.callback=null,d=h.priorityLevel;var j=Y(h.expirationTime<=P);P=n.unstable_now(),typeof j=="function"?h.callback=j:h===t(l)&&i(l),M(P)}else i(l);h=t(l)}if(h!==null)var K=!0;else{var ce=t(c);ce!==null&&W(E,ce.startTime-P),K=!1}return K}finally{h=null,d=k,p=!1}}var T=!1,R=null,x=-1,A=5,I=-1;function N(){return!(n.unstable_now()-I<A)}function J(){if(R!==null){var U=n.unstable_now();I=U;var P=!0;try{P=R(!0,U)}finally{P?q():(T=!1,R=null)}}else T=!1}var q;if(typeof _=="function")q=function(){_(J)};else if(typeof MessageChannel!="undefined"){var L=new MessageChannel,$=L.port2;L.port1.onmessage=J,q=function(){$.postMessage(null)}}else q=function(){f(J,0)};function z(U){R=U,T||(T=!0,q())}function W(U,P){x=f(function(){U(n.unstable_now())},P)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(U){U.callback=null},n.unstable_continueExecution=function(){v||p||(v=!0,z(S))},n.unstable_forceFrameRate=function(U){0>U||125<U?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):A=0<U?Math.floor(1e3/U):5},n.unstable_getCurrentPriorityLevel=function(){return d},n.unstable_getFirstCallbackNode=function(){return t(l)},n.unstable_next=function(U){switch(d){case 1:case 2:case 3:var P=3;break;default:P=d}var k=d;d=P;try{return U()}finally{d=k}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(U,P){switch(U){case 1:case 2:case 3:case 4:case 5:break;default:U=3}var k=d;d=U;try{return P()}finally{d=k}},n.unstable_scheduleCallback=function(U,P,k){var Y=n.unstable_now();switch(typeof k=="object"&&k!==null?(k=k.delay,k=typeof k=="number"&&0<k?Y+k:Y):k=Y,U){case 1:var j=-1;break;case 2:j=250;break;case 5:j=1073741823;break;case 4:j=1e4;break;default:j=5e3}return j=k+j,U={id:u++,callback:P,priorityLevel:U,startTime:k,expirationTime:j,sortIndex:-1},k>Y?(U.sortIndex=k,e(c,U),t(l)===null&&U===t(c)&&(m?(g(x),x=-1):m=!0,W(E,k-Y))):(U.sortIndex=j,e(l,U),v||p||(v=!0,z(S))),U},n.unstable_shouldYield=N,n.unstable_wrapCallback=function(U){var P=d;return function(){var k=d;d=P;try{return U.apply(this,arguments)}finally{d=k}}}})(Nw);Iw.exports=Nw;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Fw=wt.exports,ei=Iw.exports;function ve(n){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+n,t=1;t<arguments.length;t++)e+="&args[]="+encodeURIComponent(arguments[t]);return"Minified React error #"+n+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var Uw=new Set,$c={};function Lo(n,e){nl(n,e),nl(n+"Capture",e)}function nl(n,e){for($c[n]=e,n=0;n<e.length;n++)Uw.add(e[n])}var Dr=!(typeof window=="undefined"||typeof window.document=="undefined"||typeof window.document.createElement=="undefined"),Jm=Object.prototype.hasOwnProperty,L3=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Cx={},Rx={};function P3(n){return Jm.call(Rx,n)?!0:Jm.call(Cx,n)?!1:L3.test(n)?Rx[n]=!0:(Cx[n]=!0,!1)}function D3(n,e,t,i){if(t!==null&&t.type===0)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return i?!1:t!==null?!t.acceptsBooleans:(n=n.toLowerCase().slice(0,5),n!=="data-"&&n!=="aria-");default:return!1}}function I3(n,e,t,i){if(e===null||typeof e=="undefined"||D3(n,e,t,i))return!0;if(i)return!1;if(t!==null)switch(t.type){case 3:return!e;case 4:return e===!1;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}function Dn(n,e,t,i,r,s,o){this.acceptsBooleans=e===2||e===3||e===4,this.attributeName=i,this.attributeNamespace=r,this.mustUseProperty=t,this.propertyName=n,this.type=e,this.sanitizeURL=s,this.removeEmptyString=o}var cn={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(n){cn[n]=new Dn(n,0,!1,n,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(n){var e=n[0];cn[e]=new Dn(e,1,!1,n[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(n){cn[n]=new Dn(n,2,!1,n.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(n){cn[n]=new Dn(n,2,!1,n,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(n){cn[n]=new Dn(n,3,!1,n.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(n){cn[n]=new Dn(n,3,!0,n,null,!1,!1)});["capture","download"].forEach(function(n){cn[n]=new Dn(n,4,!1,n,null,!1,!1)});["cols","rows","size","span"].forEach(function(n){cn[n]=new Dn(n,6,!1,n,null,!1,!1)});["rowSpan","start"].forEach(function(n){cn[n]=new Dn(n,5,!1,n.toLowerCase(),null,!1,!1)});var U0=/[\-:]([a-z])/g;function O0(n){return n[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(n){var e=n.replace(U0,O0);cn[e]=new Dn(e,1,!1,n,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(n){var e=n.replace(U0,O0);cn[e]=new Dn(e,1,!1,n,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(n){var e=n.replace(U0,O0);cn[e]=new Dn(e,1,!1,n,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(n){cn[n]=new Dn(n,1,!1,n.toLowerCase(),null,!1,!1)});cn.xlinkHref=new Dn("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(n){cn[n]=new Dn(n,1,!1,n.toLowerCase(),null,!0,!0)});function B0(n,e,t,i){var r=cn.hasOwnProperty(e)?cn[e]:null;(r!==null?r.type!==0:i||!(2<e.length)||e[0]!=="o"&&e[0]!=="O"||e[1]!=="n"&&e[1]!=="N")&&(I3(e,t,r,i)&&(t=null),i||r===null?P3(e)&&(t===null?n.removeAttribute(e):n.setAttribute(e,""+t)):r.mustUseProperty?n[r.propertyName]=t===null?r.type===3?!1:"":t:(e=r.attributeName,i=r.attributeNamespace,t===null?n.removeAttribute(e):(r=r.type,t=r===3||r===4&&t===!0?"":""+t,i?n.setAttributeNS(i,e,t):n.setAttribute(e,t))))}var Or=Fw.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,lh=Symbol.for("react.element"),Sa=Symbol.for("react.portal"),wa=Symbol.for("react.fragment"),z0=Symbol.for("react.strict_mode"),Qm=Symbol.for("react.profiler"),Ow=Symbol.for("react.provider"),Bw=Symbol.for("react.context"),k0=Symbol.for("react.forward_ref"),eg=Symbol.for("react.suspense"),tg=Symbol.for("react.suspense_list"),H0=Symbol.for("react.memo"),ns=Symbol.for("react.lazy"),zw=Symbol.for("react.offscreen"),Lx=Symbol.iterator;function Xl(n){return n===null||typeof n!="object"?null:(n=Lx&&n[Lx]||n["@@iterator"],typeof n=="function"?n:null)}var At=Object.assign,yp;function hc(n){if(yp===void 0)try{throw Error()}catch(t){var e=t.stack.trim().match(/\n( *(at )?)/);yp=e&&e[1]||""}return`
`+yp+n}var Mp=!1;function Sp(n,e){if(!n||Mp)return"";Mp=!0;var t=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(e,[])}catch(c){var i=c}Reflect.construct(n,[],e)}else{try{e.call()}catch(c){i=c}n.call(e.prototype)}else{try{throw Error()}catch(c){i=c}n()}}catch(c){if(c&&i&&typeof c.stack=="string"){for(var r=c.stack.split(`
`),s=i.stack.split(`
`),o=r.length-1,a=s.length-1;1<=o&&0<=a&&r[o]!==s[a];)a--;for(;1<=o&&0<=a;o--,a--)if(r[o]!==s[a]){if(o!==1||a!==1)do if(o--,a--,0>a||r[o]!==s[a]){var l=`
`+r[o].replace(" at new "," at ");return n.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",n.displayName)),l}while(1<=o&&0<=a);break}}}finally{Mp=!1,Error.prepareStackTrace=t}return(n=n?n.displayName||n.name:"")?hc(n):""}function N3(n){switch(n.tag){case 5:return hc(n.type);case 16:return hc("Lazy");case 13:return hc("Suspense");case 19:return hc("SuspenseList");case 0:case 2:case 15:return n=Sp(n.type,!1),n;case 11:return n=Sp(n.type.render,!1),n;case 1:return n=Sp(n.type,!0),n;default:return""}}function ng(n){if(n==null)return null;if(typeof n=="function")return n.displayName||n.name||null;if(typeof n=="string")return n;switch(n){case wa:return"Fragment";case Sa:return"Portal";case Qm:return"Profiler";case z0:return"StrictMode";case eg:return"Suspense";case tg:return"SuspenseList"}if(typeof n=="object")switch(n.$$typeof){case Bw:return(n.displayName||"Context")+".Consumer";case Ow:return(n._context.displayName||"Context")+".Provider";case k0:var e=n.render;return n=n.displayName,n||(n=e.displayName||e.name||"",n=n!==""?"ForwardRef("+n+")":"ForwardRef"),n;case H0:return e=n.displayName||null,e!==null?e:ng(n.type)||"Memo";case ns:e=n._payload,n=n._init;try{return ng(n(e))}catch{}}return null}function F3(n){var e=n.type;switch(n.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return n=e.render,n=n.displayName||n.name||"",e.displayName||(n!==""?"ForwardRef("+n+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return ng(e);case 8:return e===z0?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e}return null}function As(n){switch(typeof n){case"boolean":case"number":case"string":case"undefined":return n;case"object":return n;default:return""}}function kw(n){var e=n.type;return(n=n.nodeName)&&n.toLowerCase()==="input"&&(e==="checkbox"||e==="radio")}function U3(n){var e=kw(n)?"checked":"value",t=Object.getOwnPropertyDescriptor(n.constructor.prototype,e),i=""+n[e];if(!n.hasOwnProperty(e)&&typeof t!="undefined"&&typeof t.get=="function"&&typeof t.set=="function"){var r=t.get,s=t.set;return Object.defineProperty(n,e,{configurable:!0,get:function(){return r.call(this)},set:function(o){i=""+o,s.call(this,o)}}),Object.defineProperty(n,e,{enumerable:t.enumerable}),{getValue:function(){return i},setValue:function(o){i=""+o},stopTracking:function(){n._valueTracker=null,delete n[e]}}}}function ch(n){n._valueTracker||(n._valueTracker=U3(n))}function Hw(n){if(!n)return!1;var e=n._valueTracker;if(!e)return!0;var t=e.getValue(),i="";return n&&(i=kw(n)?n.checked?"true":"false":n.value),n=i,n!==t?(e.setValue(n),!0):!1}function gd(n){if(n=n||(typeof document!="undefined"?document:void 0),typeof n=="undefined")return null;try{return n.activeElement||n.body}catch{return n.body}}function ig(n,e){var t=e.checked;return At({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:t!=null?t:n._wrapperState.initialChecked})}function Px(n,e){var t=e.defaultValue==null?"":e.defaultValue,i=e.checked!=null?e.checked:e.defaultChecked;t=As(e.value!=null?e.value:t),n._wrapperState={initialChecked:i,initialValue:t,controlled:e.type==="checkbox"||e.type==="radio"?e.checked!=null:e.value!=null}}function Gw(n,e){e=e.checked,e!=null&&B0(n,"checked",e,!1)}function rg(n,e){Gw(n,e);var t=As(e.value),i=e.type;if(t!=null)i==="number"?(t===0&&n.value===""||n.value!=t)&&(n.value=""+t):n.value!==""+t&&(n.value=""+t);else if(i==="submit"||i==="reset"){n.removeAttribute("value");return}e.hasOwnProperty("value")?sg(n,e.type,t):e.hasOwnProperty("defaultValue")&&sg(n,e.type,As(e.defaultValue)),e.checked==null&&e.defaultChecked!=null&&(n.defaultChecked=!!e.defaultChecked)}function Dx(n,e,t){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var i=e.type;if(!(i!=="submit"&&i!=="reset"||e.value!==void 0&&e.value!==null))return;e=""+n._wrapperState.initialValue,t||e===n.value||(n.value=e),n.defaultValue=e}t=n.name,t!==""&&(n.name=""),n.defaultChecked=!!n._wrapperState.initialChecked,t!==""&&(n.name=t)}function sg(n,e,t){(e!=="number"||gd(n.ownerDocument)!==n)&&(t==null?n.defaultValue=""+n._wrapperState.initialValue:n.defaultValue!==""+t&&(n.defaultValue=""+t))}var dc=Array.isArray;function Oa(n,e,t,i){if(n=n.options,e){e={};for(var r=0;r<t.length;r++)e["$"+t[r]]=!0;for(t=0;t<n.length;t++)r=e.hasOwnProperty("$"+n[t].value),n[t].selected!==r&&(n[t].selected=r),r&&i&&(n[t].defaultSelected=!0)}else{for(t=""+As(t),e=null,r=0;r<n.length;r++){if(n[r].value===t){n[r].selected=!0,i&&(n[r].defaultSelected=!0);return}e!==null||n[r].disabled||(e=n[r])}e!==null&&(e.selected=!0)}}function og(n,e){if(e.dangerouslySetInnerHTML!=null)throw Error(ve(91));return At({},e,{value:void 0,defaultValue:void 0,children:""+n._wrapperState.initialValue})}function Ix(n,e){var t=e.value;if(t==null){if(t=e.children,e=e.defaultValue,t!=null){if(e!=null)throw Error(ve(92));if(dc(t)){if(1<t.length)throw Error(ve(93));t=t[0]}e=t}e==null&&(e=""),t=e}n._wrapperState={initialValue:As(t)}}function Vw(n,e){var t=As(e.value),i=As(e.defaultValue);t!=null&&(t=""+t,t!==n.value&&(n.value=t),e.defaultValue==null&&n.defaultValue!==t&&(n.defaultValue=t)),i!=null&&(n.defaultValue=""+i)}function Nx(n){var e=n.textContent;e===n._wrapperState.initialValue&&e!==""&&e!==null&&(n.value=e)}function Ww(n){switch(n){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function ag(n,e){return n==null||n==="http://www.w3.org/1999/xhtml"?Ww(e):n==="http://www.w3.org/2000/svg"&&e==="foreignObject"?"http://www.w3.org/1999/xhtml":n}var uh,$w=function(n){return typeof MSApp!="undefined"&&MSApp.execUnsafeLocalFunction?function(e,t,i,r){MSApp.execUnsafeLocalFunction(function(){return n(e,t,i,r)})}:n}(function(n,e){if(n.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in n)n.innerHTML=e;else{for(uh=uh||document.createElement("div"),uh.innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=uh.firstChild;n.firstChild;)n.removeChild(n.firstChild);for(;e.firstChild;)n.appendChild(e.firstChild)}});function Xc(n,e){if(e){var t=n.firstChild;if(t&&t===n.lastChild&&t.nodeType===3){t.nodeValue=e;return}}n.textContent=e}var bc={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},O3=["Webkit","ms","Moz","O"];Object.keys(bc).forEach(function(n){O3.forEach(function(e){e=e+n.charAt(0).toUpperCase()+n.substring(1),bc[e]=bc[n]})});function Xw(n,e,t){return e==null||typeof e=="boolean"||e===""?"":t||typeof e!="number"||e===0||bc.hasOwnProperty(n)&&bc[n]?(""+e).trim():e+"px"}function jw(n,e){n=n.style;for(var t in e)if(e.hasOwnProperty(t)){var i=t.indexOf("--")===0,r=Xw(t,e[t],i);t==="float"&&(t="cssFloat"),i?n.setProperty(t,r):n[t]=r}}var B3=At({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function lg(n,e){if(e){if(B3[n]&&(e.children!=null||e.dangerouslySetInnerHTML!=null))throw Error(ve(137,n));if(e.dangerouslySetInnerHTML!=null){if(e.children!=null)throw Error(ve(60));if(typeof e.dangerouslySetInnerHTML!="object"||!("__html"in e.dangerouslySetInnerHTML))throw Error(ve(61))}if(e.style!=null&&typeof e.style!="object")throw Error(ve(62))}}function cg(n,e){if(n.indexOf("-")===-1)return typeof e.is=="string";switch(n){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var ug=null;function G0(n){return n=n.target||n.srcElement||window,n.correspondingUseElement&&(n=n.correspondingUseElement),n.nodeType===3?n.parentNode:n}var hg=null,Ba=null,za=null;function Fx(n){if(n=wu(n)){if(typeof hg!="function")throw Error(ve(280));var e=n.stateNode;e&&(e=lf(e),hg(n.stateNode,n.type,e))}}function qw(n){Ba?za?za.push(n):za=[n]:Ba=n}function Yw(){if(Ba){var n=Ba,e=za;if(za=Ba=null,Fx(n),e)for(n=0;n<e.length;n++)Fx(e[n])}}function Kw(n,e){return n(e)}function Zw(){}var wp=!1;function Jw(n,e,t){if(wp)return n(e,t);wp=!0;try{return Kw(n,e,t)}finally{wp=!1,(Ba!==null||za!==null)&&(Zw(),Yw())}}function jc(n,e){var t=n.stateNode;if(t===null)return null;var i=lf(t);if(i===null)return null;t=i[e];e:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(i=!i.disabled)||(n=n.type,i=!(n==="button"||n==="input"||n==="select"||n==="textarea")),n=!i;break e;default:n=!1}if(n)return null;if(t&&typeof t!="function")throw Error(ve(231,e,typeof t));return t}var dg=!1;if(Dr)try{var jl={};Object.defineProperty(jl,"passive",{get:function(){dg=!0}}),window.addEventListener("test",jl,jl),window.removeEventListener("test",jl,jl)}catch{dg=!1}function z3(n,e,t,i,r,s,o,a,l){var c=Array.prototype.slice.call(arguments,3);try{e.apply(t,c)}catch(u){this.onError(u)}}var Tc=!1,vd=null,_d=!1,fg=null,k3={onError:function(n){Tc=!0,vd=n}};function H3(n,e,t,i,r,s,o,a,l){Tc=!1,vd=null,z3.apply(k3,arguments)}function G3(n,e,t,i,r,s,o,a,l){if(H3.apply(this,arguments),Tc){if(Tc){var c=vd;Tc=!1,vd=null}else throw Error(ve(198));_d||(_d=!0,fg=c)}}function Po(n){var e=n,t=n;if(n.alternate)for(;e.return;)e=e.return;else{n=e;do e=n,(e.flags&4098)!==0&&(t=e.return),n=e.return;while(n)}return e.tag===3?t:null}function Qw(n){if(n.tag===13){var e=n.memoizedState;if(e===null&&(n=n.alternate,n!==null&&(e=n.memoizedState)),e!==null)return e.dehydrated}return null}function Ux(n){if(Po(n)!==n)throw Error(ve(188))}function V3(n){var e=n.alternate;if(!e){if(e=Po(n),e===null)throw Error(ve(188));return e!==n?null:n}for(var t=n,i=e;;){var r=t.return;if(r===null)break;var s=r.alternate;if(s===null){if(i=r.return,i!==null){t=i;continue}break}if(r.child===s.child){for(s=r.child;s;){if(s===t)return Ux(r),n;if(s===i)return Ux(r),e;s=s.sibling}throw Error(ve(188))}if(t.return!==i.return)t=r,i=s;else{for(var o=!1,a=r.child;a;){if(a===t){o=!0,t=r,i=s;break}if(a===i){o=!0,i=r,t=s;break}a=a.sibling}if(!o){for(a=s.child;a;){if(a===t){o=!0,t=s,i=r;break}if(a===i){o=!0,i=s,t=r;break}a=a.sibling}if(!o)throw Error(ve(189))}}if(t.alternate!==i)throw Error(ve(190))}if(t.tag!==3)throw Error(ve(188));return t.stateNode.current===t?n:e}function eE(n){return n=V3(n),n!==null?tE(n):null}function tE(n){if(n.tag===5||n.tag===6)return n;for(n=n.child;n!==null;){var e=tE(n);if(e!==null)return e;n=n.sibling}return null}var nE=ei.unstable_scheduleCallback,Ox=ei.unstable_cancelCallback,W3=ei.unstable_shouldYield,$3=ei.unstable_requestPaint,Ft=ei.unstable_now,X3=ei.unstable_getCurrentPriorityLevel,V0=ei.unstable_ImmediatePriority,iE=ei.unstable_UserBlockingPriority,xd=ei.unstable_NormalPriority,j3=ei.unstable_LowPriority,rE=ei.unstable_IdlePriority,rf=null,Qi=null;function q3(n){if(Qi&&typeof Qi.onCommitFiberRoot=="function")try{Qi.onCommitFiberRoot(rf,n,void 0,(n.current.flags&128)===128)}catch{}}var zi=Math.clz32?Math.clz32:Z3,Y3=Math.log,K3=Math.LN2;function Z3(n){return n>>>=0,n===0?32:31-(Y3(n)/K3|0)|0}var hh=64,dh=4194304;function fc(n){switch(n&-n){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return n&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return n&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return n}}function yd(n,e){var t=n.pendingLanes;if(t===0)return 0;var i=0,r=n.suspendedLanes,s=n.pingedLanes,o=t&268435455;if(o!==0){var a=o&~r;a!==0?i=fc(a):(s&=o,s!==0&&(i=fc(s)))}else o=t&~r,o!==0?i=fc(o):s!==0&&(i=fc(s));if(i===0)return 0;if(e!==0&&e!==i&&(e&r)===0&&(r=i&-i,s=e&-e,r>=s||r===16&&(s&4194240)!==0))return e;if((i&4)!==0&&(i|=t&16),e=n.entangledLanes,e!==0)for(n=n.entanglements,e&=i;0<e;)t=31-zi(e),r=1<<t,i|=n[t],e&=~r;return i}function J3(n,e){switch(n){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Q3(n,e){for(var t=n.suspendedLanes,i=n.pingedLanes,r=n.expirationTimes,s=n.pendingLanes;0<s;){var o=31-zi(s),a=1<<o,l=r[o];l===-1?((a&t)===0||(a&i)!==0)&&(r[o]=J3(a,e)):l<=e&&(n.expiredLanes|=a),s&=~a}}function pg(n){return n=n.pendingLanes&-1073741825,n!==0?n:n&1073741824?1073741824:0}function sE(){var n=hh;return hh<<=1,(hh&4194240)===0&&(hh=64),n}function Ep(n){for(var e=[],t=0;31>t;t++)e.push(n);return e}function Mu(n,e,t){n.pendingLanes|=e,e!==536870912&&(n.suspendedLanes=0,n.pingedLanes=0),n=n.eventTimes,e=31-zi(e),n[e]=t}function eD(n,e){var t=n.pendingLanes&~e;n.pendingLanes=e,n.suspendedLanes=0,n.pingedLanes=0,n.expiredLanes&=e,n.mutableReadLanes&=e,n.entangledLanes&=e,e=n.entanglements;var i=n.eventTimes;for(n=n.expirationTimes;0<t;){var r=31-zi(t),s=1<<r;e[r]=0,i[r]=-1,n[r]=-1,t&=~s}}function W0(n,e){var t=n.entangledLanes|=e;for(n=n.entanglements;t;){var i=31-zi(t),r=1<<i;r&e|n[i]&e&&(n[i]|=e),t&=~r}}var ct=0;function oE(n){return n&=-n,1<n?4<n?(n&268435455)!==0?16:536870912:4:1}var aE,$0,lE,cE,uE,mg=!1,fh=[],ms=null,gs=null,vs=null,qc=new Map,Yc=new Map,os=[],tD="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Bx(n,e){switch(n){case"focusin":case"focusout":ms=null;break;case"dragenter":case"dragleave":gs=null;break;case"mouseover":case"mouseout":vs=null;break;case"pointerover":case"pointerout":qc.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":Yc.delete(e.pointerId)}}function ql(n,e,t,i,r,s){return n===null||n.nativeEvent!==s?(n={blockedOn:e,domEventName:t,eventSystemFlags:i,nativeEvent:s,targetContainers:[r]},e!==null&&(e=wu(e),e!==null&&$0(e)),n):(n.eventSystemFlags|=i,e=n.targetContainers,r!==null&&e.indexOf(r)===-1&&e.push(r),n)}function nD(n,e,t,i,r){switch(e){case"focusin":return ms=ql(ms,n,e,t,i,r),!0;case"dragenter":return gs=ql(gs,n,e,t,i,r),!0;case"mouseover":return vs=ql(vs,n,e,t,i,r),!0;case"pointerover":var s=r.pointerId;return qc.set(s,ql(qc.get(s)||null,n,e,t,i,r)),!0;case"gotpointercapture":return s=r.pointerId,Yc.set(s,ql(Yc.get(s)||null,n,e,t,i,r)),!0}return!1}function hE(n){var e=to(n.target);if(e!==null){var t=Po(e);if(t!==null){if(e=t.tag,e===13){if(e=Qw(t),e!==null){n.blockedOn=e,uE(n.priority,function(){lE(t)});return}}else if(e===3&&t.stateNode.current.memoizedState.isDehydrated){n.blockedOn=t.tag===3?t.stateNode.containerInfo:null;return}}}n.blockedOn=null}function Kh(n){if(n.blockedOn!==null)return!1;for(var e=n.targetContainers;0<e.length;){var t=gg(n.domEventName,n.eventSystemFlags,e[0],n.nativeEvent);if(t===null){t=n.nativeEvent;var i=new t.constructor(t.type,t);ug=i,t.target.dispatchEvent(i),ug=null}else return e=wu(t),e!==null&&$0(e),n.blockedOn=t,!1;e.shift()}return!0}function zx(n,e,t){Kh(n)&&t.delete(e)}function iD(){mg=!1,ms!==null&&Kh(ms)&&(ms=null),gs!==null&&Kh(gs)&&(gs=null),vs!==null&&Kh(vs)&&(vs=null),qc.forEach(zx),Yc.forEach(zx)}function Yl(n,e){n.blockedOn===e&&(n.blockedOn=null,mg||(mg=!0,ei.unstable_scheduleCallback(ei.unstable_NormalPriority,iD)))}function Kc(n){function e(r){return Yl(r,n)}if(0<fh.length){Yl(fh[0],n);for(var t=1;t<fh.length;t++){var i=fh[t];i.blockedOn===n&&(i.blockedOn=null)}}for(ms!==null&&Yl(ms,n),gs!==null&&Yl(gs,n),vs!==null&&Yl(vs,n),qc.forEach(e),Yc.forEach(e),t=0;t<os.length;t++)i=os[t],i.blockedOn===n&&(i.blockedOn=null);for(;0<os.length&&(t=os[0],t.blockedOn===null);)hE(t),t.blockedOn===null&&os.shift()}var ka=Or.ReactCurrentBatchConfig,Md=!0;function rD(n,e,t,i){var r=ct,s=ka.transition;ka.transition=null;try{ct=1,X0(n,e,t,i)}finally{ct=r,ka.transition=s}}function sD(n,e,t,i){var r=ct,s=ka.transition;ka.transition=null;try{ct=4,X0(n,e,t,i)}finally{ct=r,ka.transition=s}}function X0(n,e,t,i){if(Md){var r=gg(n,e,t,i);if(r===null)Np(n,e,i,Sd,t),Bx(n,i);else if(nD(r,n,e,t,i))i.stopPropagation();else if(Bx(n,i),e&4&&-1<tD.indexOf(n)){for(;r!==null;){var s=wu(r);if(s!==null&&aE(s),s=gg(n,e,t,i),s===null&&Np(n,e,i,Sd,t),s===r)break;r=s}r!==null&&i.stopPropagation()}else Np(n,e,i,null,t)}}var Sd=null;function gg(n,e,t,i){if(Sd=null,n=G0(i),n=to(n),n!==null)if(e=Po(n),e===null)n=null;else if(t=e.tag,t===13){if(n=Qw(e),n!==null)return n;n=null}else if(t===3){if(e.stateNode.current.memoizedState.isDehydrated)return e.tag===3?e.stateNode.containerInfo:null;n=null}else e!==n&&(n=null);return Sd=n,null}function dE(n){switch(n){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(X3()){case V0:return 1;case iE:return 4;case xd:case j3:return 16;case rE:return 536870912;default:return 16}default:return 16}}var cs=null,j0=null,Zh=null;function fE(){if(Zh)return Zh;var n,e=j0,t=e.length,i,r="value"in cs?cs.value:cs.textContent,s=r.length;for(n=0;n<t&&e[n]===r[n];n++);var o=t-n;for(i=1;i<=o&&e[t-i]===r[s-i];i++);return Zh=r.slice(n,1<i?1-i:void 0)}function Jh(n){var e=n.keyCode;return"charCode"in n?(n=n.charCode,n===0&&e===13&&(n=13)):n=e,n===10&&(n=13),32<=n||n===13?n:0}function ph(){return!0}function kx(){return!1}function ni(n){function e(t,i,r,s,o){this._reactName=t,this._targetInst=r,this.type=i,this.nativeEvent=s,this.target=o,this.currentTarget=null;for(var a in n)n.hasOwnProperty(a)&&(t=n[a],this[a]=t?t(s):s[a]);return this.isDefaultPrevented=(s.defaultPrevented!=null?s.defaultPrevented:s.returnValue===!1)?ph:kx,this.isPropagationStopped=kx,this}return At(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var t=this.nativeEvent;t&&(t.preventDefault?t.preventDefault():typeof t.returnValue!="unknown"&&(t.returnValue=!1),this.isDefaultPrevented=ph)},stopPropagation:function(){var t=this.nativeEvent;t&&(t.stopPropagation?t.stopPropagation():typeof t.cancelBubble!="unknown"&&(t.cancelBubble=!0),this.isPropagationStopped=ph)},persist:function(){},isPersistent:ph}),e}var Al={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(n){return n.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},q0=ni(Al),Su=At({},Al,{view:0,detail:0}),oD=ni(Su),bp,Tp,Kl,sf=At({},Su,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Y0,button:0,buttons:0,relatedTarget:function(n){return n.relatedTarget===void 0?n.fromElement===n.srcElement?n.toElement:n.fromElement:n.relatedTarget},movementX:function(n){return"movementX"in n?n.movementX:(n!==Kl&&(Kl&&n.type==="mousemove"?(bp=n.screenX-Kl.screenX,Tp=n.screenY-Kl.screenY):Tp=bp=0,Kl=n),bp)},movementY:function(n){return"movementY"in n?n.movementY:Tp}}),Hx=ni(sf),aD=At({},sf,{dataTransfer:0}),lD=ni(aD),cD=At({},Su,{relatedTarget:0}),Ap=ni(cD),uD=At({},Al,{animationName:0,elapsedTime:0,pseudoElement:0}),hD=ni(uD),dD=At({},Al,{clipboardData:function(n){return"clipboardData"in n?n.clipboardData:window.clipboardData}}),fD=ni(dD),pD=At({},Al,{data:0}),Gx=ni(pD),mD={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},gD={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},vD={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function _D(n){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(n):(n=vD[n])?!!e[n]:!1}function Y0(){return _D}var xD=At({},Su,{key:function(n){if(n.key){var e=mD[n.key]||n.key;if(e!=="Unidentified")return e}return n.type==="keypress"?(n=Jh(n),n===13?"Enter":String.fromCharCode(n)):n.type==="keydown"||n.type==="keyup"?gD[n.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Y0,charCode:function(n){return n.type==="keypress"?Jh(n):0},keyCode:function(n){return n.type==="keydown"||n.type==="keyup"?n.keyCode:0},which:function(n){return n.type==="keypress"?Jh(n):n.type==="keydown"||n.type==="keyup"?n.keyCode:0}}),yD=ni(xD),MD=At({},sf,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Vx=ni(MD),SD=At({},Su,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Y0}),wD=ni(SD),ED=At({},Al,{propertyName:0,elapsedTime:0,pseudoElement:0}),bD=ni(ED),TD=At({},sf,{deltaX:function(n){return"deltaX"in n?n.deltaX:"wheelDeltaX"in n?-n.wheelDeltaX:0},deltaY:function(n){return"deltaY"in n?n.deltaY:"wheelDeltaY"in n?-n.wheelDeltaY:"wheelDelta"in n?-n.wheelDelta:0},deltaZ:0,deltaMode:0}),AD=ni(TD),CD=[9,13,27,32],K0=Dr&&"CompositionEvent"in window,Ac=null;Dr&&"documentMode"in document&&(Ac=document.documentMode);var RD=Dr&&"TextEvent"in window&&!Ac,pE=Dr&&(!K0||Ac&&8<Ac&&11>=Ac),Wx=String.fromCharCode(32),$x=!1;function mE(n,e){switch(n){case"keyup":return CD.indexOf(e.keyCode)!==-1;case"keydown":return e.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function gE(n){return n=n.detail,typeof n=="object"&&"data"in n?n.data:null}var Ea=!1;function LD(n,e){switch(n){case"compositionend":return gE(e);case"keypress":return e.which!==32?null:($x=!0,Wx);case"textInput":return n=e.data,n===Wx&&$x?null:n;default:return null}}function PD(n,e){if(Ea)return n==="compositionend"||!K0&&mE(n,e)?(n=fE(),Zh=j0=cs=null,Ea=!1,n):null;switch(n){case"paste":return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return pE&&e.locale!=="ko"?null:e.data;default:return null}}var DD={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Xx(n){var e=n&&n.nodeName&&n.nodeName.toLowerCase();return e==="input"?!!DD[n.type]:e==="textarea"}function vE(n,e,t,i){qw(i),e=wd(e,"onChange"),0<e.length&&(t=new q0("onChange","change",null,t,i),n.push({event:t,listeners:e}))}var Cc=null,Zc=null;function ID(n){CE(n,0)}function of(n){var e=Aa(n);if(Hw(e))return n}function ND(n,e){if(n==="change")return e}var _E=!1;if(Dr){var Cp;if(Dr){var Rp="oninput"in document;if(!Rp){var jx=document.createElement("div");jx.setAttribute("oninput","return;"),Rp=typeof jx.oninput=="function"}Cp=Rp}else Cp=!1;_E=Cp&&(!document.documentMode||9<document.documentMode)}function qx(){Cc&&(Cc.detachEvent("onpropertychange",xE),Zc=Cc=null)}function xE(n){if(n.propertyName==="value"&&of(Zc)){var e=[];vE(e,Zc,n,G0(n)),Jw(ID,e)}}function FD(n,e,t){n==="focusin"?(qx(),Cc=e,Zc=t,Cc.attachEvent("onpropertychange",xE)):n==="focusout"&&qx()}function UD(n){if(n==="selectionchange"||n==="keyup"||n==="keydown")return of(Zc)}function OD(n,e){if(n==="click")return of(e)}function BD(n,e){if(n==="input"||n==="change")return of(e)}function zD(n,e){return n===e&&(n!==0||1/n===1/e)||n!==n&&e!==e}var Vi=typeof Object.is=="function"?Object.is:zD;function Jc(n,e){if(Vi(n,e))return!0;if(typeof n!="object"||n===null||typeof e!="object"||e===null)return!1;var t=Object.keys(n),i=Object.keys(e);if(t.length!==i.length)return!1;for(i=0;i<t.length;i++){var r=t[i];if(!Jm.call(e,r)||!Vi(n[r],e[r]))return!1}return!0}function Yx(n){for(;n&&n.firstChild;)n=n.firstChild;return n}function Kx(n,e){var t=Yx(n);n=0;for(var i;t;){if(t.nodeType===3){if(i=n+t.textContent.length,n<=e&&i>=e)return{node:t,offset:e-n};n=i}e:{for(;t;){if(t.nextSibling){t=t.nextSibling;break e}t=t.parentNode}t=void 0}t=Yx(t)}}function yE(n,e){return n&&e?n===e?!0:n&&n.nodeType===3?!1:e&&e.nodeType===3?yE(n,e.parentNode):"contains"in n?n.contains(e):n.compareDocumentPosition?!!(n.compareDocumentPosition(e)&16):!1:!1}function ME(){for(var n=window,e=gd();e instanceof n.HTMLIFrameElement;){try{var t=typeof e.contentWindow.location.href=="string"}catch{t=!1}if(t)n=e.contentWindow;else break;e=gd(n.document)}return e}function Z0(n){var e=n&&n.nodeName&&n.nodeName.toLowerCase();return e&&(e==="input"&&(n.type==="text"||n.type==="search"||n.type==="tel"||n.type==="url"||n.type==="password")||e==="textarea"||n.contentEditable==="true")}function kD(n){var e=ME(),t=n.focusedElem,i=n.selectionRange;if(e!==t&&t&&t.ownerDocument&&yE(t.ownerDocument.documentElement,t)){if(i!==null&&Z0(t)){if(e=i.start,n=i.end,n===void 0&&(n=e),"selectionStart"in t)t.selectionStart=e,t.selectionEnd=Math.min(n,t.value.length);else if(n=(e=t.ownerDocument||document)&&e.defaultView||window,n.getSelection){n=n.getSelection();var r=t.textContent.length,s=Math.min(i.start,r);i=i.end===void 0?s:Math.min(i.end,r),!n.extend&&s>i&&(r=i,i=s,s=r),r=Kx(t,s);var o=Kx(t,i);r&&o&&(n.rangeCount!==1||n.anchorNode!==r.node||n.anchorOffset!==r.offset||n.focusNode!==o.node||n.focusOffset!==o.offset)&&(e=e.createRange(),e.setStart(r.node,r.offset),n.removeAllRanges(),s>i?(n.addRange(e),n.extend(o.node,o.offset)):(e.setEnd(o.node,o.offset),n.addRange(e)))}}for(e=[],n=t;n=n.parentNode;)n.nodeType===1&&e.push({element:n,left:n.scrollLeft,top:n.scrollTop});for(typeof t.focus=="function"&&t.focus(),t=0;t<e.length;t++)n=e[t],n.element.scrollLeft=n.left,n.element.scrollTop=n.top}}var HD=Dr&&"documentMode"in document&&11>=document.documentMode,ba=null,vg=null,Rc=null,_g=!1;function Zx(n,e,t){var i=t.window===t?t.document:t.nodeType===9?t:t.ownerDocument;_g||ba==null||ba!==gd(i)||(i=ba,"selectionStart"in i&&Z0(i)?i={start:i.selectionStart,end:i.selectionEnd}:(i=(i.ownerDocument&&i.ownerDocument.defaultView||window).getSelection(),i={anchorNode:i.anchorNode,anchorOffset:i.anchorOffset,focusNode:i.focusNode,focusOffset:i.focusOffset}),Rc&&Jc(Rc,i)||(Rc=i,i=wd(vg,"onSelect"),0<i.length&&(e=new q0("onSelect","select",null,e,t),n.push({event:e,listeners:i}),e.target=ba)))}function mh(n,e){var t={};return t[n.toLowerCase()]=e.toLowerCase(),t["Webkit"+n]="webkit"+e,t["Moz"+n]="moz"+e,t}var Ta={animationend:mh("Animation","AnimationEnd"),animationiteration:mh("Animation","AnimationIteration"),animationstart:mh("Animation","AnimationStart"),transitionend:mh("Transition","TransitionEnd")},Lp={},SE={};Dr&&(SE=document.createElement("div").style,"AnimationEvent"in window||(delete Ta.animationend.animation,delete Ta.animationiteration.animation,delete Ta.animationstart.animation),"TransitionEvent"in window||delete Ta.transitionend.transition);function af(n){if(Lp[n])return Lp[n];if(!Ta[n])return n;var e=Ta[n],t;for(t in e)if(e.hasOwnProperty(t)&&t in SE)return Lp[n]=e[t];return n}var wE=af("animationend"),EE=af("animationiteration"),bE=af("animationstart"),TE=af("transitionend"),AE=new Map,Jx="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Ds(n,e){AE.set(n,e),Lo(e,[n])}for(var Pp=0;Pp<Jx.length;Pp++){var Dp=Jx[Pp],GD=Dp.toLowerCase(),VD=Dp[0].toUpperCase()+Dp.slice(1);Ds(GD,"on"+VD)}Ds(wE,"onAnimationEnd");Ds(EE,"onAnimationIteration");Ds(bE,"onAnimationStart");Ds("dblclick","onDoubleClick");Ds("focusin","onFocus");Ds("focusout","onBlur");Ds(TE,"onTransitionEnd");nl("onMouseEnter",["mouseout","mouseover"]);nl("onMouseLeave",["mouseout","mouseover"]);nl("onPointerEnter",["pointerout","pointerover"]);nl("onPointerLeave",["pointerout","pointerover"]);Lo("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));Lo("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));Lo("onBeforeInput",["compositionend","keypress","textInput","paste"]);Lo("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));Lo("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));Lo("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var pc="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),WD=new Set("cancel close invalid load scroll toggle".split(" ").concat(pc));function Qx(n,e,t){var i=n.type||"unknown-event";n.currentTarget=t,G3(i,e,void 0,n),n.currentTarget=null}function CE(n,e){e=(e&4)!==0;for(var t=0;t<n.length;t++){var i=n[t],r=i.event;i=i.listeners;e:{var s=void 0;if(e)for(var o=i.length-1;0<=o;o--){var a=i[o],l=a.instance,c=a.currentTarget;if(a=a.listener,l!==s&&r.isPropagationStopped())break e;Qx(r,a,c),s=l}else for(o=0;o<i.length;o++){if(a=i[o],l=a.instance,c=a.currentTarget,a=a.listener,l!==s&&r.isPropagationStopped())break e;Qx(r,a,c),s=l}}}if(_d)throw n=fg,_d=!1,fg=null,n}function gt(n,e){var t=e[wg];t===void 0&&(t=e[wg]=new Set);var i=n+"__bubble";t.has(i)||(RE(e,n,2,!1),t.add(i))}function Ip(n,e,t){var i=0;e&&(i|=4),RE(t,n,i,e)}var gh="_reactListening"+Math.random().toString(36).slice(2);function Qc(n){if(!n[gh]){n[gh]=!0,Uw.forEach(function(t){t!=="selectionchange"&&(WD.has(t)||Ip(t,!1,n),Ip(t,!0,n))});var e=n.nodeType===9?n:n.ownerDocument;e===null||e[gh]||(e[gh]=!0,Ip("selectionchange",!1,e))}}function RE(n,e,t,i){switch(dE(e)){case 1:var r=rD;break;case 4:r=sD;break;default:r=X0}t=r.bind(null,e,t,n),r=void 0,!dg||e!=="touchstart"&&e!=="touchmove"&&e!=="wheel"||(r=!0),i?r!==void 0?n.addEventListener(e,t,{capture:!0,passive:r}):n.addEventListener(e,t,!0):r!==void 0?n.addEventListener(e,t,{passive:r}):n.addEventListener(e,t,!1)}function Np(n,e,t,i,r){var s=i;if((e&1)===0&&(e&2)===0&&i!==null)e:for(;;){if(i===null)return;var o=i.tag;if(o===3||o===4){var a=i.stateNode.containerInfo;if(a===r||a.nodeType===8&&a.parentNode===r)break;if(o===4)for(o=i.return;o!==null;){var l=o.tag;if((l===3||l===4)&&(l=o.stateNode.containerInfo,l===r||l.nodeType===8&&l.parentNode===r))return;o=o.return}for(;a!==null;){if(o=to(a),o===null)return;if(l=o.tag,l===5||l===6){i=s=o;continue e}a=a.parentNode}}i=i.return}Jw(function(){var c=s,u=G0(t),h=[];e:{var d=AE.get(n);if(d!==void 0){var p=q0,v=n;switch(n){case"keypress":if(Jh(t)===0)break e;case"keydown":case"keyup":p=yD;break;case"focusin":v="focus",p=Ap;break;case"focusout":v="blur",p=Ap;break;case"beforeblur":case"afterblur":p=Ap;break;case"click":if(t.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":p=Hx;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":p=lD;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":p=wD;break;case wE:case EE:case bE:p=hD;break;case TE:p=bD;break;case"scroll":p=oD;break;case"wheel":p=AD;break;case"copy":case"cut":case"paste":p=fD;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":p=Vx}var m=(e&4)!==0,f=!m&&n==="scroll",g=m?d!==null?d+"Capture":null:d;m=[];for(var _=c,M;_!==null;){M=_;var E=M.stateNode;if(M.tag===5&&E!==null&&(M=E,g!==null&&(E=jc(_,g),E!=null&&m.push(eu(_,E,M)))),f)break;_=_.return}0<m.length&&(d=new p(d,v,null,t,u),h.push({event:d,listeners:m}))}}if((e&7)===0){e:{if(d=n==="mouseover"||n==="pointerover",p=n==="mouseout"||n==="pointerout",d&&t!==ug&&(v=t.relatedTarget||t.fromElement)&&(to(v)||v[Ir]))break e;if((p||d)&&(d=u.window===u?u:(d=u.ownerDocument)?d.defaultView||d.parentWindow:window,p?(v=t.relatedTarget||t.toElement,p=c,v=v?to(v):null,v!==null&&(f=Po(v),v!==f||v.tag!==5&&v.tag!==6)&&(v=null)):(p=null,v=c),p!==v)){if(m=Hx,E="onMouseLeave",g="onMouseEnter",_="mouse",(n==="pointerout"||n==="pointerover")&&(m=Vx,E="onPointerLeave",g="onPointerEnter",_="pointer"),f=p==null?d:Aa(p),M=v==null?d:Aa(v),d=new m(E,_+"leave",p,t,u),d.target=f,d.relatedTarget=M,E=null,to(u)===c&&(m=new m(g,_+"enter",v,t,u),m.target=M,m.relatedTarget=f,E=m),f=E,p&&v)t:{for(m=p,g=v,_=0,M=m;M;M=Zo(M))_++;for(M=0,E=g;E;E=Zo(E))M++;for(;0<_-M;)m=Zo(m),_--;for(;0<M-_;)g=Zo(g),M--;for(;_--;){if(m===g||g!==null&&m===g.alternate)break t;m=Zo(m),g=Zo(g)}m=null}else m=null;p!==null&&ey(h,d,p,m,!1),v!==null&&f!==null&&ey(h,f,v,m,!0)}}e:{if(d=c?Aa(c):window,p=d.nodeName&&d.nodeName.toLowerCase(),p==="select"||p==="input"&&d.type==="file")var S=ND;else if(Xx(d))if(_E)S=BD;else{S=UD;var T=FD}else(p=d.nodeName)&&p.toLowerCase()==="input"&&(d.type==="checkbox"||d.type==="radio")&&(S=OD);if(S&&(S=S(n,c))){vE(h,S,t,u);break e}T&&T(n,d,c),n==="focusout"&&(T=d._wrapperState)&&T.controlled&&d.type==="number"&&sg(d,"number",d.value)}switch(T=c?Aa(c):window,n){case"focusin":(Xx(T)||T.contentEditable==="true")&&(ba=T,vg=c,Rc=null);break;case"focusout":Rc=vg=ba=null;break;case"mousedown":_g=!0;break;case"contextmenu":case"mouseup":case"dragend":_g=!1,Zx(h,t,u);break;case"selectionchange":if(HD)break;case"keydown":case"keyup":Zx(h,t,u)}var R;if(K0)e:{switch(n){case"compositionstart":var x="onCompositionStart";break e;case"compositionend":x="onCompositionEnd";break e;case"compositionupdate":x="onCompositionUpdate";break e}x=void 0}else Ea?mE(n,t)&&(x="onCompositionEnd"):n==="keydown"&&t.keyCode===229&&(x="onCompositionStart");x&&(pE&&t.locale!=="ko"&&(Ea||x!=="onCompositionStart"?x==="onCompositionEnd"&&Ea&&(R=fE()):(cs=u,j0="value"in cs?cs.value:cs.textContent,Ea=!0)),T=wd(c,x),0<T.length&&(x=new Gx(x,n,null,t,u),h.push({event:x,listeners:T}),R?x.data=R:(R=gE(t),R!==null&&(x.data=R)))),(R=RD?LD(n,t):PD(n,t))&&(c=wd(c,"onBeforeInput"),0<c.length&&(u=new Gx("onBeforeInput","beforeinput",null,t,u),h.push({event:u,listeners:c}),u.data=R))}CE(h,e)})}function eu(n,e,t){return{instance:n,listener:e,currentTarget:t}}function wd(n,e){for(var t=e+"Capture",i=[];n!==null;){var r=n,s=r.stateNode;r.tag===5&&s!==null&&(r=s,s=jc(n,t),s!=null&&i.unshift(eu(n,s,r)),s=jc(n,e),s!=null&&i.push(eu(n,s,r))),n=n.return}return i}function Zo(n){if(n===null)return null;do n=n.return;while(n&&n.tag!==5);return n||null}function ey(n,e,t,i,r){for(var s=e._reactName,o=[];t!==null&&t!==i;){var a=t,l=a.alternate,c=a.stateNode;if(l!==null&&l===i)break;a.tag===5&&c!==null&&(a=c,r?(l=jc(t,s),l!=null&&o.unshift(eu(t,l,a))):r||(l=jc(t,s),l!=null&&o.push(eu(t,l,a)))),t=t.return}o.length!==0&&n.push({event:e,listeners:o})}var $D=/\r\n?/g,XD=/\u0000|\uFFFD/g;function ty(n){return(typeof n=="string"?n:""+n).replace($D,`
`).replace(XD,"")}function vh(n,e,t){if(e=ty(e),ty(n)!==e&&t)throw Error(ve(425))}function Ed(){}var xg=null,yg=null;function Mg(n,e){return n==="textarea"||n==="noscript"||typeof e.children=="string"||typeof e.children=="number"||typeof e.dangerouslySetInnerHTML=="object"&&e.dangerouslySetInnerHTML!==null&&e.dangerouslySetInnerHTML.__html!=null}var Sg=typeof setTimeout=="function"?setTimeout:void 0,jD=typeof clearTimeout=="function"?clearTimeout:void 0,ny=typeof Promise=="function"?Promise:void 0,qD=typeof queueMicrotask=="function"?queueMicrotask:typeof ny!="undefined"?function(n){return ny.resolve(null).then(n).catch(YD)}:Sg;function YD(n){setTimeout(function(){throw n})}function Fp(n,e){var t=e,i=0;do{var r=t.nextSibling;if(n.removeChild(t),r&&r.nodeType===8)if(t=r.data,t==="/$"){if(i===0){n.removeChild(r),Kc(e);return}i--}else t!=="$"&&t!=="$?"&&t!=="$!"||i++;t=r}while(t);Kc(e)}function _s(n){for(;n!=null;n=n.nextSibling){var e=n.nodeType;if(e===1||e===3)break;if(e===8){if(e=n.data,e==="$"||e==="$!"||e==="$?")break;if(e==="/$")return null}}return n}function iy(n){n=n.previousSibling;for(var e=0;n;){if(n.nodeType===8){var t=n.data;if(t==="$"||t==="$!"||t==="$?"){if(e===0)return n;e--}else t==="/$"&&e++}n=n.previousSibling}return null}var Cl=Math.random().toString(36).slice(2),Zi="__reactFiber$"+Cl,tu="__reactProps$"+Cl,Ir="__reactContainer$"+Cl,wg="__reactEvents$"+Cl,KD="__reactListeners$"+Cl,ZD="__reactHandles$"+Cl;function to(n){var e=n[Zi];if(e)return e;for(var t=n.parentNode;t;){if(e=t[Ir]||t[Zi]){if(t=e.alternate,e.child!==null||t!==null&&t.child!==null)for(n=iy(n);n!==null;){if(t=n[Zi])return t;n=iy(n)}return e}n=t,t=n.parentNode}return null}function wu(n){return n=n[Zi]||n[Ir],!n||n.tag!==5&&n.tag!==6&&n.tag!==13&&n.tag!==3?null:n}function Aa(n){if(n.tag===5||n.tag===6)return n.stateNode;throw Error(ve(33))}function lf(n){return n[tu]||null}var Eg=[],Ca=-1;function Is(n){return{current:n}}function vt(n){0>Ca||(n.current=Eg[Ca],Eg[Ca]=null,Ca--)}function pt(n,e){Ca++,Eg[Ca]=n.current,n.current=e}var Cs={},xn=Is(Cs),On=Is(!1),vo=Cs;function il(n,e){var t=n.type.contextTypes;if(!t)return Cs;var i=n.stateNode;if(i&&i.__reactInternalMemoizedUnmaskedChildContext===e)return i.__reactInternalMemoizedMaskedChildContext;var r={},s;for(s in t)r[s]=e[s];return i&&(n=n.stateNode,n.__reactInternalMemoizedUnmaskedChildContext=e,n.__reactInternalMemoizedMaskedChildContext=r),r}function Bn(n){return n=n.childContextTypes,n!=null}function bd(){vt(On),vt(xn)}function ry(n,e,t){if(xn.current!==Cs)throw Error(ve(168));pt(xn,e),pt(On,t)}function LE(n,e,t){var i=n.stateNode;if(e=e.childContextTypes,typeof i.getChildContext!="function")return t;i=i.getChildContext();for(var r in i)if(!(r in e))throw Error(ve(108,F3(n)||"Unknown",r));return At({},t,i)}function Td(n){return n=(n=n.stateNode)&&n.__reactInternalMemoizedMergedChildContext||Cs,vo=xn.current,pt(xn,n),pt(On,On.current),!0}function sy(n,e,t){var i=n.stateNode;if(!i)throw Error(ve(169));t?(n=LE(n,e,vo),i.__reactInternalMemoizedMergedChildContext=n,vt(On),vt(xn),pt(xn,n)):vt(On),pt(On,t)}var Sr=null,cf=!1,Up=!1;function PE(n){Sr===null?Sr=[n]:Sr.push(n)}function JD(n){cf=!0,PE(n)}function Ns(){if(!Up&&Sr!==null){Up=!0;var n=0,e=ct;try{var t=Sr;for(ct=1;n<t.length;n++){var i=t[n];do i=i(!0);while(i!==null)}Sr=null,cf=!1}catch(r){throw Sr!==null&&(Sr=Sr.slice(n+1)),nE(V0,Ns),r}finally{ct=e,Up=!1}}return null}var Ra=[],La=0,Ad=null,Cd=0,oi=[],ai=0,_o=null,Er=1,br="";function js(n,e){Ra[La++]=Cd,Ra[La++]=Ad,Ad=n,Cd=e}function DE(n,e,t){oi[ai++]=Er,oi[ai++]=br,oi[ai++]=_o,_o=n;var i=Er;n=br;var r=32-zi(i)-1;i&=~(1<<r),t+=1;var s=32-zi(e)+r;if(30<s){var o=r-r%5;s=(i&(1<<o)-1).toString(32),i>>=o,r-=o,Er=1<<32-zi(e)+r|t<<r|i,br=s+n}else Er=1<<s|t<<r|i,br=n}function J0(n){n.return!==null&&(js(n,1),DE(n,1,0))}function Q0(n){for(;n===Ad;)Ad=Ra[--La],Ra[La]=null,Cd=Ra[--La],Ra[La]=null;for(;n===_o;)_o=oi[--ai],oi[ai]=null,br=oi[--ai],oi[ai]=null,Er=oi[--ai],oi[ai]=null}var Qn=null,Zn=null,xt=!1,Ii=null;function IE(n,e){var t=hi(5,null,null,0);t.elementType="DELETED",t.stateNode=e,t.return=n,e=n.deletions,e===null?(n.deletions=[t],n.flags|=16):e.push(t)}function oy(n,e){switch(n.tag){case 5:var t=n.type;return e=e.nodeType!==1||t.toLowerCase()!==e.nodeName.toLowerCase()?null:e,e!==null?(n.stateNode=e,Qn=n,Zn=_s(e.firstChild),!0):!1;case 6:return e=n.pendingProps===""||e.nodeType!==3?null:e,e!==null?(n.stateNode=e,Qn=n,Zn=null,!0):!1;case 13:return e=e.nodeType!==8?null:e,e!==null?(t=_o!==null?{id:Er,overflow:br}:null,n.memoizedState={dehydrated:e,treeContext:t,retryLane:1073741824},t=hi(18,null,null,0),t.stateNode=e,t.return=n,n.child=t,Qn=n,Zn=null,!0):!1;default:return!1}}function bg(n){return(n.mode&1)!==0&&(n.flags&128)===0}function Tg(n){if(xt){var e=Zn;if(e){var t=e;if(!oy(n,e)){if(bg(n))throw Error(ve(418));e=_s(t.nextSibling);var i=Qn;e&&oy(n,e)?IE(i,t):(n.flags=n.flags&-4097|2,xt=!1,Qn=n)}}else{if(bg(n))throw Error(ve(418));n.flags=n.flags&-4097|2,xt=!1,Qn=n}}}function ay(n){for(n=n.return;n!==null&&n.tag!==5&&n.tag!==3&&n.tag!==13;)n=n.return;Qn=n}function _h(n){if(n!==Qn)return!1;if(!xt)return ay(n),xt=!0,!1;var e;if((e=n.tag!==3)&&!(e=n.tag!==5)&&(e=n.type,e=e!=="head"&&e!=="body"&&!Mg(n.type,n.memoizedProps)),e&&(e=Zn)){if(bg(n))throw NE(),Error(ve(418));for(;e;)IE(n,e),e=_s(e.nextSibling)}if(ay(n),n.tag===13){if(n=n.memoizedState,n=n!==null?n.dehydrated:null,!n)throw Error(ve(317));e:{for(n=n.nextSibling,e=0;n;){if(n.nodeType===8){var t=n.data;if(t==="/$"){if(e===0){Zn=_s(n.nextSibling);break e}e--}else t!=="$"&&t!=="$!"&&t!=="$?"||e++}n=n.nextSibling}Zn=null}}else Zn=Qn?_s(n.stateNode.nextSibling):null;return!0}function NE(){for(var n=Zn;n;)n=_s(n.nextSibling)}function rl(){Zn=Qn=null,xt=!1}function ev(n){Ii===null?Ii=[n]:Ii.push(n)}var QD=Or.ReactCurrentBatchConfig;function Pi(n,e){if(n&&n.defaultProps){e=At({},e),n=n.defaultProps;for(var t in n)e[t]===void 0&&(e[t]=n[t]);return e}return e}var Rd=Is(null),Ld=null,Pa=null,tv=null;function nv(){tv=Pa=Ld=null}function iv(n){var e=Rd.current;vt(Rd),n._currentValue=e}function Ag(n,e,t){for(;n!==null;){var i=n.alternate;if((n.childLanes&e)!==e?(n.childLanes|=e,i!==null&&(i.childLanes|=e)):i!==null&&(i.childLanes&e)!==e&&(i.childLanes|=e),n===t)break;n=n.return}}function Ha(n,e){Ld=n,tv=Pa=null,n=n.dependencies,n!==null&&n.firstContext!==null&&((n.lanes&e)!==0&&(Un=!0),n.firstContext=null)}function gi(n){var e=n._currentValue;if(tv!==n)if(n={context:n,memoizedValue:e,next:null},Pa===null){if(Ld===null)throw Error(ve(308));Pa=n,Ld.dependencies={lanes:0,firstContext:n}}else Pa=Pa.next=n;return e}var no=null;function rv(n){no===null?no=[n]:no.push(n)}function FE(n,e,t,i){var r=e.interleaved;return r===null?(t.next=t,rv(e)):(t.next=r.next,r.next=t),e.interleaved=t,Nr(n,i)}function Nr(n,e){n.lanes|=e;var t=n.alternate;for(t!==null&&(t.lanes|=e),t=n,n=n.return;n!==null;)n.childLanes|=e,t=n.alternate,t!==null&&(t.childLanes|=e),t=n,n=n.return;return t.tag===3?t.stateNode:null}var is=!1;function sv(n){n.updateQueue={baseState:n.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function UE(n,e){n=n.updateQueue,e.updateQueue===n&&(e.updateQueue={baseState:n.baseState,firstBaseUpdate:n.firstBaseUpdate,lastBaseUpdate:n.lastBaseUpdate,shared:n.shared,effects:n.effects})}function Cr(n,e){return{eventTime:n,lane:e,tag:0,payload:null,callback:null,next:null}}function xs(n,e,t){var i=n.updateQueue;if(i===null)return null;if(i=i.shared,(tt&2)!==0){var r=i.pending;return r===null?e.next=e:(e.next=r.next,r.next=e),i.pending=e,Nr(n,t)}return r=i.interleaved,r===null?(e.next=e,rv(i)):(e.next=r.next,r.next=e),i.interleaved=e,Nr(n,t)}function Qh(n,e,t){if(e=e.updateQueue,e!==null&&(e=e.shared,(t&4194240)!==0)){var i=e.lanes;i&=n.pendingLanes,t|=i,e.lanes=t,W0(n,t)}}function ly(n,e){var t=n.updateQueue,i=n.alternate;if(i!==null&&(i=i.updateQueue,t===i)){var r=null,s=null;if(t=t.firstBaseUpdate,t!==null){do{var o={eventTime:t.eventTime,lane:t.lane,tag:t.tag,payload:t.payload,callback:t.callback,next:null};s===null?r=s=o:s=s.next=o,t=t.next}while(t!==null);s===null?r=s=e:s=s.next=e}else r=s=e;t={baseState:i.baseState,firstBaseUpdate:r,lastBaseUpdate:s,shared:i.shared,effects:i.effects},n.updateQueue=t;return}n=t.lastBaseUpdate,n===null?t.firstBaseUpdate=e:n.next=e,t.lastBaseUpdate=e}function Pd(n,e,t,i){var r=n.updateQueue;is=!1;var s=r.firstBaseUpdate,o=r.lastBaseUpdate,a=r.shared.pending;if(a!==null){r.shared.pending=null;var l=a,c=l.next;l.next=null,o===null?s=c:o.next=c,o=l;var u=n.alternate;u!==null&&(u=u.updateQueue,a=u.lastBaseUpdate,a!==o&&(a===null?u.firstBaseUpdate=c:a.next=c,u.lastBaseUpdate=l))}if(s!==null){var h=r.baseState;o=0,u=c=l=null,a=s;do{var d=a.lane,p=a.eventTime;if((i&d)===d){u!==null&&(u=u.next={eventTime:p,lane:0,tag:a.tag,payload:a.payload,callback:a.callback,next:null});e:{var v=n,m=a;switch(d=e,p=t,m.tag){case 1:if(v=m.payload,typeof v=="function"){h=v.call(p,h,d);break e}h=v;break e;case 3:v.flags=v.flags&-65537|128;case 0:if(v=m.payload,d=typeof v=="function"?v.call(p,h,d):v,d==null)break e;h=At({},h,d);break e;case 2:is=!0}}a.callback!==null&&a.lane!==0&&(n.flags|=64,d=r.effects,d===null?r.effects=[a]:d.push(a))}else p={eventTime:p,lane:d,tag:a.tag,payload:a.payload,callback:a.callback,next:null},u===null?(c=u=p,l=h):u=u.next=p,o|=d;if(a=a.next,a===null){if(a=r.shared.pending,a===null)break;d=a,a=d.next,d.next=null,r.lastBaseUpdate=d,r.shared.pending=null}}while(1);if(u===null&&(l=h),r.baseState=l,r.firstBaseUpdate=c,r.lastBaseUpdate=u,e=r.shared.interleaved,e!==null){r=e;do o|=r.lane,r=r.next;while(r!==e)}else s===null&&(r.shared.lanes=0);yo|=o,n.lanes=o,n.memoizedState=h}}function cy(n,e,t){if(n=e.effects,e.effects=null,n!==null)for(e=0;e<n.length;e++){var i=n[e],r=i.callback;if(r!==null){if(i.callback=null,i=t,typeof r!="function")throw Error(ve(191,r));r.call(i)}}}var OE=new Fw.Component().refs;function Cg(n,e,t,i){e=n.memoizedState,t=t(i,e),t=t==null?e:At({},e,t),n.memoizedState=t,n.lanes===0&&(n.updateQueue.baseState=t)}var uf={isMounted:function(n){return(n=n._reactInternals)?Po(n)===n:!1},enqueueSetState:function(n,e,t){n=n._reactInternals;var i=Tn(),r=Ms(n),s=Cr(i,r);s.payload=e,t!=null&&(s.callback=t),e=xs(n,s,r),e!==null&&(ki(e,n,r,i),Qh(e,n,r))},enqueueReplaceState:function(n,e,t){n=n._reactInternals;var i=Tn(),r=Ms(n),s=Cr(i,r);s.tag=1,s.payload=e,t!=null&&(s.callback=t),e=xs(n,s,r),e!==null&&(ki(e,n,r,i),Qh(e,n,r))},enqueueForceUpdate:function(n,e){n=n._reactInternals;var t=Tn(),i=Ms(n),r=Cr(t,i);r.tag=2,e!=null&&(r.callback=e),e=xs(n,r,i),e!==null&&(ki(e,n,i,t),Qh(e,n,i))}};function uy(n,e,t,i,r,s,o){return n=n.stateNode,typeof n.shouldComponentUpdate=="function"?n.shouldComponentUpdate(i,s,o):e.prototype&&e.prototype.isPureReactComponent?!Jc(t,i)||!Jc(r,s):!0}function BE(n,e,t){var i=!1,r=Cs,s=e.contextType;return typeof s=="object"&&s!==null?s=gi(s):(r=Bn(e)?vo:xn.current,i=e.contextTypes,s=(i=i!=null)?il(n,r):Cs),e=new e(t,s),n.memoizedState=e.state!==null&&e.state!==void 0?e.state:null,e.updater=uf,n.stateNode=e,e._reactInternals=n,i&&(n=n.stateNode,n.__reactInternalMemoizedUnmaskedChildContext=r,n.__reactInternalMemoizedMaskedChildContext=s),e}function hy(n,e,t,i){n=e.state,typeof e.componentWillReceiveProps=="function"&&e.componentWillReceiveProps(t,i),typeof e.UNSAFE_componentWillReceiveProps=="function"&&e.UNSAFE_componentWillReceiveProps(t,i),e.state!==n&&uf.enqueueReplaceState(e,e.state,null)}function Rg(n,e,t,i){var r=n.stateNode;r.props=t,r.state=n.memoizedState,r.refs=OE,sv(n);var s=e.contextType;typeof s=="object"&&s!==null?r.context=gi(s):(s=Bn(e)?vo:xn.current,r.context=il(n,s)),r.state=n.memoizedState,s=e.getDerivedStateFromProps,typeof s=="function"&&(Cg(n,e,s,t),r.state=n.memoizedState),typeof e.getDerivedStateFromProps=="function"||typeof r.getSnapshotBeforeUpdate=="function"||typeof r.UNSAFE_componentWillMount!="function"&&typeof r.componentWillMount!="function"||(e=r.state,typeof r.componentWillMount=="function"&&r.componentWillMount(),typeof r.UNSAFE_componentWillMount=="function"&&r.UNSAFE_componentWillMount(),e!==r.state&&uf.enqueueReplaceState(r,r.state,null),Pd(n,t,r,i),r.state=n.memoizedState),typeof r.componentDidMount=="function"&&(n.flags|=4194308)}function Zl(n,e,t){if(n=t.ref,n!==null&&typeof n!="function"&&typeof n!="object"){if(t._owner){if(t=t._owner,t){if(t.tag!==1)throw Error(ve(309));var i=t.stateNode}if(!i)throw Error(ve(147,n));var r=i,s=""+n;return e!==null&&e.ref!==null&&typeof e.ref=="function"&&e.ref._stringRef===s?e.ref:(e=function(o){var a=r.refs;a===OE&&(a=r.refs={}),o===null?delete a[s]:a[s]=o},e._stringRef=s,e)}if(typeof n!="string")throw Error(ve(284));if(!t._owner)throw Error(ve(290,n))}return n}function xh(n,e){throw n=Object.prototype.toString.call(e),Error(ve(31,n==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":n))}function dy(n){var e=n._init;return e(n._payload)}function zE(n){function e(g,_){if(n){var M=g.deletions;M===null?(g.deletions=[_],g.flags|=16):M.push(_)}}function t(g,_){if(!n)return null;for(;_!==null;)e(g,_),_=_.sibling;return null}function i(g,_){for(g=new Map;_!==null;)_.key!==null?g.set(_.key,_):g.set(_.index,_),_=_.sibling;return g}function r(g,_){return g=Ss(g,_),g.index=0,g.sibling=null,g}function s(g,_,M){return g.index=M,n?(M=g.alternate,M!==null?(M=M.index,M<_?(g.flags|=2,_):M):(g.flags|=2,_)):(g.flags|=1048576,_)}function o(g){return n&&g.alternate===null&&(g.flags|=2),g}function a(g,_,M,E){return _===null||_.tag!==6?(_=Vp(M,g.mode,E),_.return=g,_):(_=r(_,M),_.return=g,_)}function l(g,_,M,E){var S=M.type;return S===wa?u(g,_,M.props.children,E,M.key):_!==null&&(_.elementType===S||typeof S=="object"&&S!==null&&S.$$typeof===ns&&dy(S)===_.type)?(E=r(_,M.props),E.ref=Zl(g,_,M),E.return=g,E):(E=sd(M.type,M.key,M.props,null,g.mode,E),E.ref=Zl(g,_,M),E.return=g,E)}function c(g,_,M,E){return _===null||_.tag!==4||_.stateNode.containerInfo!==M.containerInfo||_.stateNode.implementation!==M.implementation?(_=Wp(M,g.mode,E),_.return=g,_):(_=r(_,M.children||[]),_.return=g,_)}function u(g,_,M,E,S){return _===null||_.tag!==7?(_=co(M,g.mode,E,S),_.return=g,_):(_=r(_,M),_.return=g,_)}function h(g,_,M){if(typeof _=="string"&&_!==""||typeof _=="number")return _=Vp(""+_,g.mode,M),_.return=g,_;if(typeof _=="object"&&_!==null){switch(_.$$typeof){case lh:return M=sd(_.type,_.key,_.props,null,g.mode,M),M.ref=Zl(g,null,_),M.return=g,M;case Sa:return _=Wp(_,g.mode,M),_.return=g,_;case ns:var E=_._init;return h(g,E(_._payload),M)}if(dc(_)||Xl(_))return _=co(_,g.mode,M,null),_.return=g,_;xh(g,_)}return null}function d(g,_,M,E){var S=_!==null?_.key:null;if(typeof M=="string"&&M!==""||typeof M=="number")return S!==null?null:a(g,_,""+M,E);if(typeof M=="object"&&M!==null){switch(M.$$typeof){case lh:return M.key===S?l(g,_,M,E):null;case Sa:return M.key===S?c(g,_,M,E):null;case ns:return S=M._init,d(g,_,S(M._payload),E)}if(dc(M)||Xl(M))return S!==null?null:u(g,_,M,E,null);xh(g,M)}return null}function p(g,_,M,E,S){if(typeof E=="string"&&E!==""||typeof E=="number")return g=g.get(M)||null,a(_,g,""+E,S);if(typeof E=="object"&&E!==null){switch(E.$$typeof){case lh:return g=g.get(E.key===null?M:E.key)||null,l(_,g,E,S);case Sa:return g=g.get(E.key===null?M:E.key)||null,c(_,g,E,S);case ns:var T=E._init;return p(g,_,M,T(E._payload),S)}if(dc(E)||Xl(E))return g=g.get(M)||null,u(_,g,E,S,null);xh(_,E)}return null}function v(g,_,M,E){for(var S=null,T=null,R=_,x=_=0,A=null;R!==null&&x<M.length;x++){R.index>x?(A=R,R=null):A=R.sibling;var I=d(g,R,M[x],E);if(I===null){R===null&&(R=A);break}n&&R&&I.alternate===null&&e(g,R),_=s(I,_,x),T===null?S=I:T.sibling=I,T=I,R=A}if(x===M.length)return t(g,R),xt&&js(g,x),S;if(R===null){for(;x<M.length;x++)R=h(g,M[x],E),R!==null&&(_=s(R,_,x),T===null?S=R:T.sibling=R,T=R);return xt&&js(g,x),S}for(R=i(g,R);x<M.length;x++)A=p(R,g,x,M[x],E),A!==null&&(n&&A.alternate!==null&&R.delete(A.key===null?x:A.key),_=s(A,_,x),T===null?S=A:T.sibling=A,T=A);return n&&R.forEach(function(N){return e(g,N)}),xt&&js(g,x),S}function m(g,_,M,E){var S=Xl(M);if(typeof S!="function")throw Error(ve(150));if(M=S.call(M),M==null)throw Error(ve(151));for(var T=S=null,R=_,x=_=0,A=null,I=M.next();R!==null&&!I.done;x++,I=M.next()){R.index>x?(A=R,R=null):A=R.sibling;var N=d(g,R,I.value,E);if(N===null){R===null&&(R=A);break}n&&R&&N.alternate===null&&e(g,R),_=s(N,_,x),T===null?S=N:T.sibling=N,T=N,R=A}if(I.done)return t(g,R),xt&&js(g,x),S;if(R===null){for(;!I.done;x++,I=M.next())I=h(g,I.value,E),I!==null&&(_=s(I,_,x),T===null?S=I:T.sibling=I,T=I);return xt&&js(g,x),S}for(R=i(g,R);!I.done;x++,I=M.next())I=p(R,g,x,I.value,E),I!==null&&(n&&I.alternate!==null&&R.delete(I.key===null?x:I.key),_=s(I,_,x),T===null?S=I:T.sibling=I,T=I);return n&&R.forEach(function(J){return e(g,J)}),xt&&js(g,x),S}function f(g,_,M,E){if(typeof M=="object"&&M!==null&&M.type===wa&&M.key===null&&(M=M.props.children),typeof M=="object"&&M!==null){switch(M.$$typeof){case lh:e:{for(var S=M.key,T=_;T!==null;){if(T.key===S){if(S=M.type,S===wa){if(T.tag===7){t(g,T.sibling),_=r(T,M.props.children),_.return=g,g=_;break e}}else if(T.elementType===S||typeof S=="object"&&S!==null&&S.$$typeof===ns&&dy(S)===T.type){t(g,T.sibling),_=r(T,M.props),_.ref=Zl(g,T,M),_.return=g,g=_;break e}t(g,T);break}else e(g,T);T=T.sibling}M.type===wa?(_=co(M.props.children,g.mode,E,M.key),_.return=g,g=_):(E=sd(M.type,M.key,M.props,null,g.mode,E),E.ref=Zl(g,_,M),E.return=g,g=E)}return o(g);case Sa:e:{for(T=M.key;_!==null;){if(_.key===T)if(_.tag===4&&_.stateNode.containerInfo===M.containerInfo&&_.stateNode.implementation===M.implementation){t(g,_.sibling),_=r(_,M.children||[]),_.return=g,g=_;break e}else{t(g,_);break}else e(g,_);_=_.sibling}_=Wp(M,g.mode,E),_.return=g,g=_}return o(g);case ns:return T=M._init,f(g,_,T(M._payload),E)}if(dc(M))return v(g,_,M,E);if(Xl(M))return m(g,_,M,E);xh(g,M)}return typeof M=="string"&&M!==""||typeof M=="number"?(M=""+M,_!==null&&_.tag===6?(t(g,_.sibling),_=r(_,M),_.return=g,g=_):(t(g,_),_=Vp(M,g.mode,E),_.return=g,g=_),o(g)):t(g,_)}return f}var sl=zE(!0),kE=zE(!1),Eu={},er=Is(Eu),nu=Is(Eu),iu=Is(Eu);function io(n){if(n===Eu)throw Error(ve(174));return n}function ov(n,e){switch(pt(iu,e),pt(nu,n),pt(er,Eu),n=e.nodeType,n){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:ag(null,"");break;default:n=n===8?e.parentNode:e,e=n.namespaceURI||null,n=n.tagName,e=ag(e,n)}vt(er),pt(er,e)}function ol(){vt(er),vt(nu),vt(iu)}function HE(n){io(iu.current);var e=io(er.current),t=ag(e,n.type);e!==t&&(pt(nu,n),pt(er,t))}function av(n){nu.current===n&&(vt(er),vt(nu))}var Et=Is(0);function Dd(n){for(var e=n;e!==null;){if(e.tag===13){var t=e.memoizedState;if(t!==null&&(t=t.dehydrated,t===null||t.data==="$?"||t.data==="$!"))return e}else if(e.tag===19&&e.memoizedProps.revealOrder!==void 0){if((e.flags&128)!==0)return e}else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===n)break;for(;e.sibling===null;){if(e.return===null||e.return===n)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var Op=[];function lv(){for(var n=0;n<Op.length;n++)Op[n]._workInProgressVersionPrimary=null;Op.length=0}var ed=Or.ReactCurrentDispatcher,Bp=Or.ReactCurrentBatchConfig,xo=0,Tt=null,Wt=null,Kt=null,Id=!1,Lc=!1,ru=0,eI=0;function hn(){throw Error(ve(321))}function cv(n,e){if(e===null)return!1;for(var t=0;t<e.length&&t<n.length;t++)if(!Vi(n[t],e[t]))return!1;return!0}function uv(n,e,t,i,r,s){if(xo=s,Tt=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,ed.current=n===null||n.memoizedState===null?rI:sI,n=t(i,r),Lc){s=0;do{if(Lc=!1,ru=0,25<=s)throw Error(ve(301));s+=1,Kt=Wt=null,e.updateQueue=null,ed.current=oI,n=t(i,r)}while(Lc)}if(ed.current=Nd,e=Wt!==null&&Wt.next!==null,xo=0,Kt=Wt=Tt=null,Id=!1,e)throw Error(ve(300));return n}function hv(){var n=ru!==0;return ru=0,n}function qi(){var n={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Kt===null?Tt.memoizedState=Kt=n:Kt=Kt.next=n,Kt}function vi(){if(Wt===null){var n=Tt.alternate;n=n!==null?n.memoizedState:null}else n=Wt.next;var e=Kt===null?Tt.memoizedState:Kt.next;if(e!==null)Kt=e,Wt=n;else{if(n===null)throw Error(ve(310));Wt=n,n={memoizedState:Wt.memoizedState,baseState:Wt.baseState,baseQueue:Wt.baseQueue,queue:Wt.queue,next:null},Kt===null?Tt.memoizedState=Kt=n:Kt=Kt.next=n}return Kt}function su(n,e){return typeof e=="function"?e(n):e}function zp(n){var e=vi(),t=e.queue;if(t===null)throw Error(ve(311));t.lastRenderedReducer=n;var i=Wt,r=i.baseQueue,s=t.pending;if(s!==null){if(r!==null){var o=r.next;r.next=s.next,s.next=o}i.baseQueue=r=s,t.pending=null}if(r!==null){s=r.next,i=i.baseState;var a=o=null,l=null,c=s;do{var u=c.lane;if((xo&u)===u)l!==null&&(l=l.next={lane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),i=c.hasEagerState?c.eagerState:n(i,c.action);else{var h={lane:u,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null};l===null?(a=l=h,o=i):l=l.next=h,Tt.lanes|=u,yo|=u}c=c.next}while(c!==null&&c!==s);l===null?o=i:l.next=a,Vi(i,e.memoizedState)||(Un=!0),e.memoizedState=i,e.baseState=o,e.baseQueue=l,t.lastRenderedState=i}if(n=t.interleaved,n!==null){r=n;do s=r.lane,Tt.lanes|=s,yo|=s,r=r.next;while(r!==n)}else r===null&&(t.lanes=0);return[e.memoizedState,t.dispatch]}function kp(n){var e=vi(),t=e.queue;if(t===null)throw Error(ve(311));t.lastRenderedReducer=n;var i=t.dispatch,r=t.pending,s=e.memoizedState;if(r!==null){t.pending=null;var o=r=r.next;do s=n(s,o.action),o=o.next;while(o!==r);Vi(s,e.memoizedState)||(Un=!0),e.memoizedState=s,e.baseQueue===null&&(e.baseState=s),t.lastRenderedState=s}return[s,i]}function GE(){}function VE(n,e){var t=Tt,i=vi(),r=e(),s=!Vi(i.memoizedState,r);if(s&&(i.memoizedState=r,Un=!0),i=i.queue,dv(XE.bind(null,t,i,n),[n]),i.getSnapshot!==e||s||Kt!==null&&Kt.memoizedState.tag&1){if(t.flags|=2048,ou(9,$E.bind(null,t,i,r,e),void 0,null),Jt===null)throw Error(ve(349));(xo&30)!==0||WE(t,e,r)}return r}function WE(n,e,t){n.flags|=16384,n={getSnapshot:e,value:t},e=Tt.updateQueue,e===null?(e={lastEffect:null,stores:null},Tt.updateQueue=e,e.stores=[n]):(t=e.stores,t===null?e.stores=[n]:t.push(n))}function $E(n,e,t,i){e.value=t,e.getSnapshot=i,jE(e)&&qE(n)}function XE(n,e,t){return t(function(){jE(e)&&qE(n)})}function jE(n){var e=n.getSnapshot;n=n.value;try{var t=e();return!Vi(n,t)}catch{return!0}}function qE(n){var e=Nr(n,1);e!==null&&ki(e,n,1,-1)}function fy(n){var e=qi();return typeof n=="function"&&(n=n()),e.memoizedState=e.baseState=n,n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:su,lastRenderedState:n},e.queue=n,n=n.dispatch=iI.bind(null,Tt,n),[e.memoizedState,n]}function ou(n,e,t,i){return n={tag:n,create:e,destroy:t,deps:i,next:null},e=Tt.updateQueue,e===null?(e={lastEffect:null,stores:null},Tt.updateQueue=e,e.lastEffect=n.next=n):(t=e.lastEffect,t===null?e.lastEffect=n.next=n:(i=t.next,t.next=n,n.next=i,e.lastEffect=n)),n}function YE(){return vi().memoizedState}function td(n,e,t,i){var r=qi();Tt.flags|=n,r.memoizedState=ou(1|e,t,void 0,i===void 0?null:i)}function hf(n,e,t,i){var r=vi();i=i===void 0?null:i;var s=void 0;if(Wt!==null){var o=Wt.memoizedState;if(s=o.destroy,i!==null&&cv(i,o.deps)){r.memoizedState=ou(e,t,s,i);return}}Tt.flags|=n,r.memoizedState=ou(1|e,t,s,i)}function py(n,e){return td(8390656,8,n,e)}function dv(n,e){return hf(2048,8,n,e)}function KE(n,e){return hf(4,2,n,e)}function ZE(n,e){return hf(4,4,n,e)}function JE(n,e){if(typeof e=="function")return n=n(),e(n),function(){e(null)};if(e!=null)return n=n(),e.current=n,function(){e.current=null}}function QE(n,e,t){return t=t!=null?t.concat([n]):null,hf(4,4,JE.bind(null,e,n),t)}function fv(){}function e1(n,e){var t=vi();e=e===void 0?null:e;var i=t.memoizedState;return i!==null&&e!==null&&cv(e,i[1])?i[0]:(t.memoizedState=[n,e],n)}function t1(n,e){var t=vi();e=e===void 0?null:e;var i=t.memoizedState;return i!==null&&e!==null&&cv(e,i[1])?i[0]:(n=n(),t.memoizedState=[n,e],n)}function n1(n,e,t){return(xo&21)===0?(n.baseState&&(n.baseState=!1,Un=!0),n.memoizedState=t):(Vi(t,e)||(t=sE(),Tt.lanes|=t,yo|=t,n.baseState=!0),e)}function tI(n,e){var t=ct;ct=t!==0&&4>t?t:4,n(!0);var i=Bp.transition;Bp.transition={};try{n(!1),e()}finally{ct=t,Bp.transition=i}}function i1(){return vi().memoizedState}function nI(n,e,t){var i=Ms(n);if(t={lane:i,action:t,hasEagerState:!1,eagerState:null,next:null},r1(n))s1(e,t);else if(t=FE(n,e,t,i),t!==null){var r=Tn();ki(t,n,i,r),o1(t,e,i)}}function iI(n,e,t){var i=Ms(n),r={lane:i,action:t,hasEagerState:!1,eagerState:null,next:null};if(r1(n))s1(e,r);else{var s=n.alternate;if(n.lanes===0&&(s===null||s.lanes===0)&&(s=e.lastRenderedReducer,s!==null))try{var o=e.lastRenderedState,a=s(o,t);if(r.hasEagerState=!0,r.eagerState=a,Vi(a,o)){var l=e.interleaved;l===null?(r.next=r,rv(e)):(r.next=l.next,l.next=r),e.interleaved=r;return}}catch{}finally{}t=FE(n,e,r,i),t!==null&&(r=Tn(),ki(t,n,i,r),o1(t,e,i))}}function r1(n){var e=n.alternate;return n===Tt||e!==null&&e===Tt}function s1(n,e){Lc=Id=!0;var t=n.pending;t===null?e.next=e:(e.next=t.next,t.next=e),n.pending=e}function o1(n,e,t){if((t&4194240)!==0){var i=e.lanes;i&=n.pendingLanes,t|=i,e.lanes=t,W0(n,t)}}var Nd={readContext:gi,useCallback:hn,useContext:hn,useEffect:hn,useImperativeHandle:hn,useInsertionEffect:hn,useLayoutEffect:hn,useMemo:hn,useReducer:hn,useRef:hn,useState:hn,useDebugValue:hn,useDeferredValue:hn,useTransition:hn,useMutableSource:hn,useSyncExternalStore:hn,useId:hn,unstable_isNewReconciler:!1},rI={readContext:gi,useCallback:function(n,e){return qi().memoizedState=[n,e===void 0?null:e],n},useContext:gi,useEffect:py,useImperativeHandle:function(n,e,t){return t=t!=null?t.concat([n]):null,td(4194308,4,JE.bind(null,e,n),t)},useLayoutEffect:function(n,e){return td(4194308,4,n,e)},useInsertionEffect:function(n,e){return td(4,2,n,e)},useMemo:function(n,e){var t=qi();return e=e===void 0?null:e,n=n(),t.memoizedState=[n,e],n},useReducer:function(n,e,t){var i=qi();return e=t!==void 0?t(e):e,i.memoizedState=i.baseState=e,n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:n,lastRenderedState:e},i.queue=n,n=n.dispatch=nI.bind(null,Tt,n),[i.memoizedState,n]},useRef:function(n){var e=qi();return n={current:n},e.memoizedState=n},useState:fy,useDebugValue:fv,useDeferredValue:function(n){return qi().memoizedState=n},useTransition:function(){var n=fy(!1),e=n[0];return n=tI.bind(null,n[1]),qi().memoizedState=n,[e,n]},useMutableSource:function(){},useSyncExternalStore:function(n,e,t){var i=Tt,r=qi();if(xt){if(t===void 0)throw Error(ve(407));t=t()}else{if(t=e(),Jt===null)throw Error(ve(349));(xo&30)!==0||WE(i,e,t)}r.memoizedState=t;var s={value:t,getSnapshot:e};return r.queue=s,py(XE.bind(null,i,s,n),[n]),i.flags|=2048,ou(9,$E.bind(null,i,s,t,e),void 0,null),t},useId:function(){var n=qi(),e=Jt.identifierPrefix;if(xt){var t=br,i=Er;t=(i&~(1<<32-zi(i)-1)).toString(32)+t,e=":"+e+"R"+t,t=ru++,0<t&&(e+="H"+t.toString(32)),e+=":"}else t=eI++,e=":"+e+"r"+t.toString(32)+":";return n.memoizedState=e},unstable_isNewReconciler:!1},sI={readContext:gi,useCallback:e1,useContext:gi,useEffect:dv,useImperativeHandle:QE,useInsertionEffect:KE,useLayoutEffect:ZE,useMemo:t1,useReducer:zp,useRef:YE,useState:function(){return zp(su)},useDebugValue:fv,useDeferredValue:function(n){var e=vi();return n1(e,Wt.memoizedState,n)},useTransition:function(){var n=zp(su)[0],e=vi().memoizedState;return[n,e]},useMutableSource:GE,useSyncExternalStore:VE,useId:i1,unstable_isNewReconciler:!1},oI={readContext:gi,useCallback:e1,useContext:gi,useEffect:dv,useImperativeHandle:QE,useInsertionEffect:KE,useLayoutEffect:ZE,useMemo:t1,useReducer:kp,useRef:YE,useState:function(){return kp(su)},useDebugValue:fv,useDeferredValue:function(n){var e=vi();return Wt===null?e.memoizedState=n:n1(e,Wt.memoizedState,n)},useTransition:function(){var n=kp(su)[0],e=vi().memoizedState;return[n,e]},useMutableSource:GE,useSyncExternalStore:VE,useId:i1,unstable_isNewReconciler:!1};function al(n,e){try{var t="",i=e;do t+=N3(i),i=i.return;while(i);var r=t}catch(s){r=`
Error generating stack: `+s.message+`
`+s.stack}return{value:n,source:e,stack:r,digest:null}}function Hp(n,e,t){return{value:n,source:null,stack:t!=null?t:null,digest:e!=null?e:null}}function Lg(n,e){try{console.error(e.value)}catch(t){setTimeout(function(){throw t})}}var aI=typeof WeakMap=="function"?WeakMap:Map;function a1(n,e,t){t=Cr(-1,t),t.tag=3,t.payload={element:null};var i=e.value;return t.callback=function(){Ud||(Ud=!0,kg=i),Lg(n,e)},t}function l1(n,e,t){t=Cr(-1,t),t.tag=3;var i=n.type.getDerivedStateFromError;if(typeof i=="function"){var r=e.value;t.payload=function(){return i(r)},t.callback=function(){Lg(n,e)}}var s=n.stateNode;return s!==null&&typeof s.componentDidCatch=="function"&&(t.callback=function(){Lg(n,e),typeof i!="function"&&(ys===null?ys=new Set([this]):ys.add(this));var o=e.stack;this.componentDidCatch(e.value,{componentStack:o!==null?o:""})}),t}function my(n,e,t){var i=n.pingCache;if(i===null){i=n.pingCache=new aI;var r=new Set;i.set(e,r)}else r=i.get(e),r===void 0&&(r=new Set,i.set(e,r));r.has(t)||(r.add(t),n=MI.bind(null,n,e,t),e.then(n,n))}function gy(n){do{var e;if((e=n.tag===13)&&(e=n.memoizedState,e=e!==null?e.dehydrated!==null:!0),e)return n;n=n.return}while(n!==null);return null}function vy(n,e,t,i,r){return(n.mode&1)===0?(n===e?n.flags|=65536:(n.flags|=128,t.flags|=131072,t.flags&=-52805,t.tag===1&&(t.alternate===null?t.tag=17:(e=Cr(-1,1),e.tag=2,xs(t,e,1))),t.lanes|=1),n):(n.flags|=65536,n.lanes=r,n)}var lI=Or.ReactCurrentOwner,Un=!1;function En(n,e,t,i){e.child=n===null?kE(e,null,t,i):sl(e,n.child,t,i)}function _y(n,e,t,i,r){t=t.render;var s=e.ref;return Ha(e,r),i=uv(n,e,t,i,s,r),t=hv(),n!==null&&!Un?(e.updateQueue=n.updateQueue,e.flags&=-2053,n.lanes&=~r,Fr(n,e,r)):(xt&&t&&J0(e),e.flags|=1,En(n,e,i,r),e.child)}function xy(n,e,t,i,r){if(n===null){var s=t.type;return typeof s=="function"&&!Mv(s)&&s.defaultProps===void 0&&t.compare===null&&t.defaultProps===void 0?(e.tag=15,e.type=s,c1(n,e,s,i,r)):(n=sd(t.type,null,i,e,e.mode,r),n.ref=e.ref,n.return=e,e.child=n)}if(s=n.child,(n.lanes&r)===0){var o=s.memoizedProps;if(t=t.compare,t=t!==null?t:Jc,t(o,i)&&n.ref===e.ref)return Fr(n,e,r)}return e.flags|=1,n=Ss(s,i),n.ref=e.ref,n.return=e,e.child=n}function c1(n,e,t,i,r){if(n!==null){var s=n.memoizedProps;if(Jc(s,i)&&n.ref===e.ref)if(Un=!1,e.pendingProps=i=s,(n.lanes&r)!==0)(n.flags&131072)!==0&&(Un=!0);else return e.lanes=n.lanes,Fr(n,e,r)}return Pg(n,e,t,i,r)}function u1(n,e,t){var i=e.pendingProps,r=i.children,s=n!==null?n.memoizedState:null;if(i.mode==="hidden")if((e.mode&1)===0)e.memoizedState={baseLanes:0,cachePool:null,transitions:null},pt(Ia,Yn),Yn|=t;else{if((t&1073741824)===0)return n=s!==null?s.baseLanes|t:t,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:n,cachePool:null,transitions:null},e.updateQueue=null,pt(Ia,Yn),Yn|=n,null;e.memoizedState={baseLanes:0,cachePool:null,transitions:null},i=s!==null?s.baseLanes:t,pt(Ia,Yn),Yn|=i}else s!==null?(i=s.baseLanes|t,e.memoizedState=null):i=t,pt(Ia,Yn),Yn|=i;return En(n,e,r,t),e.child}function h1(n,e){var t=e.ref;(n===null&&t!==null||n!==null&&n.ref!==t)&&(e.flags|=512,e.flags|=2097152)}function Pg(n,e,t,i,r){var s=Bn(t)?vo:xn.current;return s=il(e,s),Ha(e,r),t=uv(n,e,t,i,s,r),i=hv(),n!==null&&!Un?(e.updateQueue=n.updateQueue,e.flags&=-2053,n.lanes&=~r,Fr(n,e,r)):(xt&&i&&J0(e),e.flags|=1,En(n,e,t,r),e.child)}function yy(n,e,t,i,r){if(Bn(t)){var s=!0;Td(e)}else s=!1;if(Ha(e,r),e.stateNode===null)nd(n,e),BE(e,t,i),Rg(e,t,i,r),i=!0;else if(n===null){var o=e.stateNode,a=e.memoizedProps;o.props=a;var l=o.context,c=t.contextType;typeof c=="object"&&c!==null?c=gi(c):(c=Bn(t)?vo:xn.current,c=il(e,c));var u=t.getDerivedStateFromProps,h=typeof u=="function"||typeof o.getSnapshotBeforeUpdate=="function";h||typeof o.UNSAFE_componentWillReceiveProps!="function"&&typeof o.componentWillReceiveProps!="function"||(a!==i||l!==c)&&hy(e,o,i,c),is=!1;var d=e.memoizedState;o.state=d,Pd(e,i,o,r),l=e.memoizedState,a!==i||d!==l||On.current||is?(typeof u=="function"&&(Cg(e,t,u,i),l=e.memoizedState),(a=is||uy(e,t,a,i,d,l,c))?(h||typeof o.UNSAFE_componentWillMount!="function"&&typeof o.componentWillMount!="function"||(typeof o.componentWillMount=="function"&&o.componentWillMount(),typeof o.UNSAFE_componentWillMount=="function"&&o.UNSAFE_componentWillMount()),typeof o.componentDidMount=="function"&&(e.flags|=4194308)):(typeof o.componentDidMount=="function"&&(e.flags|=4194308),e.memoizedProps=i,e.memoizedState=l),o.props=i,o.state=l,o.context=c,i=a):(typeof o.componentDidMount=="function"&&(e.flags|=4194308),i=!1)}else{o=e.stateNode,UE(n,e),a=e.memoizedProps,c=e.type===e.elementType?a:Pi(e.type,a),o.props=c,h=e.pendingProps,d=o.context,l=t.contextType,typeof l=="object"&&l!==null?l=gi(l):(l=Bn(t)?vo:xn.current,l=il(e,l));var p=t.getDerivedStateFromProps;(u=typeof p=="function"||typeof o.getSnapshotBeforeUpdate=="function")||typeof o.UNSAFE_componentWillReceiveProps!="function"&&typeof o.componentWillReceiveProps!="function"||(a!==h||d!==l)&&hy(e,o,i,l),is=!1,d=e.memoizedState,o.state=d,Pd(e,i,o,r);var v=e.memoizedState;a!==h||d!==v||On.current||is?(typeof p=="function"&&(Cg(e,t,p,i),v=e.memoizedState),(c=is||uy(e,t,c,i,d,v,l)||!1)?(u||typeof o.UNSAFE_componentWillUpdate!="function"&&typeof o.componentWillUpdate!="function"||(typeof o.componentWillUpdate=="function"&&o.componentWillUpdate(i,v,l),typeof o.UNSAFE_componentWillUpdate=="function"&&o.UNSAFE_componentWillUpdate(i,v,l)),typeof o.componentDidUpdate=="function"&&(e.flags|=4),typeof o.getSnapshotBeforeUpdate=="function"&&(e.flags|=1024)):(typeof o.componentDidUpdate!="function"||a===n.memoizedProps&&d===n.memoizedState||(e.flags|=4),typeof o.getSnapshotBeforeUpdate!="function"||a===n.memoizedProps&&d===n.memoizedState||(e.flags|=1024),e.memoizedProps=i,e.memoizedState=v),o.props=i,o.state=v,o.context=l,i=c):(typeof o.componentDidUpdate!="function"||a===n.memoizedProps&&d===n.memoizedState||(e.flags|=4),typeof o.getSnapshotBeforeUpdate!="function"||a===n.memoizedProps&&d===n.memoizedState||(e.flags|=1024),i=!1)}return Dg(n,e,t,i,s,r)}function Dg(n,e,t,i,r,s){h1(n,e);var o=(e.flags&128)!==0;if(!i&&!o)return r&&sy(e,t,!1),Fr(n,e,s);i=e.stateNode,lI.current=e;var a=o&&typeof t.getDerivedStateFromError!="function"?null:i.render();return e.flags|=1,n!==null&&o?(e.child=sl(e,n.child,null,s),e.child=sl(e,null,a,s)):En(n,e,a,s),e.memoizedState=i.state,r&&sy(e,t,!0),e.child}function d1(n){var e=n.stateNode;e.pendingContext?ry(n,e.pendingContext,e.pendingContext!==e.context):e.context&&ry(n,e.context,!1),ov(n,e.containerInfo)}function My(n,e,t,i,r){return rl(),ev(r),e.flags|=256,En(n,e,t,i),e.child}var Ig={dehydrated:null,treeContext:null,retryLane:0};function Ng(n){return{baseLanes:n,cachePool:null,transitions:null}}function f1(n,e,t){var i=e.pendingProps,r=Et.current,s=!1,o=(e.flags&128)!==0,a;if((a=o)||(a=n!==null&&n.memoizedState===null?!1:(r&2)!==0),a?(s=!0,e.flags&=-129):(n===null||n.memoizedState!==null)&&(r|=1),pt(Et,r&1),n===null)return Tg(e),n=e.memoizedState,n!==null&&(n=n.dehydrated,n!==null)?((e.mode&1)===0?e.lanes=1:n.data==="$!"?e.lanes=8:e.lanes=1073741824,null):(o=i.children,n=i.fallback,s?(i=e.mode,s=e.child,o={mode:"hidden",children:o},(i&1)===0&&s!==null?(s.childLanes=0,s.pendingProps=o):s=pf(o,i,0,null),n=co(n,i,t,null),s.return=e,n.return=e,s.sibling=n,e.child=s,e.child.memoizedState=Ng(t),e.memoizedState=Ig,n):pv(e,o));if(r=n.memoizedState,r!==null&&(a=r.dehydrated,a!==null))return cI(n,e,o,i,a,r,t);if(s){s=i.fallback,o=e.mode,r=n.child,a=r.sibling;var l={mode:"hidden",children:i.children};return(o&1)===0&&e.child!==r?(i=e.child,i.childLanes=0,i.pendingProps=l,e.deletions=null):(i=Ss(r,l),i.subtreeFlags=r.subtreeFlags&14680064),a!==null?s=Ss(a,s):(s=co(s,o,t,null),s.flags|=2),s.return=e,i.return=e,i.sibling=s,e.child=i,i=s,s=e.child,o=n.child.memoizedState,o=o===null?Ng(t):{baseLanes:o.baseLanes|t,cachePool:null,transitions:o.transitions},s.memoizedState=o,s.childLanes=n.childLanes&~t,e.memoizedState=Ig,i}return s=n.child,n=s.sibling,i=Ss(s,{mode:"visible",children:i.children}),(e.mode&1)===0&&(i.lanes=t),i.return=e,i.sibling=null,n!==null&&(t=e.deletions,t===null?(e.deletions=[n],e.flags|=16):t.push(n)),e.child=i,e.memoizedState=null,i}function pv(n,e){return e=pf({mode:"visible",children:e},n.mode,0,null),e.return=n,n.child=e}function yh(n,e,t,i){return i!==null&&ev(i),sl(e,n.child,null,t),n=pv(e,e.pendingProps.children),n.flags|=2,e.memoizedState=null,n}function cI(n,e,t,i,r,s,o){if(t)return e.flags&256?(e.flags&=-257,i=Hp(Error(ve(422))),yh(n,e,o,i)):e.memoizedState!==null?(e.child=n.child,e.flags|=128,null):(s=i.fallback,r=e.mode,i=pf({mode:"visible",children:i.children},r,0,null),s=co(s,r,o,null),s.flags|=2,i.return=e,s.return=e,i.sibling=s,e.child=i,(e.mode&1)!==0&&sl(e,n.child,null,o),e.child.memoizedState=Ng(o),e.memoizedState=Ig,s);if((e.mode&1)===0)return yh(n,e,o,null);if(r.data==="$!"){if(i=r.nextSibling&&r.nextSibling.dataset,i)var a=i.dgst;return i=a,s=Error(ve(419)),i=Hp(s,i,void 0),yh(n,e,o,i)}if(a=(o&n.childLanes)!==0,Un||a){if(i=Jt,i!==null){switch(o&-o){case 4:r=2;break;case 16:r=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:r=32;break;case 536870912:r=268435456;break;default:r=0}r=(r&(i.suspendedLanes|o))!==0?0:r,r!==0&&r!==s.retryLane&&(s.retryLane=r,Nr(n,r),ki(i,n,r,-1))}return yv(),i=Hp(Error(ve(421))),yh(n,e,o,i)}return r.data==="$?"?(e.flags|=128,e.child=n.child,e=SI.bind(null,n),r._reactRetry=e,null):(n=s.treeContext,Zn=_s(r.nextSibling),Qn=e,xt=!0,Ii=null,n!==null&&(oi[ai++]=Er,oi[ai++]=br,oi[ai++]=_o,Er=n.id,br=n.overflow,_o=e),e=pv(e,i.children),e.flags|=4096,e)}function Sy(n,e,t){n.lanes|=e;var i=n.alternate;i!==null&&(i.lanes|=e),Ag(n.return,e,t)}function Gp(n,e,t,i,r){var s=n.memoizedState;s===null?n.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:i,tail:t,tailMode:r}:(s.isBackwards=e,s.rendering=null,s.renderingStartTime=0,s.last=i,s.tail=t,s.tailMode=r)}function p1(n,e,t){var i=e.pendingProps,r=i.revealOrder,s=i.tail;if(En(n,e,i.children,t),i=Et.current,(i&2)!==0)i=i&1|2,e.flags|=128;else{if(n!==null&&(n.flags&128)!==0)e:for(n=e.child;n!==null;){if(n.tag===13)n.memoizedState!==null&&Sy(n,t,e);else if(n.tag===19)Sy(n,t,e);else if(n.child!==null){n.child.return=n,n=n.child;continue}if(n===e)break e;for(;n.sibling===null;){if(n.return===null||n.return===e)break e;n=n.return}n.sibling.return=n.return,n=n.sibling}i&=1}if(pt(Et,i),(e.mode&1)===0)e.memoizedState=null;else switch(r){case"forwards":for(t=e.child,r=null;t!==null;)n=t.alternate,n!==null&&Dd(n)===null&&(r=t),t=t.sibling;t=r,t===null?(r=e.child,e.child=null):(r=t.sibling,t.sibling=null),Gp(e,!1,r,t,s);break;case"backwards":for(t=null,r=e.child,e.child=null;r!==null;){if(n=r.alternate,n!==null&&Dd(n)===null){e.child=r;break}n=r.sibling,r.sibling=t,t=r,r=n}Gp(e,!0,t,null,s);break;case"together":Gp(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function nd(n,e){(e.mode&1)===0&&n!==null&&(n.alternate=null,e.alternate=null,e.flags|=2)}function Fr(n,e,t){if(n!==null&&(e.dependencies=n.dependencies),yo|=e.lanes,(t&e.childLanes)===0)return null;if(n!==null&&e.child!==n.child)throw Error(ve(153));if(e.child!==null){for(n=e.child,t=Ss(n,n.pendingProps),e.child=t,t.return=e;n.sibling!==null;)n=n.sibling,t=t.sibling=Ss(n,n.pendingProps),t.return=e;t.sibling=null}return e.child}function uI(n,e,t){switch(e.tag){case 3:d1(e),rl();break;case 5:HE(e);break;case 1:Bn(e.type)&&Td(e);break;case 4:ov(e,e.stateNode.containerInfo);break;case 10:var i=e.type._context,r=e.memoizedProps.value;pt(Rd,i._currentValue),i._currentValue=r;break;case 13:if(i=e.memoizedState,i!==null)return i.dehydrated!==null?(pt(Et,Et.current&1),e.flags|=128,null):(t&e.child.childLanes)!==0?f1(n,e,t):(pt(Et,Et.current&1),n=Fr(n,e,t),n!==null?n.sibling:null);pt(Et,Et.current&1);break;case 19:if(i=(t&e.childLanes)!==0,(n.flags&128)!==0){if(i)return p1(n,e,t);e.flags|=128}if(r=e.memoizedState,r!==null&&(r.rendering=null,r.tail=null,r.lastEffect=null),pt(Et,Et.current),i)break;return null;case 22:case 23:return e.lanes=0,u1(n,e,t)}return Fr(n,e,t)}var m1,Fg,g1,v1;m1=function(n,e){for(var t=e.child;t!==null;){if(t.tag===5||t.tag===6)n.appendChild(t.stateNode);else if(t.tag!==4&&t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return;t=t.return}t.sibling.return=t.return,t=t.sibling}};Fg=function(){};g1=function(n,e,t,i){var r=n.memoizedProps;if(r!==i){n=e.stateNode,io(er.current);var s=null;switch(t){case"input":r=ig(n,r),i=ig(n,i),s=[];break;case"select":r=At({},r,{value:void 0}),i=At({},i,{value:void 0}),s=[];break;case"textarea":r=og(n,r),i=og(n,i),s=[];break;default:typeof r.onClick!="function"&&typeof i.onClick=="function"&&(n.onclick=Ed)}lg(t,i);var o;t=null;for(c in r)if(!i.hasOwnProperty(c)&&r.hasOwnProperty(c)&&r[c]!=null)if(c==="style"){var a=r[c];for(o in a)a.hasOwnProperty(o)&&(t||(t={}),t[o]="")}else c!=="dangerouslySetInnerHTML"&&c!=="children"&&c!=="suppressContentEditableWarning"&&c!=="suppressHydrationWarning"&&c!=="autoFocus"&&($c.hasOwnProperty(c)?s||(s=[]):(s=s||[]).push(c,null));for(c in i){var l=i[c];if(a=r!=null?r[c]:void 0,i.hasOwnProperty(c)&&l!==a&&(l!=null||a!=null))if(c==="style")if(a){for(o in a)!a.hasOwnProperty(o)||l&&l.hasOwnProperty(o)||(t||(t={}),t[o]="");for(o in l)l.hasOwnProperty(o)&&a[o]!==l[o]&&(t||(t={}),t[o]=l[o])}else t||(s||(s=[]),s.push(c,t)),t=l;else c==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,a=a?a.__html:void 0,l!=null&&a!==l&&(s=s||[]).push(c,l)):c==="children"?typeof l!="string"&&typeof l!="number"||(s=s||[]).push(c,""+l):c!=="suppressContentEditableWarning"&&c!=="suppressHydrationWarning"&&($c.hasOwnProperty(c)?(l!=null&&c==="onScroll"&&gt("scroll",n),s||a===l||(s=[])):(s=s||[]).push(c,l))}t&&(s=s||[]).push("style",t);var c=s;(e.updateQueue=c)&&(e.flags|=4)}};v1=function(n,e,t,i){t!==i&&(e.flags|=4)};function Jl(n,e){if(!xt)switch(n.tailMode){case"hidden":e=n.tail;for(var t=null;e!==null;)e.alternate!==null&&(t=e),e=e.sibling;t===null?n.tail=null:t.sibling=null;break;case"collapsed":t=n.tail;for(var i=null;t!==null;)t.alternate!==null&&(i=t),t=t.sibling;i===null?e||n.tail===null?n.tail=null:n.tail.sibling=null:i.sibling=null}}function dn(n){var e=n.alternate!==null&&n.alternate.child===n.child,t=0,i=0;if(e)for(var r=n.child;r!==null;)t|=r.lanes|r.childLanes,i|=r.subtreeFlags&14680064,i|=r.flags&14680064,r.return=n,r=r.sibling;else for(r=n.child;r!==null;)t|=r.lanes|r.childLanes,i|=r.subtreeFlags,i|=r.flags,r.return=n,r=r.sibling;return n.subtreeFlags|=i,n.childLanes=t,e}function hI(n,e,t){var i=e.pendingProps;switch(Q0(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return dn(e),null;case 1:return Bn(e.type)&&bd(),dn(e),null;case 3:return i=e.stateNode,ol(),vt(On),vt(xn),lv(),i.pendingContext&&(i.context=i.pendingContext,i.pendingContext=null),(n===null||n.child===null)&&(_h(e)?e.flags|=4:n===null||n.memoizedState.isDehydrated&&(e.flags&256)===0||(e.flags|=1024,Ii!==null&&(Vg(Ii),Ii=null))),Fg(n,e),dn(e),null;case 5:av(e);var r=io(iu.current);if(t=e.type,n!==null&&e.stateNode!=null)g1(n,e,t,i,r),n.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!i){if(e.stateNode===null)throw Error(ve(166));return dn(e),null}if(n=io(er.current),_h(e)){i=e.stateNode,t=e.type;var s=e.memoizedProps;switch(i[Zi]=e,i[tu]=s,n=(e.mode&1)!==0,t){case"dialog":gt("cancel",i),gt("close",i);break;case"iframe":case"object":case"embed":gt("load",i);break;case"video":case"audio":for(r=0;r<pc.length;r++)gt(pc[r],i);break;case"source":gt("error",i);break;case"img":case"image":case"link":gt("error",i),gt("load",i);break;case"details":gt("toggle",i);break;case"input":Px(i,s),gt("invalid",i);break;case"select":i._wrapperState={wasMultiple:!!s.multiple},gt("invalid",i);break;case"textarea":Ix(i,s),gt("invalid",i)}lg(t,s),r=null;for(var o in s)if(s.hasOwnProperty(o)){var a=s[o];o==="children"?typeof a=="string"?i.textContent!==a&&(s.suppressHydrationWarning!==!0&&vh(i.textContent,a,n),r=["children",a]):typeof a=="number"&&i.textContent!==""+a&&(s.suppressHydrationWarning!==!0&&vh(i.textContent,a,n),r=["children",""+a]):$c.hasOwnProperty(o)&&a!=null&&o==="onScroll"&&gt("scroll",i)}switch(t){case"input":ch(i),Dx(i,s,!0);break;case"textarea":ch(i),Nx(i);break;case"select":case"option":break;default:typeof s.onClick=="function"&&(i.onclick=Ed)}i=r,e.updateQueue=i,i!==null&&(e.flags|=4)}else{o=r.nodeType===9?r:r.ownerDocument,n==="http://www.w3.org/1999/xhtml"&&(n=Ww(t)),n==="http://www.w3.org/1999/xhtml"?t==="script"?(n=o.createElement("div"),n.innerHTML="<script><\/script>",n=n.removeChild(n.firstChild)):typeof i.is=="string"?n=o.createElement(t,{is:i.is}):(n=o.createElement(t),t==="select"&&(o=n,i.multiple?o.multiple=!0:i.size&&(o.size=i.size))):n=o.createElementNS(n,t),n[Zi]=e,n[tu]=i,m1(n,e,!1,!1),e.stateNode=n;e:{switch(o=cg(t,i),t){case"dialog":gt("cancel",n),gt("close",n),r=i;break;case"iframe":case"object":case"embed":gt("load",n),r=i;break;case"video":case"audio":for(r=0;r<pc.length;r++)gt(pc[r],n);r=i;break;case"source":gt("error",n),r=i;break;case"img":case"image":case"link":gt("error",n),gt("load",n),r=i;break;case"details":gt("toggle",n),r=i;break;case"input":Px(n,i),r=ig(n,i),gt("invalid",n);break;case"option":r=i;break;case"select":n._wrapperState={wasMultiple:!!i.multiple},r=At({},i,{value:void 0}),gt("invalid",n);break;case"textarea":Ix(n,i),r=og(n,i),gt("invalid",n);break;default:r=i}lg(t,r),a=r;for(s in a)if(a.hasOwnProperty(s)){var l=a[s];s==="style"?jw(n,l):s==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,l!=null&&$w(n,l)):s==="children"?typeof l=="string"?(t!=="textarea"||l!=="")&&Xc(n,l):typeof l=="number"&&Xc(n,""+l):s!=="suppressContentEditableWarning"&&s!=="suppressHydrationWarning"&&s!=="autoFocus"&&($c.hasOwnProperty(s)?l!=null&&s==="onScroll"&&gt("scroll",n):l!=null&&B0(n,s,l,o))}switch(t){case"input":ch(n),Dx(n,i,!1);break;case"textarea":ch(n),Nx(n);break;case"option":i.value!=null&&n.setAttribute("value",""+As(i.value));break;case"select":n.multiple=!!i.multiple,s=i.value,s!=null?Oa(n,!!i.multiple,s,!1):i.defaultValue!=null&&Oa(n,!!i.multiple,i.defaultValue,!0);break;default:typeof r.onClick=="function"&&(n.onclick=Ed)}switch(t){case"button":case"input":case"select":case"textarea":i=!!i.autoFocus;break e;case"img":i=!0;break e;default:i=!1}}i&&(e.flags|=4)}e.ref!==null&&(e.flags|=512,e.flags|=2097152)}return dn(e),null;case 6:if(n&&e.stateNode!=null)v1(n,e,n.memoizedProps,i);else{if(typeof i!="string"&&e.stateNode===null)throw Error(ve(166));if(t=io(iu.current),io(er.current),_h(e)){if(i=e.stateNode,t=e.memoizedProps,i[Zi]=e,(s=i.nodeValue!==t)&&(n=Qn,n!==null))switch(n.tag){case 3:vh(i.nodeValue,t,(n.mode&1)!==0);break;case 5:n.memoizedProps.suppressHydrationWarning!==!0&&vh(i.nodeValue,t,(n.mode&1)!==0)}s&&(e.flags|=4)}else i=(t.nodeType===9?t:t.ownerDocument).createTextNode(i),i[Zi]=e,e.stateNode=i}return dn(e),null;case 13:if(vt(Et),i=e.memoizedState,n===null||n.memoizedState!==null&&n.memoizedState.dehydrated!==null){if(xt&&Zn!==null&&(e.mode&1)!==0&&(e.flags&128)===0)NE(),rl(),e.flags|=98560,s=!1;else if(s=_h(e),i!==null&&i.dehydrated!==null){if(n===null){if(!s)throw Error(ve(318));if(s=e.memoizedState,s=s!==null?s.dehydrated:null,!s)throw Error(ve(317));s[Zi]=e}else rl(),(e.flags&128)===0&&(e.memoizedState=null),e.flags|=4;dn(e),s=!1}else Ii!==null&&(Vg(Ii),Ii=null),s=!0;if(!s)return e.flags&65536?e:null}return(e.flags&128)!==0?(e.lanes=t,e):(i=i!==null,i!==(n!==null&&n.memoizedState!==null)&&i&&(e.child.flags|=8192,(e.mode&1)!==0&&(n===null||(Et.current&1)!==0?Xt===0&&(Xt=3):yv())),e.updateQueue!==null&&(e.flags|=4),dn(e),null);case 4:return ol(),Fg(n,e),n===null&&Qc(e.stateNode.containerInfo),dn(e),null;case 10:return iv(e.type._context),dn(e),null;case 17:return Bn(e.type)&&bd(),dn(e),null;case 19:if(vt(Et),s=e.memoizedState,s===null)return dn(e),null;if(i=(e.flags&128)!==0,o=s.rendering,o===null)if(i)Jl(s,!1);else{if(Xt!==0||n!==null&&(n.flags&128)!==0)for(n=e.child;n!==null;){if(o=Dd(n),o!==null){for(e.flags|=128,Jl(s,!1),i=o.updateQueue,i!==null&&(e.updateQueue=i,e.flags|=4),e.subtreeFlags=0,i=t,t=e.child;t!==null;)s=t,n=i,s.flags&=14680066,o=s.alternate,o===null?(s.childLanes=0,s.lanes=n,s.child=null,s.subtreeFlags=0,s.memoizedProps=null,s.memoizedState=null,s.updateQueue=null,s.dependencies=null,s.stateNode=null):(s.childLanes=o.childLanes,s.lanes=o.lanes,s.child=o.child,s.subtreeFlags=0,s.deletions=null,s.memoizedProps=o.memoizedProps,s.memoizedState=o.memoizedState,s.updateQueue=o.updateQueue,s.type=o.type,n=o.dependencies,s.dependencies=n===null?null:{lanes:n.lanes,firstContext:n.firstContext}),t=t.sibling;return pt(Et,Et.current&1|2),e.child}n=n.sibling}s.tail!==null&&Ft()>ll&&(e.flags|=128,i=!0,Jl(s,!1),e.lanes=4194304)}else{if(!i)if(n=Dd(o),n!==null){if(e.flags|=128,i=!0,t=n.updateQueue,t!==null&&(e.updateQueue=t,e.flags|=4),Jl(s,!0),s.tail===null&&s.tailMode==="hidden"&&!o.alternate&&!xt)return dn(e),null}else 2*Ft()-s.renderingStartTime>ll&&t!==1073741824&&(e.flags|=128,i=!0,Jl(s,!1),e.lanes=4194304);s.isBackwards?(o.sibling=e.child,e.child=o):(t=s.last,t!==null?t.sibling=o:e.child=o,s.last=o)}return s.tail!==null?(e=s.tail,s.rendering=e,s.tail=e.sibling,s.renderingStartTime=Ft(),e.sibling=null,t=Et.current,pt(Et,i?t&1|2:t&1),e):(dn(e),null);case 22:case 23:return xv(),i=e.memoizedState!==null,n!==null&&n.memoizedState!==null!==i&&(e.flags|=8192),i&&(e.mode&1)!==0?(Yn&1073741824)!==0&&(dn(e),e.subtreeFlags&6&&(e.flags|=8192)):dn(e),null;case 24:return null;case 25:return null}throw Error(ve(156,e.tag))}function dI(n,e){switch(Q0(e),e.tag){case 1:return Bn(e.type)&&bd(),n=e.flags,n&65536?(e.flags=n&-65537|128,e):null;case 3:return ol(),vt(On),vt(xn),lv(),n=e.flags,(n&65536)!==0&&(n&128)===0?(e.flags=n&-65537|128,e):null;case 5:return av(e),null;case 13:if(vt(Et),n=e.memoizedState,n!==null&&n.dehydrated!==null){if(e.alternate===null)throw Error(ve(340));rl()}return n=e.flags,n&65536?(e.flags=n&-65537|128,e):null;case 19:return vt(Et),null;case 4:return ol(),null;case 10:return iv(e.type._context),null;case 22:case 23:return xv(),null;case 24:return null;default:return null}}var Mh=!1,vn=!1,fI=typeof WeakSet=="function"?WeakSet:Set,Ue=null;function Da(n,e){var t=n.ref;if(t!==null)if(typeof t=="function")try{t(null)}catch(i){Ct(n,e,i)}else t.current=null}function Ug(n,e,t){try{t()}catch(i){Ct(n,e,i)}}var wy=!1;function pI(n,e){if(xg=Md,n=ME(),Z0(n)){if("selectionStart"in n)var t={start:n.selectionStart,end:n.selectionEnd};else e:{t=(t=n.ownerDocument)&&t.defaultView||window;var i=t.getSelection&&t.getSelection();if(i&&i.rangeCount!==0){t=i.anchorNode;var r=i.anchorOffset,s=i.focusNode;i=i.focusOffset;try{t.nodeType,s.nodeType}catch{t=null;break e}var o=0,a=-1,l=-1,c=0,u=0,h=n,d=null;t:for(;;){for(var p;h!==t||r!==0&&h.nodeType!==3||(a=o+r),h!==s||i!==0&&h.nodeType!==3||(l=o+i),h.nodeType===3&&(o+=h.nodeValue.length),(p=h.firstChild)!==null;)d=h,h=p;for(;;){if(h===n)break t;if(d===t&&++c===r&&(a=o),d===s&&++u===i&&(l=o),(p=h.nextSibling)!==null)break;h=d,d=h.parentNode}h=p}t=a===-1||l===-1?null:{start:a,end:l}}else t=null}t=t||{start:0,end:0}}else t=null;for(yg={focusedElem:n,selectionRange:t},Md=!1,Ue=e;Ue!==null;)if(e=Ue,n=e.child,(e.subtreeFlags&1028)!==0&&n!==null)n.return=e,Ue=n;else for(;Ue!==null;){e=Ue;try{var v=e.alternate;if((e.flags&1024)!==0)switch(e.tag){case 0:case 11:case 15:break;case 1:if(v!==null){var m=v.memoizedProps,f=v.memoizedState,g=e.stateNode,_=g.getSnapshotBeforeUpdate(e.elementType===e.type?m:Pi(e.type,m),f);g.__reactInternalSnapshotBeforeUpdate=_}break;case 3:var M=e.stateNode.containerInfo;M.nodeType===1?M.textContent="":M.nodeType===9&&M.documentElement&&M.removeChild(M.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(ve(163))}}catch(E){Ct(e,e.return,E)}if(n=e.sibling,n!==null){n.return=e.return,Ue=n;break}Ue=e.return}return v=wy,wy=!1,v}function Pc(n,e,t){var i=e.updateQueue;if(i=i!==null?i.lastEffect:null,i!==null){var r=i=i.next;do{if((r.tag&n)===n){var s=r.destroy;r.destroy=void 0,s!==void 0&&Ug(e,t,s)}r=r.next}while(r!==i)}}function df(n,e){if(e=e.updateQueue,e=e!==null?e.lastEffect:null,e!==null){var t=e=e.next;do{if((t.tag&n)===n){var i=t.create;t.destroy=i()}t=t.next}while(t!==e)}}function Og(n){var e=n.ref;if(e!==null){var t=n.stateNode;switch(n.tag){case 5:n=t;break;default:n=t}typeof e=="function"?e(n):e.current=n}}function _1(n){var e=n.alternate;e!==null&&(n.alternate=null,_1(e)),n.child=null,n.deletions=null,n.sibling=null,n.tag===5&&(e=n.stateNode,e!==null&&(delete e[Zi],delete e[tu],delete e[wg],delete e[KD],delete e[ZD])),n.stateNode=null,n.return=null,n.dependencies=null,n.memoizedProps=null,n.memoizedState=null,n.pendingProps=null,n.stateNode=null,n.updateQueue=null}function x1(n){return n.tag===5||n.tag===3||n.tag===4}function Ey(n){e:for(;;){for(;n.sibling===null;){if(n.return===null||x1(n.return))return null;n=n.return}for(n.sibling.return=n.return,n=n.sibling;n.tag!==5&&n.tag!==6&&n.tag!==18;){if(n.flags&2||n.child===null||n.tag===4)continue e;n.child.return=n,n=n.child}if(!(n.flags&2))return n.stateNode}}function Bg(n,e,t){var i=n.tag;if(i===5||i===6)n=n.stateNode,e?t.nodeType===8?t.parentNode.insertBefore(n,e):t.insertBefore(n,e):(t.nodeType===8?(e=t.parentNode,e.insertBefore(n,t)):(e=t,e.appendChild(n)),t=t._reactRootContainer,t!=null||e.onclick!==null||(e.onclick=Ed));else if(i!==4&&(n=n.child,n!==null))for(Bg(n,e,t),n=n.sibling;n!==null;)Bg(n,e,t),n=n.sibling}function zg(n,e,t){var i=n.tag;if(i===5||i===6)n=n.stateNode,e?t.insertBefore(n,e):t.appendChild(n);else if(i!==4&&(n=n.child,n!==null))for(zg(n,e,t),n=n.sibling;n!==null;)zg(n,e,t),n=n.sibling}var nn=null,Di=!1;function Xr(n,e,t){for(t=t.child;t!==null;)y1(n,e,t),t=t.sibling}function y1(n,e,t){if(Qi&&typeof Qi.onCommitFiberUnmount=="function")try{Qi.onCommitFiberUnmount(rf,t)}catch{}switch(t.tag){case 5:vn||Da(t,e);case 6:var i=nn,r=Di;nn=null,Xr(n,e,t),nn=i,Di=r,nn!==null&&(Di?(n=nn,t=t.stateNode,n.nodeType===8?n.parentNode.removeChild(t):n.removeChild(t)):nn.removeChild(t.stateNode));break;case 18:nn!==null&&(Di?(n=nn,t=t.stateNode,n.nodeType===8?Fp(n.parentNode,t):n.nodeType===1&&Fp(n,t),Kc(n)):Fp(nn,t.stateNode));break;case 4:i=nn,r=Di,nn=t.stateNode.containerInfo,Di=!0,Xr(n,e,t),nn=i,Di=r;break;case 0:case 11:case 14:case 15:if(!vn&&(i=t.updateQueue,i!==null&&(i=i.lastEffect,i!==null))){r=i=i.next;do{var s=r,o=s.destroy;s=s.tag,o!==void 0&&((s&2)!==0||(s&4)!==0)&&Ug(t,e,o),r=r.next}while(r!==i)}Xr(n,e,t);break;case 1:if(!vn&&(Da(t,e),i=t.stateNode,typeof i.componentWillUnmount=="function"))try{i.props=t.memoizedProps,i.state=t.memoizedState,i.componentWillUnmount()}catch(a){Ct(t,e,a)}Xr(n,e,t);break;case 21:Xr(n,e,t);break;case 22:t.mode&1?(vn=(i=vn)||t.memoizedState!==null,Xr(n,e,t),vn=i):Xr(n,e,t);break;default:Xr(n,e,t)}}function by(n){var e=n.updateQueue;if(e!==null){n.updateQueue=null;var t=n.stateNode;t===null&&(t=n.stateNode=new fI),e.forEach(function(i){var r=wI.bind(null,n,i);t.has(i)||(t.add(i),i.then(r,r))})}}function bi(n,e){var t=e.deletions;if(t!==null)for(var i=0;i<t.length;i++){var r=t[i];try{var s=n,o=e,a=o;e:for(;a!==null;){switch(a.tag){case 5:nn=a.stateNode,Di=!1;break e;case 3:nn=a.stateNode.containerInfo,Di=!0;break e;case 4:nn=a.stateNode.containerInfo,Di=!0;break e}a=a.return}if(nn===null)throw Error(ve(160));y1(s,o,r),nn=null,Di=!1;var l=r.alternate;l!==null&&(l.return=null),r.return=null}catch(c){Ct(r,e,c)}}if(e.subtreeFlags&12854)for(e=e.child;e!==null;)M1(e,n),e=e.sibling}function M1(n,e){var t=n.alternate,i=n.flags;switch(n.tag){case 0:case 11:case 14:case 15:if(bi(e,n),ji(n),i&4){try{Pc(3,n,n.return),df(3,n)}catch(m){Ct(n,n.return,m)}try{Pc(5,n,n.return)}catch(m){Ct(n,n.return,m)}}break;case 1:bi(e,n),ji(n),i&512&&t!==null&&Da(t,t.return);break;case 5:if(bi(e,n),ji(n),i&512&&t!==null&&Da(t,t.return),n.flags&32){var r=n.stateNode;try{Xc(r,"")}catch(m){Ct(n,n.return,m)}}if(i&4&&(r=n.stateNode,r!=null)){var s=n.memoizedProps,o=t!==null?t.memoizedProps:s,a=n.type,l=n.updateQueue;if(n.updateQueue=null,l!==null)try{a==="input"&&s.type==="radio"&&s.name!=null&&Gw(r,s),cg(a,o);var c=cg(a,s);for(o=0;o<l.length;o+=2){var u=l[o],h=l[o+1];u==="style"?jw(r,h):u==="dangerouslySetInnerHTML"?$w(r,h):u==="children"?Xc(r,h):B0(r,u,h,c)}switch(a){case"input":rg(r,s);break;case"textarea":Vw(r,s);break;case"select":var d=r._wrapperState.wasMultiple;r._wrapperState.wasMultiple=!!s.multiple;var p=s.value;p!=null?Oa(r,!!s.multiple,p,!1):d!==!!s.multiple&&(s.defaultValue!=null?Oa(r,!!s.multiple,s.defaultValue,!0):Oa(r,!!s.multiple,s.multiple?[]:"",!1))}r[tu]=s}catch(m){Ct(n,n.return,m)}}break;case 6:if(bi(e,n),ji(n),i&4){if(n.stateNode===null)throw Error(ve(162));r=n.stateNode,s=n.memoizedProps;try{r.nodeValue=s}catch(m){Ct(n,n.return,m)}}break;case 3:if(bi(e,n),ji(n),i&4&&t!==null&&t.memoizedState.isDehydrated)try{Kc(e.containerInfo)}catch(m){Ct(n,n.return,m)}break;case 4:bi(e,n),ji(n);break;case 13:bi(e,n),ji(n),r=n.child,r.flags&8192&&(s=r.memoizedState!==null,r.stateNode.isHidden=s,!s||r.alternate!==null&&r.alternate.memoizedState!==null||(vv=Ft())),i&4&&by(n);break;case 22:if(u=t!==null&&t.memoizedState!==null,n.mode&1?(vn=(c=vn)||u,bi(e,n),vn=c):bi(e,n),ji(n),i&8192){if(c=n.memoizedState!==null,(n.stateNode.isHidden=c)&&!u&&(n.mode&1)!==0)for(Ue=n,u=n.child;u!==null;){for(h=Ue=u;Ue!==null;){switch(d=Ue,p=d.child,d.tag){case 0:case 11:case 14:case 15:Pc(4,d,d.return);break;case 1:Da(d,d.return);var v=d.stateNode;if(typeof v.componentWillUnmount=="function"){i=d,t=d.return;try{e=i,v.props=e.memoizedProps,v.state=e.memoizedState,v.componentWillUnmount()}catch(m){Ct(i,t,m)}}break;case 5:Da(d,d.return);break;case 22:if(d.memoizedState!==null){Ay(h);continue}}p!==null?(p.return=d,Ue=p):Ay(h)}u=u.sibling}e:for(u=null,h=n;;){if(h.tag===5){if(u===null){u=h;try{r=h.stateNode,c?(s=r.style,typeof s.setProperty=="function"?s.setProperty("display","none","important"):s.display="none"):(a=h.stateNode,l=h.memoizedProps.style,o=l!=null&&l.hasOwnProperty("display")?l.display:null,a.style.display=Xw("display",o))}catch(m){Ct(n,n.return,m)}}}else if(h.tag===6){if(u===null)try{h.stateNode.nodeValue=c?"":h.memoizedProps}catch(m){Ct(n,n.return,m)}}else if((h.tag!==22&&h.tag!==23||h.memoizedState===null||h===n)&&h.child!==null){h.child.return=h,h=h.child;continue}if(h===n)break e;for(;h.sibling===null;){if(h.return===null||h.return===n)break e;u===h&&(u=null),h=h.return}u===h&&(u=null),h.sibling.return=h.return,h=h.sibling}}break;case 19:bi(e,n),ji(n),i&4&&by(n);break;case 21:break;default:bi(e,n),ji(n)}}function ji(n){var e=n.flags;if(e&2){try{e:{for(var t=n.return;t!==null;){if(x1(t)){var i=t;break e}t=t.return}throw Error(ve(160))}switch(i.tag){case 5:var r=i.stateNode;i.flags&32&&(Xc(r,""),i.flags&=-33);var s=Ey(n);zg(n,s,r);break;case 3:case 4:var o=i.stateNode.containerInfo,a=Ey(n);Bg(n,a,o);break;default:throw Error(ve(161))}}catch(l){Ct(n,n.return,l)}n.flags&=-3}e&4096&&(n.flags&=-4097)}function mI(n,e,t){Ue=n,S1(n)}function S1(n,e,t){for(var i=(n.mode&1)!==0;Ue!==null;){var r=Ue,s=r.child;if(r.tag===22&&i){var o=r.memoizedState!==null||Mh;if(!o){var a=r.alternate,l=a!==null&&a.memoizedState!==null||vn;a=Mh;var c=vn;if(Mh=o,(vn=l)&&!c)for(Ue=r;Ue!==null;)o=Ue,l=o.child,o.tag===22&&o.memoizedState!==null?Cy(r):l!==null?(l.return=o,Ue=l):Cy(r);for(;s!==null;)Ue=s,S1(s),s=s.sibling;Ue=r,Mh=a,vn=c}Ty(n)}else(r.subtreeFlags&8772)!==0&&s!==null?(s.return=r,Ue=s):Ty(n)}}function Ty(n){for(;Ue!==null;){var e=Ue;if((e.flags&8772)!==0){var t=e.alternate;try{if((e.flags&8772)!==0)switch(e.tag){case 0:case 11:case 15:vn||df(5,e);break;case 1:var i=e.stateNode;if(e.flags&4&&!vn)if(t===null)i.componentDidMount();else{var r=e.elementType===e.type?t.memoizedProps:Pi(e.type,t.memoizedProps);i.componentDidUpdate(r,t.memoizedState,i.__reactInternalSnapshotBeforeUpdate)}var s=e.updateQueue;s!==null&&cy(e,s,i);break;case 3:var o=e.updateQueue;if(o!==null){if(t=null,e.child!==null)switch(e.child.tag){case 5:t=e.child.stateNode;break;case 1:t=e.child.stateNode}cy(e,o,t)}break;case 5:var a=e.stateNode;if(t===null&&e.flags&4){t=a;var l=e.memoizedProps;switch(e.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&t.focus();break;case"img":l.src&&(t.src=l.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(e.memoizedState===null){var c=e.alternate;if(c!==null){var u=c.memoizedState;if(u!==null){var h=u.dehydrated;h!==null&&Kc(h)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(ve(163))}vn||e.flags&512&&Og(e)}catch(d){Ct(e,e.return,d)}}if(e===n){Ue=null;break}if(t=e.sibling,t!==null){t.return=e.return,Ue=t;break}Ue=e.return}}function Ay(n){for(;Ue!==null;){var e=Ue;if(e===n){Ue=null;break}var t=e.sibling;if(t!==null){t.return=e.return,Ue=t;break}Ue=e.return}}function Cy(n){for(;Ue!==null;){var e=Ue;try{switch(e.tag){case 0:case 11:case 15:var t=e.return;try{df(4,e)}catch(l){Ct(e,t,l)}break;case 1:var i=e.stateNode;if(typeof i.componentDidMount=="function"){var r=e.return;try{i.componentDidMount()}catch(l){Ct(e,r,l)}}var s=e.return;try{Og(e)}catch(l){Ct(e,s,l)}break;case 5:var o=e.return;try{Og(e)}catch(l){Ct(e,o,l)}}}catch(l){Ct(e,e.return,l)}if(e===n){Ue=null;break}var a=e.sibling;if(a!==null){a.return=e.return,Ue=a;break}Ue=e.return}}var gI=Math.ceil,Fd=Or.ReactCurrentDispatcher,mv=Or.ReactCurrentOwner,fi=Or.ReactCurrentBatchConfig,tt=0,Jt=null,kt=null,an=0,Yn=0,Ia=Is(0),Xt=0,au=null,yo=0,ff=0,gv=0,Dc=null,In=null,vv=0,ll=1/0,xr=null,Ud=!1,kg=null,ys=null,Sh=!1,us=null,Od=0,Ic=0,Hg=null,id=-1,rd=0;function Tn(){return(tt&6)!==0?Ft():id!==-1?id:id=Ft()}function Ms(n){return(n.mode&1)===0?1:(tt&2)!==0&&an!==0?an&-an:QD.transition!==null?(rd===0&&(rd=sE()),rd):(n=ct,n!==0||(n=window.event,n=n===void 0?16:dE(n.type)),n)}function ki(n,e,t,i){if(50<Ic)throw Ic=0,Hg=null,Error(ve(185));Mu(n,t,i),((tt&2)===0||n!==Jt)&&(n===Jt&&((tt&2)===0&&(ff|=t),Xt===4&&as(n,an)),zn(n,i),t===1&&tt===0&&(e.mode&1)===0&&(ll=Ft()+500,cf&&Ns()))}function zn(n,e){var t=n.callbackNode;Q3(n,e);var i=yd(n,n===Jt?an:0);if(i===0)t!==null&&Ox(t),n.callbackNode=null,n.callbackPriority=0;else if(e=i&-i,n.callbackPriority!==e){if(t!=null&&Ox(t),e===1)n.tag===0?JD(Ry.bind(null,n)):PE(Ry.bind(null,n)),qD(function(){(tt&6)===0&&Ns()}),t=null;else{switch(oE(i)){case 1:t=V0;break;case 4:t=iE;break;case 16:t=xd;break;case 536870912:t=rE;break;default:t=xd}t=L1(t,w1.bind(null,n))}n.callbackPriority=e,n.callbackNode=t}}function w1(n,e){if(id=-1,rd=0,(tt&6)!==0)throw Error(ve(327));var t=n.callbackNode;if(Ga()&&n.callbackNode!==t)return null;var i=yd(n,n===Jt?an:0);if(i===0)return null;if((i&30)!==0||(i&n.expiredLanes)!==0||e)e=Bd(n,i);else{e=i;var r=tt;tt|=2;var s=b1();(Jt!==n||an!==e)&&(xr=null,ll=Ft()+500,lo(n,e));do try{xI();break}catch(a){E1(n,a)}while(1);nv(),Fd.current=s,tt=r,kt!==null?e=0:(Jt=null,an=0,e=Xt)}if(e!==0){if(e===2&&(r=pg(n),r!==0&&(i=r,e=Gg(n,r))),e===1)throw t=au,lo(n,0),as(n,i),zn(n,Ft()),t;if(e===6)as(n,i);else{if(r=n.current.alternate,(i&30)===0&&!vI(r)&&(e=Bd(n,i),e===2&&(s=pg(n),s!==0&&(i=s,e=Gg(n,s))),e===1))throw t=au,lo(n,0),as(n,i),zn(n,Ft()),t;switch(n.finishedWork=r,n.finishedLanes=i,e){case 0:case 1:throw Error(ve(345));case 2:qs(n,In,xr);break;case 3:if(as(n,i),(i&130023424)===i&&(e=vv+500-Ft(),10<e)){if(yd(n,0)!==0)break;if(r=n.suspendedLanes,(r&i)!==i){Tn(),n.pingedLanes|=n.suspendedLanes&r;break}n.timeoutHandle=Sg(qs.bind(null,n,In,xr),e);break}qs(n,In,xr);break;case 4:if(as(n,i),(i&4194240)===i)break;for(e=n.eventTimes,r=-1;0<i;){var o=31-zi(i);s=1<<o,o=e[o],o>r&&(r=o),i&=~s}if(i=r,i=Ft()-i,i=(120>i?120:480>i?480:1080>i?1080:1920>i?1920:3e3>i?3e3:4320>i?4320:1960*gI(i/1960))-i,10<i){n.timeoutHandle=Sg(qs.bind(null,n,In,xr),i);break}qs(n,In,xr);break;case 5:qs(n,In,xr);break;default:throw Error(ve(329))}}}return zn(n,Ft()),n.callbackNode===t?w1.bind(null,n):null}function Gg(n,e){var t=Dc;return n.current.memoizedState.isDehydrated&&(lo(n,e).flags|=256),n=Bd(n,e),n!==2&&(e=In,In=t,e!==null&&Vg(e)),n}function Vg(n){In===null?In=n:In.push.apply(In,n)}function vI(n){for(var e=n;;){if(e.flags&16384){var t=e.updateQueue;if(t!==null&&(t=t.stores,t!==null))for(var i=0;i<t.length;i++){var r=t[i],s=r.getSnapshot;r=r.value;try{if(!Vi(s(),r))return!1}catch{return!1}}}if(t=e.child,e.subtreeFlags&16384&&t!==null)t.return=e,e=t;else{if(e===n)break;for(;e.sibling===null;){if(e.return===null||e.return===n)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}function as(n,e){for(e&=~gv,e&=~ff,n.suspendedLanes|=e,n.pingedLanes&=~e,n=n.expirationTimes;0<e;){var t=31-zi(e),i=1<<t;n[t]=-1,e&=~i}}function Ry(n){if((tt&6)!==0)throw Error(ve(327));Ga();var e=yd(n,0);if((e&1)===0)return zn(n,Ft()),null;var t=Bd(n,e);if(n.tag!==0&&t===2){var i=pg(n);i!==0&&(e=i,t=Gg(n,i))}if(t===1)throw t=au,lo(n,0),as(n,e),zn(n,Ft()),t;if(t===6)throw Error(ve(345));return n.finishedWork=n.current.alternate,n.finishedLanes=e,qs(n,In,xr),zn(n,Ft()),null}function _v(n,e){var t=tt;tt|=1;try{return n(e)}finally{tt=t,tt===0&&(ll=Ft()+500,cf&&Ns())}}function Mo(n){us!==null&&us.tag===0&&(tt&6)===0&&Ga();var e=tt;tt|=1;var t=fi.transition,i=ct;try{if(fi.transition=null,ct=1,n)return n()}finally{ct=i,fi.transition=t,tt=e,(tt&6)===0&&Ns()}}function xv(){Yn=Ia.current,vt(Ia)}function lo(n,e){n.finishedWork=null,n.finishedLanes=0;var t=n.timeoutHandle;if(t!==-1&&(n.timeoutHandle=-1,jD(t)),kt!==null)for(t=kt.return;t!==null;){var i=t;switch(Q0(i),i.tag){case 1:i=i.type.childContextTypes,i!=null&&bd();break;case 3:ol(),vt(On),vt(xn),lv();break;case 5:av(i);break;case 4:ol();break;case 13:vt(Et);break;case 19:vt(Et);break;case 10:iv(i.type._context);break;case 22:case 23:xv()}t=t.return}if(Jt=n,kt=n=Ss(n.current,null),an=Yn=e,Xt=0,au=null,gv=ff=yo=0,In=Dc=null,no!==null){for(e=0;e<no.length;e++)if(t=no[e],i=t.interleaved,i!==null){t.interleaved=null;var r=i.next,s=t.pending;if(s!==null){var o=s.next;s.next=r,i.next=o}t.pending=i}no=null}return n}function E1(n,e){do{var t=kt;try{if(nv(),ed.current=Nd,Id){for(var i=Tt.memoizedState;i!==null;){var r=i.queue;r!==null&&(r.pending=null),i=i.next}Id=!1}if(xo=0,Kt=Wt=Tt=null,Lc=!1,ru=0,mv.current=null,t===null||t.return===null){Xt=1,au=e,kt=null;break}e:{var s=n,o=t.return,a=t,l=e;if(e=an,a.flags|=32768,l!==null&&typeof l=="object"&&typeof l.then=="function"){var c=l,u=a,h=u.tag;if((u.mode&1)===0&&(h===0||h===11||h===15)){var d=u.alternate;d?(u.updateQueue=d.updateQueue,u.memoizedState=d.memoizedState,u.lanes=d.lanes):(u.updateQueue=null,u.memoizedState=null)}var p=gy(o);if(p!==null){p.flags&=-257,vy(p,o,a,s,e),p.mode&1&&my(s,c,e),e=p,l=c;var v=e.updateQueue;if(v===null){var m=new Set;m.add(l),e.updateQueue=m}else v.add(l);break e}else{if((e&1)===0){my(s,c,e),yv();break e}l=Error(ve(426))}}else if(xt&&a.mode&1){var f=gy(o);if(f!==null){(f.flags&65536)===0&&(f.flags|=256),vy(f,o,a,s,e),ev(al(l,a));break e}}s=l=al(l,a),Xt!==4&&(Xt=2),Dc===null?Dc=[s]:Dc.push(s),s=o;do{switch(s.tag){case 3:s.flags|=65536,e&=-e,s.lanes|=e;var g=a1(s,l,e);ly(s,g);break e;case 1:a=l;var _=s.type,M=s.stateNode;if((s.flags&128)===0&&(typeof _.getDerivedStateFromError=="function"||M!==null&&typeof M.componentDidCatch=="function"&&(ys===null||!ys.has(M)))){s.flags|=65536,e&=-e,s.lanes|=e;var E=l1(s,a,e);ly(s,E);break e}}s=s.return}while(s!==null)}A1(t)}catch(S){e=S,kt===t&&t!==null&&(kt=t=t.return);continue}break}while(1)}function b1(){var n=Fd.current;return Fd.current=Nd,n===null?Nd:n}function yv(){(Xt===0||Xt===3||Xt===2)&&(Xt=4),Jt===null||(yo&268435455)===0&&(ff&268435455)===0||as(Jt,an)}function Bd(n,e){var t=tt;tt|=2;var i=b1();(Jt!==n||an!==e)&&(xr=null,lo(n,e));do try{_I();break}catch(r){E1(n,r)}while(1);if(nv(),tt=t,Fd.current=i,kt!==null)throw Error(ve(261));return Jt=null,an=0,Xt}function _I(){for(;kt!==null;)T1(kt)}function xI(){for(;kt!==null&&!W3();)T1(kt)}function T1(n){var e=R1(n.alternate,n,Yn);n.memoizedProps=n.pendingProps,e===null?A1(n):kt=e,mv.current=null}function A1(n){var e=n;do{var t=e.alternate;if(n=e.return,(e.flags&32768)===0){if(t=hI(t,e,Yn),t!==null){kt=t;return}}else{if(t=dI(t,e),t!==null){t.flags&=32767,kt=t;return}if(n!==null)n.flags|=32768,n.subtreeFlags=0,n.deletions=null;else{Xt=6,kt=null;return}}if(e=e.sibling,e!==null){kt=e;return}kt=e=n}while(e!==null);Xt===0&&(Xt=5)}function qs(n,e,t){var i=ct,r=fi.transition;try{fi.transition=null,ct=1,yI(n,e,t,i)}finally{fi.transition=r,ct=i}return null}function yI(n,e,t,i){do Ga();while(us!==null);if((tt&6)!==0)throw Error(ve(327));t=n.finishedWork;var r=n.finishedLanes;if(t===null)return null;if(n.finishedWork=null,n.finishedLanes=0,t===n.current)throw Error(ve(177));n.callbackNode=null,n.callbackPriority=0;var s=t.lanes|t.childLanes;if(eD(n,s),n===Jt&&(kt=Jt=null,an=0),(t.subtreeFlags&2064)===0&&(t.flags&2064)===0||Sh||(Sh=!0,L1(xd,function(){return Ga(),null})),s=(t.flags&15990)!==0,(t.subtreeFlags&15990)!==0||s){s=fi.transition,fi.transition=null;var o=ct;ct=1;var a=tt;tt|=4,mv.current=null,pI(n,t),M1(t,n),kD(yg),Md=!!xg,yg=xg=null,n.current=t,mI(t),$3(),tt=a,ct=o,fi.transition=s}else n.current=t;if(Sh&&(Sh=!1,us=n,Od=r),s=n.pendingLanes,s===0&&(ys=null),q3(t.stateNode),zn(n,Ft()),e!==null)for(i=n.onRecoverableError,t=0;t<e.length;t++)r=e[t],i(r.value,{componentStack:r.stack,digest:r.digest});if(Ud)throw Ud=!1,n=kg,kg=null,n;return(Od&1)!==0&&n.tag!==0&&Ga(),s=n.pendingLanes,(s&1)!==0?n===Hg?Ic++:(Ic=0,Hg=n):Ic=0,Ns(),null}function Ga(){if(us!==null){var n=oE(Od),e=fi.transition,t=ct;try{if(fi.transition=null,ct=16>n?16:n,us===null)var i=!1;else{if(n=us,us=null,Od=0,(tt&6)!==0)throw Error(ve(331));var r=tt;for(tt|=4,Ue=n.current;Ue!==null;){var s=Ue,o=s.child;if((Ue.flags&16)!==0){var a=s.deletions;if(a!==null){for(var l=0;l<a.length;l++){var c=a[l];for(Ue=c;Ue!==null;){var u=Ue;switch(u.tag){case 0:case 11:case 15:Pc(8,u,s)}var h=u.child;if(h!==null)h.return=u,Ue=h;else for(;Ue!==null;){u=Ue;var d=u.sibling,p=u.return;if(_1(u),u===c){Ue=null;break}if(d!==null){d.return=p,Ue=d;break}Ue=p}}}var v=s.alternate;if(v!==null){var m=v.child;if(m!==null){v.child=null;do{var f=m.sibling;m.sibling=null,m=f}while(m!==null)}}Ue=s}}if((s.subtreeFlags&2064)!==0&&o!==null)o.return=s,Ue=o;else e:for(;Ue!==null;){if(s=Ue,(s.flags&2048)!==0)switch(s.tag){case 0:case 11:case 15:Pc(9,s,s.return)}var g=s.sibling;if(g!==null){g.return=s.return,Ue=g;break e}Ue=s.return}}var _=n.current;for(Ue=_;Ue!==null;){o=Ue;var M=o.child;if((o.subtreeFlags&2064)!==0&&M!==null)M.return=o,Ue=M;else e:for(o=_;Ue!==null;){if(a=Ue,(a.flags&2048)!==0)try{switch(a.tag){case 0:case 11:case 15:df(9,a)}}catch(S){Ct(a,a.return,S)}if(a===o){Ue=null;break e}var E=a.sibling;if(E!==null){E.return=a.return,Ue=E;break e}Ue=a.return}}if(tt=r,Ns(),Qi&&typeof Qi.onPostCommitFiberRoot=="function")try{Qi.onPostCommitFiberRoot(rf,n)}catch{}i=!0}return i}finally{ct=t,fi.transition=e}}return!1}function Ly(n,e,t){e=al(t,e),e=a1(n,e,1),n=xs(n,e,1),e=Tn(),n!==null&&(Mu(n,1,e),zn(n,e))}function Ct(n,e,t){if(n.tag===3)Ly(n,n,t);else for(;e!==null;){if(e.tag===3){Ly(e,n,t);break}else if(e.tag===1){var i=e.stateNode;if(typeof e.type.getDerivedStateFromError=="function"||typeof i.componentDidCatch=="function"&&(ys===null||!ys.has(i))){n=al(t,n),n=l1(e,n,1),e=xs(e,n,1),n=Tn(),e!==null&&(Mu(e,1,n),zn(e,n));break}}e=e.return}}function MI(n,e,t){var i=n.pingCache;i!==null&&i.delete(e),e=Tn(),n.pingedLanes|=n.suspendedLanes&t,Jt===n&&(an&t)===t&&(Xt===4||Xt===3&&(an&130023424)===an&&500>Ft()-vv?lo(n,0):gv|=t),zn(n,e)}function C1(n,e){e===0&&((n.mode&1)===0?e=1:(e=dh,dh<<=1,(dh&130023424)===0&&(dh=4194304)));var t=Tn();n=Nr(n,e),n!==null&&(Mu(n,e,t),zn(n,t))}function SI(n){var e=n.memoizedState,t=0;e!==null&&(t=e.retryLane),C1(n,t)}function wI(n,e){var t=0;switch(n.tag){case 13:var i=n.stateNode,r=n.memoizedState;r!==null&&(t=r.retryLane);break;case 19:i=n.stateNode;break;default:throw Error(ve(314))}i!==null&&i.delete(e),C1(n,t)}var R1;R1=function(n,e,t){if(n!==null)if(n.memoizedProps!==e.pendingProps||On.current)Un=!0;else{if((n.lanes&t)===0&&(e.flags&128)===0)return Un=!1,uI(n,e,t);Un=(n.flags&131072)!==0}else Un=!1,xt&&(e.flags&1048576)!==0&&DE(e,Cd,e.index);switch(e.lanes=0,e.tag){case 2:var i=e.type;nd(n,e),n=e.pendingProps;var r=il(e,xn.current);Ha(e,t),r=uv(null,e,i,n,r,t);var s=hv();return e.flags|=1,typeof r=="object"&&r!==null&&typeof r.render=="function"&&r.$$typeof===void 0?(e.tag=1,e.memoizedState=null,e.updateQueue=null,Bn(i)?(s=!0,Td(e)):s=!1,e.memoizedState=r.state!==null&&r.state!==void 0?r.state:null,sv(e),r.updater=uf,e.stateNode=r,r._reactInternals=e,Rg(e,i,n,t),e=Dg(null,e,i,!0,s,t)):(e.tag=0,xt&&s&&J0(e),En(null,e,r,t),e=e.child),e;case 16:i=e.elementType;e:{switch(nd(n,e),n=e.pendingProps,r=i._init,i=r(i._payload),e.type=i,r=e.tag=bI(i),n=Pi(i,n),r){case 0:e=Pg(null,e,i,n,t);break e;case 1:e=yy(null,e,i,n,t);break e;case 11:e=_y(null,e,i,n,t);break e;case 14:e=xy(null,e,i,Pi(i.type,n),t);break e}throw Error(ve(306,i,""))}return e;case 0:return i=e.type,r=e.pendingProps,r=e.elementType===i?r:Pi(i,r),Pg(n,e,i,r,t);case 1:return i=e.type,r=e.pendingProps,r=e.elementType===i?r:Pi(i,r),yy(n,e,i,r,t);case 3:e:{if(d1(e),n===null)throw Error(ve(387));i=e.pendingProps,s=e.memoizedState,r=s.element,UE(n,e),Pd(e,i,null,t);var o=e.memoizedState;if(i=o.element,s.isDehydrated)if(s={element:i,isDehydrated:!1,cache:o.cache,pendingSuspenseBoundaries:o.pendingSuspenseBoundaries,transitions:o.transitions},e.updateQueue.baseState=s,e.memoizedState=s,e.flags&256){r=al(Error(ve(423)),e),e=My(n,e,i,t,r);break e}else if(i!==r){r=al(Error(ve(424)),e),e=My(n,e,i,t,r);break e}else for(Zn=_s(e.stateNode.containerInfo.firstChild),Qn=e,xt=!0,Ii=null,t=kE(e,null,i,t),e.child=t;t;)t.flags=t.flags&-3|4096,t=t.sibling;else{if(rl(),i===r){e=Fr(n,e,t);break e}En(n,e,i,t)}e=e.child}return e;case 5:return HE(e),n===null&&Tg(e),i=e.type,r=e.pendingProps,s=n!==null?n.memoizedProps:null,o=r.children,Mg(i,r)?o=null:s!==null&&Mg(i,s)&&(e.flags|=32),h1(n,e),En(n,e,o,t),e.child;case 6:return n===null&&Tg(e),null;case 13:return f1(n,e,t);case 4:return ov(e,e.stateNode.containerInfo),i=e.pendingProps,n===null?e.child=sl(e,null,i,t):En(n,e,i,t),e.child;case 11:return i=e.type,r=e.pendingProps,r=e.elementType===i?r:Pi(i,r),_y(n,e,i,r,t);case 7:return En(n,e,e.pendingProps,t),e.child;case 8:return En(n,e,e.pendingProps.children,t),e.child;case 12:return En(n,e,e.pendingProps.children,t),e.child;case 10:e:{if(i=e.type._context,r=e.pendingProps,s=e.memoizedProps,o=r.value,pt(Rd,i._currentValue),i._currentValue=o,s!==null)if(Vi(s.value,o)){if(s.children===r.children&&!On.current){e=Fr(n,e,t);break e}}else for(s=e.child,s!==null&&(s.return=e);s!==null;){var a=s.dependencies;if(a!==null){o=s.child;for(var l=a.firstContext;l!==null;){if(l.context===i){if(s.tag===1){l=Cr(-1,t&-t),l.tag=2;var c=s.updateQueue;if(c!==null){c=c.shared;var u=c.pending;u===null?l.next=l:(l.next=u.next,u.next=l),c.pending=l}}s.lanes|=t,l=s.alternate,l!==null&&(l.lanes|=t),Ag(s.return,t,e),a.lanes|=t;break}l=l.next}}else if(s.tag===10)o=s.type===e.type?null:s.child;else if(s.tag===18){if(o=s.return,o===null)throw Error(ve(341));o.lanes|=t,a=o.alternate,a!==null&&(a.lanes|=t),Ag(o,t,e),o=s.sibling}else o=s.child;if(o!==null)o.return=s;else for(o=s;o!==null;){if(o===e){o=null;break}if(s=o.sibling,s!==null){s.return=o.return,o=s;break}o=o.return}s=o}En(n,e,r.children,t),e=e.child}return e;case 9:return r=e.type,i=e.pendingProps.children,Ha(e,t),r=gi(r),i=i(r),e.flags|=1,En(n,e,i,t),e.child;case 14:return i=e.type,r=Pi(i,e.pendingProps),r=Pi(i.type,r),xy(n,e,i,r,t);case 15:return c1(n,e,e.type,e.pendingProps,t);case 17:return i=e.type,r=e.pendingProps,r=e.elementType===i?r:Pi(i,r),nd(n,e),e.tag=1,Bn(i)?(n=!0,Td(e)):n=!1,Ha(e,t),BE(e,i,r),Rg(e,i,r,t),Dg(null,e,i,!0,n,t);case 19:return p1(n,e,t);case 22:return u1(n,e,t)}throw Error(ve(156,e.tag))};function L1(n,e){return nE(n,e)}function EI(n,e,t,i){this.tag=n,this.key=t,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=i,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function hi(n,e,t,i){return new EI(n,e,t,i)}function Mv(n){return n=n.prototype,!(!n||!n.isReactComponent)}function bI(n){if(typeof n=="function")return Mv(n)?1:0;if(n!=null){if(n=n.$$typeof,n===k0)return 11;if(n===H0)return 14}return 2}function Ss(n,e){var t=n.alternate;return t===null?(t=hi(n.tag,e,n.key,n.mode),t.elementType=n.elementType,t.type=n.type,t.stateNode=n.stateNode,t.alternate=n,n.alternate=t):(t.pendingProps=e,t.type=n.type,t.flags=0,t.subtreeFlags=0,t.deletions=null),t.flags=n.flags&14680064,t.childLanes=n.childLanes,t.lanes=n.lanes,t.child=n.child,t.memoizedProps=n.memoizedProps,t.memoizedState=n.memoizedState,t.updateQueue=n.updateQueue,e=n.dependencies,t.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext},t.sibling=n.sibling,t.index=n.index,t.ref=n.ref,t}function sd(n,e,t,i,r,s){var o=2;if(i=n,typeof n=="function")Mv(n)&&(o=1);else if(typeof n=="string")o=5;else e:switch(n){case wa:return co(t.children,r,s,e);case z0:o=8,r|=8;break;case Qm:return n=hi(12,t,e,r|2),n.elementType=Qm,n.lanes=s,n;case eg:return n=hi(13,t,e,r),n.elementType=eg,n.lanes=s,n;case tg:return n=hi(19,t,e,r),n.elementType=tg,n.lanes=s,n;case zw:return pf(t,r,s,e);default:if(typeof n=="object"&&n!==null)switch(n.$$typeof){case Ow:o=10;break e;case Bw:o=9;break e;case k0:o=11;break e;case H0:o=14;break e;case ns:o=16,i=null;break e}throw Error(ve(130,n==null?n:typeof n,""))}return e=hi(o,t,e,r),e.elementType=n,e.type=i,e.lanes=s,e}function co(n,e,t,i){return n=hi(7,n,i,e),n.lanes=t,n}function pf(n,e,t,i){return n=hi(22,n,i,e),n.elementType=zw,n.lanes=t,n.stateNode={isHidden:!1},n}function Vp(n,e,t){return n=hi(6,n,null,e),n.lanes=t,n}function Wp(n,e,t){return e=hi(4,n.children!==null?n.children:[],n.key,e),e.lanes=t,e.stateNode={containerInfo:n.containerInfo,pendingChildren:null,implementation:n.implementation},e}function TI(n,e,t,i,r){this.tag=e,this.containerInfo=n,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Ep(0),this.expirationTimes=Ep(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Ep(0),this.identifierPrefix=i,this.onRecoverableError=r,this.mutableSourceEagerHydrationData=null}function Sv(n,e,t,i,r,s,o,a,l){return n=new TI(n,e,t,a,l),e===1?(e=1,s===!0&&(e|=8)):e=0,s=hi(3,null,null,e),n.current=s,s.stateNode=n,s.memoizedState={element:i,isDehydrated:t,cache:null,transitions:null,pendingSuspenseBoundaries:null},sv(s),n}function AI(n,e,t){var i=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:Sa,key:i==null?null:""+i,children:n,containerInfo:e,implementation:t}}function P1(n){if(!n)return Cs;n=n._reactInternals;e:{if(Po(n)!==n||n.tag!==1)throw Error(ve(170));var e=n;do{switch(e.tag){case 3:e=e.stateNode.context;break e;case 1:if(Bn(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break e}}e=e.return}while(e!==null);throw Error(ve(171))}if(n.tag===1){var t=n.type;if(Bn(t))return LE(n,t,e)}return e}function D1(n,e,t,i,r,s,o,a,l){return n=Sv(t,i,!0,n,r,s,o,a,l),n.context=P1(null),t=n.current,i=Tn(),r=Ms(t),s=Cr(i,r),s.callback=e!=null?e:null,xs(t,s,r),n.current.lanes=r,Mu(n,r,i),zn(n,i),n}function mf(n,e,t,i){var r=e.current,s=Tn(),o=Ms(r);return t=P1(t),e.context===null?e.context=t:e.pendingContext=t,e=Cr(s,o),e.payload={element:n},i=i===void 0?null:i,i!==null&&(e.callback=i),n=xs(r,e,o),n!==null&&(ki(n,r,o,s),Qh(n,r,o)),o}function zd(n){if(n=n.current,!n.child)return null;switch(n.child.tag){case 5:return n.child.stateNode;default:return n.child.stateNode}}function Py(n,e){if(n=n.memoizedState,n!==null&&n.dehydrated!==null){var t=n.retryLane;n.retryLane=t!==0&&t<e?t:e}}function wv(n,e){Py(n,e),(n=n.alternate)&&Py(n,e)}function CI(){return null}var I1=typeof reportError=="function"?reportError:function(n){console.error(n)};function Ev(n){this._internalRoot=n}gf.prototype.render=Ev.prototype.render=function(n){var e=this._internalRoot;if(e===null)throw Error(ve(409));mf(n,e,null,null)};gf.prototype.unmount=Ev.prototype.unmount=function(){var n=this._internalRoot;if(n!==null){this._internalRoot=null;var e=n.containerInfo;Mo(function(){mf(null,n,null,null)}),e[Ir]=null}};function gf(n){this._internalRoot=n}gf.prototype.unstable_scheduleHydration=function(n){if(n){var e=cE();n={blockedOn:null,target:n,priority:e};for(var t=0;t<os.length&&e!==0&&e<os[t].priority;t++);os.splice(t,0,n),t===0&&hE(n)}};function bv(n){return!(!n||n.nodeType!==1&&n.nodeType!==9&&n.nodeType!==11)}function vf(n){return!(!n||n.nodeType!==1&&n.nodeType!==9&&n.nodeType!==11&&(n.nodeType!==8||n.nodeValue!==" react-mount-point-unstable "))}function Dy(){}function RI(n,e,t,i,r){if(r){if(typeof i=="function"){var s=i;i=function(){var c=zd(o);s.call(c)}}var o=D1(e,i,n,0,null,!1,!1,"",Dy);return n._reactRootContainer=o,n[Ir]=o.current,Qc(n.nodeType===8?n.parentNode:n),Mo(),o}for(;r=n.lastChild;)n.removeChild(r);if(typeof i=="function"){var a=i;i=function(){var c=zd(l);a.call(c)}}var l=Sv(n,0,!1,null,null,!1,!1,"",Dy);return n._reactRootContainer=l,n[Ir]=l.current,Qc(n.nodeType===8?n.parentNode:n),Mo(function(){mf(e,l,t,i)}),l}function _f(n,e,t,i,r){var s=t._reactRootContainer;if(s){var o=s;if(typeof r=="function"){var a=r;r=function(){var l=zd(o);a.call(l)}}mf(e,o,n,r)}else o=RI(t,e,n,r,i);return zd(o)}aE=function(n){switch(n.tag){case 3:var e=n.stateNode;if(e.current.memoizedState.isDehydrated){var t=fc(e.pendingLanes);t!==0&&(W0(e,t|1),zn(e,Ft()),(tt&6)===0&&(ll=Ft()+500,Ns()))}break;case 13:Mo(function(){var i=Nr(n,1);if(i!==null){var r=Tn();ki(i,n,1,r)}}),wv(n,1)}};$0=function(n){if(n.tag===13){var e=Nr(n,134217728);if(e!==null){var t=Tn();ki(e,n,134217728,t)}wv(n,134217728)}};lE=function(n){if(n.tag===13){var e=Ms(n),t=Nr(n,e);if(t!==null){var i=Tn();ki(t,n,e,i)}wv(n,e)}};cE=function(){return ct};uE=function(n,e){var t=ct;try{return ct=n,e()}finally{ct=t}};hg=function(n,e,t){switch(e){case"input":if(rg(n,t),e=t.name,t.type==="radio"&&e!=null){for(t=n;t.parentNode;)t=t.parentNode;for(t=t.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<t.length;e++){var i=t[e];if(i!==n&&i.form===n.form){var r=lf(i);if(!r)throw Error(ve(90));Hw(i),rg(i,r)}}}break;case"textarea":Vw(n,t);break;case"select":e=t.value,e!=null&&Oa(n,!!t.multiple,e,!1)}};Kw=_v;Zw=Mo;var LI={usingClientEntryPoint:!1,Events:[wu,Aa,lf,qw,Yw,_v]},Ql={findFiberByHostInstance:to,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},PI={bundleType:Ql.bundleType,version:Ql.version,rendererPackageName:Ql.rendererPackageName,rendererConfig:Ql.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Or.ReactCurrentDispatcher,findHostInstanceByFiber:function(n){return n=eE(n),n===null?null:n.stateNode},findFiberByHostInstance:Ql.findFiberByHostInstance||CI,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!="undefined"){var wh=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!wh.isDisabled&&wh.supportsFiber)try{rf=wh.inject(PI),Qi=wh}catch{}}ti.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=LI;ti.createPortal=function(n,e){var t=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!bv(e))throw Error(ve(200));return AI(n,e,null,t)};ti.createRoot=function(n,e){if(!bv(n))throw Error(ve(299));var t=!1,i="",r=I1;return e!=null&&(e.unstable_strictMode===!0&&(t=!0),e.identifierPrefix!==void 0&&(i=e.identifierPrefix),e.onRecoverableError!==void 0&&(r=e.onRecoverableError)),e=Sv(n,1,!1,null,null,t,!1,i,r),n[Ir]=e.current,Qc(n.nodeType===8?n.parentNode:n),new Ev(e)};ti.findDOMNode=function(n){if(n==null)return null;if(n.nodeType===1)return n;var e=n._reactInternals;if(e===void 0)throw typeof n.render=="function"?Error(ve(188)):(n=Object.keys(n).join(","),Error(ve(268,n)));return n=eE(e),n=n===null?null:n.stateNode,n};ti.flushSync=function(n){return Mo(n)};ti.hydrate=function(n,e,t){if(!vf(e))throw Error(ve(200));return _f(null,n,e,!0,t)};ti.hydrateRoot=function(n,e,t){if(!bv(n))throw Error(ve(405));var i=t!=null&&t.hydratedSources||null,r=!1,s="",o=I1;if(t!=null&&(t.unstable_strictMode===!0&&(r=!0),t.identifierPrefix!==void 0&&(s=t.identifierPrefix),t.onRecoverableError!==void 0&&(o=t.onRecoverableError)),e=D1(e,null,n,1,t!=null?t:null,r,!1,s,o),n[Ir]=e.current,Qc(n),i)for(n=0;n<i.length;n++)t=i[n],r=t._getVersion,r=r(t._source),e.mutableSourceEagerHydrationData==null?e.mutableSourceEagerHydrationData=[t,r]:e.mutableSourceEagerHydrationData.push(t,r);return new gf(e)};ti.render=function(n,e,t){if(!vf(e))throw Error(ve(200));return _f(null,n,e,!1,t)};ti.unmountComponentAtNode=function(n){if(!vf(n))throw Error(ve(40));return n._reactRootContainer?(Mo(function(){_f(null,null,n,!1,function(){n._reactRootContainer=null,n[Ir]=null})}),!0):!1};ti.unstable_batchedUpdates=_v;ti.unstable_renderSubtreeIntoContainer=function(n,e,t,i){if(!vf(t))throw Error(ve(200));if(n==null||n._reactInternals===void 0)throw Error(ve(38));return _f(n,e,t,!1,i)};ti.version="18.2.0-next-9e3b772b8-20220608";function N1(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__=="undefined"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(N1)}catch(n){console.error(n)}}N1(),Dw.exports=ti;var F1,DI=Dw.exports;F1=DI.createRoot;var II="/assets/felix-faces.bcde1648.png",U1="/assets/father_time_content.562e5c05.png",Wg="/assets/father_time_laughter.d02796b3.png",NI="/assets/father_time_upset.0a37fd44.png",FI="/assets/father_time_rage.57217020.png",UI="/assets/felix-ouch.af684ced.wav",OI="/assets/father-happy.94cddfa0.mp3",BI="/assets/father-content.a733a4c6.mp3",zI="/assets/father-irritated.b7b1ad82.mp3",kI="/assets/father-angry.8744e6be.mp3",HI="/assets/stoneage-spawn.2499d6c8.mp3",GI="/assets/ancient-spawn.32bbf6d1.mp3",VI="/assets/industrial-spawn.27e36908.mp3",WI="/assets/prohibition-spawn.f0666143.mp3",$I="/assets/upgrade-show.d3cfa1a4.mp3",XI="/assets/game-over.ec90703e.mp3",jI="/assets/catnip2.c960b7bf.wav",qI="/assets/catnip1.59fcbf32.wav",YI="data:audio/wav;base64,UklGRl4LAABXQVZFZm10IBAAAAABAAEARKwAAESsAAABAAgAZGF0YToLAACHlaGrtLq/wcLAvLWupJqOgnZpXVJHPTYvKykoKi0yOUFKVmJteoaSn6q0vcTKzc/PzcjDu7KonZGFeW1hVkxDPDYyLy4vMjY8Q0tVX2t1go6Yo663v8bLz9HRz8vGwLivpZqPg3hsYVdORT44MzEvMDE1OkBHT1hjbniDjZijrba+xMrO0NHQzcnEvratpJqPhHlvZFpRSUI8NzMxMDEzNjpAR09XYWp0fomSnKavt77Fyc3P0M/NysbAubGpoJaMgnhuZFtSS0Q+OTUyMTEyNDg8QkhPV2BocnuFjpegqLG4v8TJzM7Pz83Lx8K8ta6mnZSLgXhuZl1VTUdAPDg1MzIyMzU4PEJHTlVdZW52f4eQmKGpsbi+w8fLzc7OzszJxcC7tK6mnpaNhHxzamJaU0xHQT05NjQzMzM1ODs/REpQVl1lbXR9hI2UnKSrsri+w8fKzM3OzczJxsK+uLKspZ6WjoZ+dm5nX1hRTEdBPTo3NTQ0NDU3Oj1BRktQV11ja3J5gIePlp2jqrC2u8DEx8nLzMzMysjFwr65tK6ooZuUjIV+d3BoYlxVUEpGQj47OTc2NTU2ODo8QENITFFXXWJpb3V9g4mQlp2iqK60uL3BxMfJysvLysnHxcK/u7axrKahm5SOh4B6dG1nYVtWUUxIREA9Ozk4Nzc3ODk7PUBDR0pPVFhdY2ludHqAhouRlpyhpquwtbm9wMPFx8jJycnIx8XDwL25tbGsp6Kdl5KMhoB6dW9pZF5aVVFMSUVCQD08Ojk5OTk6Oz0+QUNGSk1RVVpeY2htcnd8gYaLkZWanqOnrLC0uLu+wMLExsbHx8fGxcPBv7y5trKuqqainZiTjomEfnl0cGtmYV1ZVVFNSkdFQ0E/PTw8Ozs7PD0+QEJERklMT1JWWV1hZWlucnd7f4SIjJCVmZ2gpKerr7K1uLu9v8HCw8TExMTEw8HAvry6t7Sxrqqno5+bl5OOioaBfXh0cGxoZGBcWVZSUE1KSEZEQkFAPz8+Pj4/QEBCQ0RGSEpNT1JVWFteYWVoa29zdnp+gYWIjJCTl5qdoKOmqayvsbS2ubq8vr/AwMHBwcHAwL+9vLq5trSyr62qp6SgnZqWk4+MiISBfXl2cm9raGViX1xZVlRRT01LSkhHRkREQ0JCQkJCQ0NERUZHSUpMTU9RVFZYW11gYmVoa25wc3Z5fH+ChYiLjpCTlpibnZ+ipKaoq62vsbO1tri5uru8vL29vb28vLu6ubi3trSysK+sqqimo6Gem5mWk5CNioeFgn98eXZzcG5raWZjYV9dWlhXVVNRUE9NTEtKSUlISEdHR0dHR0hISUpKS0xNT1BRU1RWWFlbXV9hY2VnaWtucHJ0d3l7fX+ChIaIioyPkZKUl5manJ6foaOkpaepqqyur7Cys7S1tba2t7e3t7e3t7e2tbW0s7KxsK6trKqop6WjoaCenJqXlZORj42LiIaEgn99e3l3dXNxb21raWdlY2JgX11cWllYVlVUU1JRUVBQT09OTk1NTU1NTU1OTk9PT1BRUVJTVFVWV1hZWltcXl9gYmNkZmdpamxtb3BydHV3eHp7fX+AgoOFhoiJi4yNj5CRk5SVl5iZmpucnZ6foKGioqOkpaeoqaqrrKytrq6vr6+wsLCwsLCwsK+vr66uraysq6qpqKempaSjoqGfnp2bmpmXlpSTkZCOjYuKiIeFhIKBf358e3l4dnVzcnFvbm1samloZ2ZlZGNiYWBfXl1dXFtaWllZWFhXV1dWVlZWVlVVVVVVVVZWVlZWVldXWFhYWVlaWltcXF1dXl9gYGFiY2NkZWZnaGlpamtsbW5vcHFyc3R1dnd4eXp7e3x9fn+AgYKDhIWGh4eIiYqLi4yNjo+PkJGRkpOTlJWVlpaXmJiYmZmampubm5ycnZ2dnZ6en6CgoaKio6OkpKWlpaampqampqampqampqampaWlpKSko6OioqGhoKCfnp6dnJybmpmZmJeWlZSUk5KRkI+OjY2Mi4qJiIeGhYSDg4KBgH9+fXx8e3p5eHd3dnV0c3NycXFwb25ubW1sa2tqamlpaGhnZ2ZmZWVkZGRjY2NiYmJiYWFhYWFgYGBgYGBgYGBgYGBgYGBgYGBgYGBhYWFhYWFiYmJiY2NjY2RkZGRlZWVmZmZnZ2doaGlpaWpqa2trbGxtbW5ubm9vcHBxcXJyc3NzdHR1dXZ2d3d3eHh5eXp6e3t7fHx9fX5+fn9/gICAgYGCgoKDg4SEhIWFhYaGhoeHh4iIiImJiYmKioqLi4uLjIyMjI2NjY2Njo6Ojo6Pj4+Pj5CQkJCQkJCRkZGRkZGRkZGSkpKSkpKSkpKSkpKSkpKSkpKSkpKTkpKTlJSVlZaWl5eXmJiYmJmZmZmZmZqampqampqampqampqamZmZmZmZmZiYmJiYl5eXl5aWlpaVlZWUlJSTk5OSkpKRkZGQkJCPj46Ojo2NjYyMi4uLioqJiYmIiIiHh4aGhoWFhISEg4ODgoKBgYGAgIB/f39+fn59fX18fHx7e3t6enp5eXl5eHh4d3d3d3Z2dnZ1dXV1dHR0dHRzc3Nzc3JycnJycXFxcXFxcXBwcHBwcHBvb29vb29vb29vb25ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubW5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5vb29vb29vb29vb29vcHBwcHBwcHBwcHBwcXFxcXFxcXFxcXJycnJycnJycnJzc3Nzc3Nzc3N0dHR0dHR0dHR1dXV1dXV1dXV2dnZ2dnZ2dnZ3d3d3d3d3d3d3eHh4eHh4eHh4eXl5eXl5eXl5eXp6enp6enp6enp7e3t7e3t7e3t7e3x8fHx8fHx8fHx8fH19fX19fX19fX19fX1+fn5+fn5+fn5+fn5+fn5/f39/f39/f39/f39/f39/f4CAgICAgICAgICAgICAgICAgICAgIGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAf39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f35+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn4=",KI="/assets/medium-hit.95b72ae5.wav",ZI="/assets/big-hit.40b46989.mp3",JI="/assets/arrow.47cb4b3e.mp3",QI="/assets/hammer.356294e2.mp3",eN="/assets/smokey.787e95e3.mp3",tN="/assets/sword.1080beda.mp3",nN="/assets/trap.fcf8bce4.mp3",iN="/assets/Music-stoneage.30e03889.mp3",rN="/assets/Music-ancient.8a0e1d7b.mp3",sN="/assets/Music-industrial.99c696a5.mp3",oN="/assets/Music-prohibition.f152b1a7.mp3",aN="/assets/Music-upgrade.a2349202.mp3",lN="/assets/Music-endloop.818e762d.mp3",cN="/assets/Music-victory.b9214dfc.mp3",uN="/assets/WakeUpFelix.a3a3a5ee.mp3";class st{constructor(e,t=1,i=0,r=!1){this.ready=!1,this.playedOnce=!1,this.backup=null,this.audio=new Audio(e),this.audio.volume=t,this.audio.addEventListener("canplaythrough",()=>{this.ready=!0}),this.audio.loop=r,i>0&&(this.backup=new st(e,t,i-1))}play(){this.ready&&(this.playedOnce&&!this.audio.ended&&this.backup?this.backup.play():(this.audio.play(),this.playedOnce=!0))}pause(){this.audio.pause()}}const hN=new st(UI,.5),dN=new st(OI),fN=new st(BI),pN=new st(zI),mN=new st(kI),gN=new st(HI),vN=new st(GI),_N=new st(VI),xN=new st(WI),yN=new st($I,.3),MN=new st(jI,.4,7),SN=new st(qI,.4,5),xf=new st(YI,.2,10),yf=new st(KI,.2,3),Mf=new st(ZI,.2,3),wN=new st(XI,.75),Iy=new st(iN,.7,0,!0),EN=new st(rN,.7),bN=new st(sN,.35),TN=new st(oN,.15),$p=new st(aN,.9,0,!0),Xp=new st(lN,.25,0,!0),AN=new st(cN,.2,0,!0),CN=new st(JI,.2,0,!1);new st(QI,1,0,!1);const RN=new st(nN,.3,0,!1),LN=new st(eN,1,0,!1),PN=new st(tN,1,0,!1),DN=new st(uN,1);var Ny=[{id:"MORE_SPEED",name:"More Speed",description:"You're faster.",scalarLabel:n=>`${n} of usual speed bonus`},{id:"MORE_WEAPON_DAMAGE",name:"More Damage",description:"Your weapons do more damage.",scalarLabel:n=>`${n} of usual damage bonus`},{id:"HEAL_NOW",name:"Heal Me!",description:"Get a heal right now.",scalarLabel:(n,e,t)=>`+${Math.floor(e)} HP (currently at ${t} HP)`},{id:"SLOWER_ENEMIES",name:"Slow Enemies",description:"Enemies are slower.",scalarLabel:n=>`${n} of usual slow-down`},{id:"PICK_UP_RANGE",name:"More Magnetic",description:"Pick up XP from farther away.",scalarLabel:n=>`${n} usual range increase`},{id:"LUCKY",name:"Lucky",description:"More likely to see rare XP gems.",scalarLabel:n=>`${n} usual chance increase`},{id:"FREEZE",name:"Stun All Enemies",description:"Every enemy on the clock becomes stunned for 15 seconds.",scalarLabel:n=>`${n} usual freeze duration`}];const O1={"1":{roman:"I",heading:"Fire an arrow out from the 1:00 angle on a clock.",elaborate:"This arrow doesn't stun enemies much, and you gotta aim it, but it fires fast, hits hard and has huge range!"},"2":{roman:"II",heading:"Swing a beefy hammer around you that gets larger when it is close to the 2:00 angle.",elaborate:"Not only does the number II hit powerfully, it also stuns enemies big time!"},"3":{roman:"III",heading:"Plant spiky traps every 3 seconds at the 3:00 angle. You can have 3 planted at once.",elaborate:"Time your steps and funnel enemies into your traps. They will stumble and stick as they take damage trying to wade through!"},"4":{roman:"IV",heading:"A deadly spear juts out from your 4:00 angle. It doesn't move but does lots of damage.",elaborate:"IV is the definition of simple but effective. Not very effective if enemies are above you!"},"5":{roman:"V",heading:"Surround yourself with protective shields and get 1 extra HP (for a total of 5:00).",elaborate:"More health always helps, not to mention this orbiting wall! The same enemy cannot be hit very frequently with these shields, so be careful."},"6":{roman:"VI",heading:"A magic scepter that hovers below you at 6:00. It fires orbs at random nearby enemies, but only 6 at a time.",elaborate:"This weapon excels against single enemies, but struggles against hordes."},"7":{roman:"VII",heading:"An energizing contraption that hovers at 7:00 and gives you a damaging aura. It also increases your pickup range!",elaborate:"You'll feel all charged up with this one! Anything that gets near you is zapped, but enemies with enough health will still power through it."},"8":{roman:"VIII",heading:"Every 8 seconds, spawn a huge smoke stack that damages and stuns enemies.",elaborate:"The smoke will absolutely incapacitate anything within it, but it will only spawn on a random enemy every 8 seconds. You will have to act fast to manuever your enemies into the smoke!"},"9":{roman:"IX",heading:"Spawn tesla coils that last 9 seconds and zap random enemies near it.",elaborate:"These coils are most effective when they cover different areas. Try to move out of range of any already placed coil to maximize damage!"},"10":{roman:"X",heading:"Toss ninja stars from the 10:00 angle and its mirrors. These have huge range and you'll throw them FAST!",elaborate:"This weapon is awesome for large hordes, but struggles when you have one huge enemy to kill."},"11":{roman:"XI",heading:"Every 11 seconds, axes will fly upwards and then fall through your enemies. These axes do MAJOR damage!",elaborate:"These axes do tons of damage, they're huge, and they last forever. Downside? Uhhhhhh ..."},"12":{roman:"XII",heading:"The power of the clock itself! Super powerful strips of light appear around you like a ticking clock.",elaborate:"Felix, this weapon is busted!"}};function B1(n,e){if(!Array.isArray(n))throw new Error("shuffle expect an array as parameter.");e=e||{};var t=n,i=n.length,r=e.rng||Math.random,s,o;for(e.copy===!0&&(t=n.slice());i;)s=Math.floor(r()*i),i-=1,o=t[i],t[i]=t[s],t[s]=o;return t}B1.pick=function(n,e){if(!Array.isArray(n))throw new Error("shuffle.pick() expect an array as parameter.");e=e||{};var t=e.rng||Math.random,i=e.picks||1;if(typeof i=="number"&&i!==1){for(var r=n.length,s=n.slice(),o=[],a;i&&r;)a=Math.floor(t()*r),o.push(s[a]),s.splice(a,1),r-=1,i-=1;return o}return n[Math.floor(t()*n.length)]};var mc=B1;const IN=({gameState:n,onSelect:e})=>{const{onUpgradeScreen:t,bagXps:i,expectedMinuteXp:r}=n,s=wt.exports.useMemo(()=>{let M=Ny.slice(0);return n.felixHP===n.felixMaxHP&&(M=M.filter(E=>E.name==="HEAL_NOW")),mc(Ny.slice(0)).slice(0,3)},[t]),o=wt.exports.useRef(null),[a,l]=wt.exports.useState(!1);wt.exports.useEffect(()=>{if(a&&o.current){const M=o.current,E=setInterval(()=>{M.style.opacity=`${parseFloat(M.style.opacity)-.05}`},10);return()=>clearInterval(E)}},[a]);const c=wt.exports.useMemo(()=>{if(!t)return null;const M=O1[t];if(!M)throw new Error(`No weapon details for minute ${t}`);return M},[t]),u=wt.exports.useMemo(()=>{if(!t)return null;const M=i.find(E=>E.minute===t);if(!M)throw new Error("No bagged XP for this minute upgrade.");return M.total},[t,i]),[h,d]=wt.exports.useState(0);if(wt.exports.useEffect(()=>{h<1&&setTimeout(()=>d(h+.1),20)},[h]),wt.exports.useEffect(()=>{if(t&&u&&r){const M=u/r;M>=1?M>=2?dN.play():fN.play():M<.5?mN.play():pN.play()}},[t,u,r]),r===null)throw new Error("Should not render without expectedMinuteXp.");if(!c||typeof u!="number")return null;const p=u/r,v=(p*100).toFixed(0)+"%",m=p>=1?"good":"bad",f=m==="good"?"!":" ...",g=(()=>p>=1?p>=2?Wg:U1:p<.5?FI:NI)(),_=3-n.chosenWeapons.length;return Q.createElement("div",{id:"upgrade-container",ref:o,style:{opacity:h}},Q.createElement("div",{className:"got-the-bag"},Q.createElement("h1",null,"You got the ",t,":00 bag!"),Q.createElement("div",{className:"xp-stats"},Q.createElement("div",{className:"scaling-result"},Q.createElement("img",{className:"father-time",src:g}),Q.createElement("div",null,Q.createElement("h3",null,"Time rings collected during this minute: ",Q.createElement("strong",null,u)),Q.createElement("h3",null,"Time rings needed by Father Time: ",Q.createElement("strong",null,r)),Q.createElement("h2",null,"This weapon or upgrade will be"," ",Q.createElement("strong",null,p.toFixed(2),"x")," as powerful!"))))),Q.createElement("div",{className:"divider"}),Q.createElement("div",{className:"selection-section"},_!==0&&Q.createElement("div",{className:"choose-weapon"},Q.createElement("div",{className:"weapon-description"},Q.createElement("h3",null,c.heading),Q.createElement("p",null,c.elaborate)),Q.createElement("h2",{onClick:()=>{a||(l(!0),e(!0,null,p))}},"Claim ",Q.createElement("br",null),Q.createElement("strong",null,c.roman),Q.createElement("br",null)," as your weapon",Q.createElement("span",{className:`bonus ${m}`},v," damage",f)),Q.createElement("h4",{className:"remaining-weapons"},"You can claim ",_," more"," ",_===1?"weapon":"weapons","!")),_===0&&Q.createElement("div",{className:"choose-weapon"},Q.createElement("h2",null,"You can't claim any more weapons.")),Q.createElement("div",{className:"divider-vertical"}),Q.createElement("div",{className:"choose-upgrade"},Q.createElement("h1",null,"Or, have an upgrade ..."),s.map(M=>Q.createElement("div",{className:"one-upgrade",key:M.id,onClick:()=>{a||(l(!0),e(!1,M.id,p))}},Q.createElement("h2",null,M.name),Q.createElement("p",null,M.description),Q.createElement("span",{className:`bonus ${m}`},M.scalarLabel(v,p,n.felixHP),f))))))};var NN="/assets/titleScreen.89149652.png",FN="/assets/ll.82b7be28.png",Tv={exports:{}},z1=function(e,t){return function(){for(var r=new Array(arguments.length),s=0;s<r.length;s++)r[s]=arguments[s];return e.apply(t,r)}},UN=z1,Av=Object.prototype.toString,Cv=function(n){return function(e){var t=Av.call(e);return n[t]||(n[t]=t.slice(8,-1).toLowerCase())}}(Object.create(null));function Do(n){return n=n.toLowerCase(),function(t){return Cv(t)===n}}function Rv(n){return Array.isArray(n)}function kd(n){return typeof n=="undefined"}function ON(n){return n!==null&&!kd(n)&&n.constructor!==null&&!kd(n.constructor)&&typeof n.constructor.isBuffer=="function"&&n.constructor.isBuffer(n)}var k1=Do("ArrayBuffer");function BN(n){var e;return typeof ArrayBuffer!="undefined"&&ArrayBuffer.isView?e=ArrayBuffer.isView(n):e=n&&n.buffer&&k1(n.buffer),e}function zN(n){return typeof n=="string"}function kN(n){return typeof n=="number"}function H1(n){return n!==null&&typeof n=="object"}function od(n){if(Cv(n)!=="object")return!1;var e=Object.getPrototypeOf(n);return e===null||e===Object.prototype}var HN=Do("Date"),GN=Do("File"),VN=Do("Blob"),WN=Do("FileList");function Lv(n){return Av.call(n)==="[object Function]"}function $N(n){return H1(n)&&Lv(n.pipe)}function XN(n){var e="[object FormData]";return n&&(typeof FormData=="function"&&n instanceof FormData||Av.call(n)===e||Lv(n.toString)&&n.toString()===e)}var jN=Do("URLSearchParams");function qN(n){return n.trim?n.trim():n.replace(/^\s+|\s+$/g,"")}function YN(){return typeof navigator!="undefined"&&(navigator.product==="ReactNative"||navigator.product==="NativeScript"||navigator.product==="NS")?!1:typeof window!="undefined"&&typeof document!="undefined"}function Pv(n,e){if(!(n===null||typeof n=="undefined"))if(typeof n!="object"&&(n=[n]),Rv(n))for(var t=0,i=n.length;t<i;t++)e.call(null,n[t],t,n);else for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&e.call(null,n[r],r,n)}function $g(){var n={};function e(r,s){od(n[s])&&od(r)?n[s]=$g(n[s],r):od(r)?n[s]=$g({},r):Rv(r)?n[s]=r.slice():n[s]=r}for(var t=0,i=arguments.length;t<i;t++)Pv(arguments[t],e);return n}function KN(n,e,t){return Pv(e,function(r,s){t&&typeof r=="function"?n[s]=UN(r,t):n[s]=r}),n}function ZN(n){return n.charCodeAt(0)===65279&&(n=n.slice(1)),n}function JN(n,e,t,i){n.prototype=Object.create(e.prototype,i),n.prototype.constructor=n,t&&Object.assign(n.prototype,t)}function QN(n,e,t){var i,r,s,o={};e=e||{};do{for(i=Object.getOwnPropertyNames(n),r=i.length;r-- >0;)s=i[r],o[s]||(e[s]=n[s],o[s]=!0);n=Object.getPrototypeOf(n)}while(n&&(!t||t(n,e))&&n!==Object.prototype);return e}function eF(n,e,t){n=String(n),(t===void 0||t>n.length)&&(t=n.length),t-=e.length;var i=n.indexOf(e,t);return i!==-1&&i===t}function tF(n){if(!n)return null;var e=n.length;if(kd(e))return null;for(var t=new Array(e);e-- >0;)t[e]=n[e];return t}var nF=function(n){return function(e){return n&&e instanceof n}}(typeof Uint8Array!="undefined"&&Object.getPrototypeOf(Uint8Array)),un={isArray:Rv,isArrayBuffer:k1,isBuffer:ON,isFormData:XN,isArrayBufferView:BN,isString:zN,isNumber:kN,isObject:H1,isPlainObject:od,isUndefined:kd,isDate:HN,isFile:GN,isBlob:VN,isFunction:Lv,isStream:$N,isURLSearchParams:jN,isStandardBrowserEnv:YN,forEach:Pv,merge:$g,extend:KN,trim:qN,stripBOM:ZN,inherits:JN,toFlatObject:QN,kindOf:Cv,kindOfTest:Do,endsWith:eF,toArray:tF,isTypedArray:nF,isFileList:WN},Jo=un;function Fy(n){return encodeURIComponent(n).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}var G1=function(e,t,i){if(!t)return e;var r;if(i)r=i(t);else if(Jo.isURLSearchParams(t))r=t.toString();else{var s=[];Jo.forEach(t,function(l,c){l===null||typeof l=="undefined"||(Jo.isArray(l)?c=c+"[]":l=[l],Jo.forEach(l,function(h){Jo.isDate(h)?h=h.toISOString():Jo.isObject(h)&&(h=JSON.stringify(h)),s.push(Fy(c)+"="+Fy(h))}))}),r=s.join("&")}if(r){var o=e.indexOf("#");o!==-1&&(e=e.slice(0,o)),e+=(e.indexOf("?")===-1?"?":"&")+r}return e},iF=un;function Sf(){this.handlers=[]}Sf.prototype.use=function(e,t,i){return this.handlers.push({fulfilled:e,rejected:t,synchronous:i?i.synchronous:!1,runWhen:i?i.runWhen:null}),this.handlers.length-1};Sf.prototype.eject=function(e){this.handlers[e]&&(this.handlers[e]=null)};Sf.prototype.forEach=function(e){iF.forEach(this.handlers,function(i){i!==null&&e(i)})};var rF=Sf,sF=un,oF=function(e,t){sF.forEach(e,function(r,s){s!==t&&s.toUpperCase()===t.toUpperCase()&&(e[t]=r,delete e[s])})},V1=un;function cl(n,e,t,i,r){Error.call(this),this.message=n,this.name="AxiosError",e&&(this.code=e),t&&(this.config=t),i&&(this.request=i),r&&(this.response=r)}V1.inherits(cl,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:this.config,code:this.code,status:this.response&&this.response.status?this.response.status:null}}});var W1=cl.prototype,$1={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED"].forEach(function(n){$1[n]={value:n}});Object.defineProperties(cl,$1);Object.defineProperty(W1,"isAxiosError",{value:!0});cl.from=function(n,e,t,i,r,s){var o=Object.create(W1);return V1.toFlatObject(n,o,function(l){return l!==Error.prototype}),cl.call(o,n.message,e,t,i,r),o.name=n.name,s&&Object.assign(o,s),o};var Rl=cl,X1={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},Ti=un;function aF(n,e){e=e||new FormData;var t=[];function i(s){return s===null?"":Ti.isDate(s)?s.toISOString():Ti.isArrayBuffer(s)||Ti.isTypedArray(s)?typeof Blob=="function"?new Blob([s]):Buffer.from(s):s}function r(s,o){if(Ti.isPlainObject(s)||Ti.isArray(s)){if(t.indexOf(s)!==-1)throw Error("Circular reference detected in "+o);t.push(s),Ti.forEach(s,function(l,c){if(!Ti.isUndefined(l)){var u=o?o+"."+c:c,h;if(l&&!o&&typeof l=="object"){if(Ti.endsWith(c,"{}"))l=JSON.stringify(l);else if(Ti.endsWith(c,"[]")&&(h=Ti.toArray(l))){h.forEach(function(d){!Ti.isUndefined(d)&&e.append(u,i(d))});return}}r(l,u)}}),t.pop()}else e.append(o,i(s))}return r(n),e}var j1=aF,jp=Rl,lF=function(e,t,i){var r=i.config.validateStatus;!i.status||!r||r(i.status)?e(i):t(new jp("Request failed with status code "+i.status,[jp.ERR_BAD_REQUEST,jp.ERR_BAD_RESPONSE][Math.floor(i.status/100)-4],i.config,i.request,i))},Eh=un,cF=Eh.isStandardBrowserEnv()?function(){return{write:function(t,i,r,s,o,a){var l=[];l.push(t+"="+encodeURIComponent(i)),Eh.isNumber(r)&&l.push("expires="+new Date(r).toGMTString()),Eh.isString(s)&&l.push("path="+s),Eh.isString(o)&&l.push("domain="+o),a===!0&&l.push("secure"),document.cookie=l.join("; ")},read:function(t){var i=document.cookie.match(new RegExp("(^|;\\s*)("+t+")=([^;]*)"));return i?decodeURIComponent(i[3]):null},remove:function(t){this.write(t,"",Date.now()-864e5)}}}():function(){return{write:function(){},read:function(){return null},remove:function(){}}}(),uF=function(e){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)},hF=function(e,t){return t?e.replace(/\/+$/,"")+"/"+t.replace(/^\/+/,""):e},dF=uF,fF=hF,q1=function(e,t){return e&&!dF(t)?fF(e,t):t},qp=un,pF=["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"],mF=function(e){var t={},i,r,s;return e&&qp.forEach(e.split(`
`),function(a){if(s=a.indexOf(":"),i=qp.trim(a.substr(0,s)).toLowerCase(),r=qp.trim(a.substr(s+1)),i){if(t[i]&&pF.indexOf(i)>=0)return;i==="set-cookie"?t[i]=(t[i]?t[i]:[]).concat([r]):t[i]=t[i]?t[i]+", "+r:r}}),t},Uy=un,gF=Uy.isStandardBrowserEnv()?function(){var e=/(msie|trident)/i.test(navigator.userAgent),t=document.createElement("a"),i;function r(s){var o=s;return e&&(t.setAttribute("href",o),o=t.href),t.setAttribute("href",o),{href:t.href,protocol:t.protocol?t.protocol.replace(/:$/,""):"",host:t.host,search:t.search?t.search.replace(/^\?/,""):"",hash:t.hash?t.hash.replace(/^#/,""):"",hostname:t.hostname,port:t.port,pathname:t.pathname.charAt(0)==="/"?t.pathname:"/"+t.pathname}}return i=r(window.location.href),function(o){var a=Uy.isString(o)?r(o):o;return a.protocol===i.protocol&&a.host===i.host}}():function(){return function(){return!0}}(),Xg=Rl,vF=un;function Y1(n){Xg.call(this,n==null?"canceled":n,Xg.ERR_CANCELED),this.name="CanceledError"}vF.inherits(Y1,Xg,{__CANCEL__:!0});var wf=Y1,_F=function(e){var t=/^([-+\w]{1,25})(:?\/\/|:)/.exec(e);return t&&t[1]||""},ec=un,xF=lF,yF=cF,MF=G1,SF=q1,wF=mF,EF=gF,bF=X1,ur=Rl,TF=wf,AF=_F,Oy=function(e){return new Promise(function(i,r){var s=e.data,o=e.headers,a=e.responseType,l;function c(){e.cancelToken&&e.cancelToken.unsubscribe(l),e.signal&&e.signal.removeEventListener("abort",l)}ec.isFormData(s)&&ec.isStandardBrowserEnv()&&delete o["Content-Type"];var u=new XMLHttpRequest;if(e.auth){var h=e.auth.username||"",d=e.auth.password?unescape(encodeURIComponent(e.auth.password)):"";o.Authorization="Basic "+btoa(h+":"+d)}var p=SF(e.baseURL,e.url);u.open(e.method.toUpperCase(),MF(p,e.params,e.paramsSerializer),!0),u.timeout=e.timeout;function v(){if(!!u){var g="getAllResponseHeaders"in u?wF(u.getAllResponseHeaders()):null,_=!a||a==="text"||a==="json"?u.responseText:u.response,M={data:_,status:u.status,statusText:u.statusText,headers:g,config:e,request:u};xF(function(S){i(S),c()},function(S){r(S),c()},M),u=null}}if("onloadend"in u?u.onloadend=v:u.onreadystatechange=function(){!u||u.readyState!==4||u.status===0&&!(u.responseURL&&u.responseURL.indexOf("file:")===0)||setTimeout(v)},u.onabort=function(){!u||(r(new ur("Request aborted",ur.ECONNABORTED,e,u)),u=null)},u.onerror=function(){r(new ur("Network Error",ur.ERR_NETWORK,e,u,u)),u=null},u.ontimeout=function(){var _=e.timeout?"timeout of "+e.timeout+"ms exceeded":"timeout exceeded",M=e.transitional||bF;e.timeoutErrorMessage&&(_=e.timeoutErrorMessage),r(new ur(_,M.clarifyTimeoutError?ur.ETIMEDOUT:ur.ECONNABORTED,e,u)),u=null},ec.isStandardBrowserEnv()){var m=(e.withCredentials||EF(p))&&e.xsrfCookieName?yF.read(e.xsrfCookieName):void 0;m&&(o[e.xsrfHeaderName]=m)}"setRequestHeader"in u&&ec.forEach(o,function(_,M){typeof s=="undefined"&&M.toLowerCase()==="content-type"?delete o[M]:u.setRequestHeader(M,_)}),ec.isUndefined(e.withCredentials)||(u.withCredentials=!!e.withCredentials),a&&a!=="json"&&(u.responseType=e.responseType),typeof e.onDownloadProgress=="function"&&u.addEventListener("progress",e.onDownloadProgress),typeof e.onUploadProgress=="function"&&u.upload&&u.upload.addEventListener("progress",e.onUploadProgress),(e.cancelToken||e.signal)&&(l=function(g){!u||(r(!g||g&&g.type?new TF:g),u.abort(),u=null)},e.cancelToken&&e.cancelToken.subscribe(l),e.signal&&(e.signal.aborted?l():e.signal.addEventListener("abort",l))),s||(s=null);var f=AF(p);if(f&&["http","https","file"].indexOf(f)===-1){r(new ur("Unsupported protocol "+f+":",ur.ERR_BAD_REQUEST,e));return}u.send(s)})},CF=null,Yt=un,By=oF,zy=Rl,RF=X1,LF=j1,PF={"Content-Type":"application/x-www-form-urlencoded"};function ky(n,e){!Yt.isUndefined(n)&&Yt.isUndefined(n["Content-Type"])&&(n["Content-Type"]=e)}function DF(){var n;return(typeof XMLHttpRequest!="undefined"||typeof process!="undefined"&&Object.prototype.toString.call(process)==="[object process]")&&(n=Oy),n}function IF(n,e,t){if(Yt.isString(n))try{return(e||JSON.parse)(n),Yt.trim(n)}catch(i){if(i.name!=="SyntaxError")throw i}return(t||JSON.stringify)(n)}var Ef={transitional:RF,adapter:DF(),transformRequest:[function(e,t){if(By(t,"Accept"),By(t,"Content-Type"),Yt.isFormData(e)||Yt.isArrayBuffer(e)||Yt.isBuffer(e)||Yt.isStream(e)||Yt.isFile(e)||Yt.isBlob(e))return e;if(Yt.isArrayBufferView(e))return e.buffer;if(Yt.isURLSearchParams(e))return ky(t,"application/x-www-form-urlencoded;charset=utf-8"),e.toString();var i=Yt.isObject(e),r=t&&t["Content-Type"],s;if((s=Yt.isFileList(e))||i&&r==="multipart/form-data"){var o=this.env&&this.env.FormData;return LF(s?{"files[]":e}:e,o&&new o)}else if(i||r==="application/json")return ky(t,"application/json"),IF(e);return e}],transformResponse:[function(e){var t=this.transitional||Ef.transitional,i=t&&t.silentJSONParsing,r=t&&t.forcedJSONParsing,s=!i&&this.responseType==="json";if(s||r&&Yt.isString(e)&&e.length)try{return JSON.parse(e)}catch(o){if(s)throw o.name==="SyntaxError"?zy.from(o,zy.ERR_BAD_RESPONSE,this,null,this.response):o}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:CF},validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*"}}};Yt.forEach(["delete","get","head"],function(e){Ef.headers[e]={}});Yt.forEach(["post","put","patch"],function(e){Ef.headers[e]=Yt.merge(PF)});var Dv=Ef,NF=un,FF=Dv,UF=function(e,t,i){var r=this||FF;return NF.forEach(i,function(o){e=o.call(r,e,t)}),e},K1=function(e){return!!(e&&e.__CANCEL__)},Hy=un,Yp=UF,OF=K1,BF=Dv,zF=wf;function Kp(n){if(n.cancelToken&&n.cancelToken.throwIfRequested(),n.signal&&n.signal.aborted)throw new zF}var kF=function(e){Kp(e),e.headers=e.headers||{},e.data=Yp.call(e,e.data,e.headers,e.transformRequest),e.headers=Hy.merge(e.headers.common||{},e.headers[e.method]||{},e.headers),Hy.forEach(["delete","get","head","post","put","patch","common"],function(r){delete e.headers[r]});var t=e.adapter||BF.adapter;return t(e).then(function(r){return Kp(e),r.data=Yp.call(e,r.data,r.headers,e.transformResponse),r},function(r){return OF(r)||(Kp(e),r&&r.response&&(r.response.data=Yp.call(e,r.response.data,r.response.headers,e.transformResponse))),Promise.reject(r)})},Xn=un,Z1=function(e,t){t=t||{};var i={};function r(u,h){return Xn.isPlainObject(u)&&Xn.isPlainObject(h)?Xn.merge(u,h):Xn.isPlainObject(h)?Xn.merge({},h):Xn.isArray(h)?h.slice():h}function s(u){if(Xn.isUndefined(t[u])){if(!Xn.isUndefined(e[u]))return r(void 0,e[u])}else return r(e[u],t[u])}function o(u){if(!Xn.isUndefined(t[u]))return r(void 0,t[u])}function a(u){if(Xn.isUndefined(t[u])){if(!Xn.isUndefined(e[u]))return r(void 0,e[u])}else return r(void 0,t[u])}function l(u){if(u in t)return r(e[u],t[u]);if(u in e)return r(void 0,e[u])}var c={url:o,method:o,data:o,baseURL:a,transformRequest:a,transformResponse:a,paramsSerializer:a,timeout:a,timeoutMessage:a,withCredentials:a,adapter:a,responseType:a,xsrfCookieName:a,xsrfHeaderName:a,onUploadProgress:a,onDownloadProgress:a,decompress:a,maxContentLength:a,maxBodyLength:a,beforeRedirect:a,transport:a,httpAgent:a,httpsAgent:a,cancelToken:a,socketPath:a,responseEncoding:a,validateStatus:l};return Xn.forEach(Object.keys(e).concat(Object.keys(t)),function(h){var d=c[h]||s,p=d(h);Xn.isUndefined(p)&&d!==l||(i[h]=p)}),i},J1={version:"0.27.2"},HF=J1.version,rs=Rl,Iv={};["object","boolean","number","function","string","symbol"].forEach(function(n,e){Iv[n]=function(i){return typeof i===n||"a"+(e<1?"n ":" ")+n}});var Gy={};Iv.transitional=function(e,t,i){function r(s,o){return"[Axios v"+HF+"] Transitional option '"+s+"'"+o+(i?". "+i:"")}return function(s,o,a){if(e===!1)throw new rs(r(o," has been removed"+(t?" in "+t:"")),rs.ERR_DEPRECATED);return t&&!Gy[o]&&(Gy[o]=!0,console.warn(r(o," has been deprecated since v"+t+" and will be removed in the near future"))),e?e(s,o,a):!0}};function GF(n,e,t){if(typeof n!="object")throw new rs("options must be an object",rs.ERR_BAD_OPTION_VALUE);for(var i=Object.keys(n),r=i.length;r-- >0;){var s=i[r],o=e[s];if(o){var a=n[s],l=a===void 0||o(a,s,n);if(l!==!0)throw new rs("option "+s+" must be "+l,rs.ERR_BAD_OPTION_VALUE);continue}if(t!==!0)throw new rs("Unknown option "+s,rs.ERR_BAD_OPTION)}}var VF={assertOptions:GF,validators:Iv},Q1=un,WF=G1,Vy=rF,Wy=kF,bf=Z1,$F=q1,eb=VF,Qo=eb.validators;function ul(n){this.defaults=n,this.interceptors={request:new Vy,response:new Vy}}ul.prototype.request=function(e,t){typeof e=="string"?(t=t||{},t.url=e):t=e||{},t=bf(this.defaults,t),t.method?t.method=t.method.toLowerCase():this.defaults.method?t.method=this.defaults.method.toLowerCase():t.method="get";var i=t.transitional;i!==void 0&&eb.assertOptions(i,{silentJSONParsing:Qo.transitional(Qo.boolean),forcedJSONParsing:Qo.transitional(Qo.boolean),clarifyTimeoutError:Qo.transitional(Qo.boolean)},!1);var r=[],s=!0;this.interceptors.request.forEach(function(p){typeof p.runWhen=="function"&&p.runWhen(t)===!1||(s=s&&p.synchronous,r.unshift(p.fulfilled,p.rejected))});var o=[];this.interceptors.response.forEach(function(p){o.push(p.fulfilled,p.rejected)});var a;if(!s){var l=[Wy,void 0];for(Array.prototype.unshift.apply(l,r),l=l.concat(o),a=Promise.resolve(t);l.length;)a=a.then(l.shift(),l.shift());return a}for(var c=t;r.length;){var u=r.shift(),h=r.shift();try{c=u(c)}catch(d){h(d);break}}try{a=Wy(c)}catch(d){return Promise.reject(d)}for(;o.length;)a=a.then(o.shift(),o.shift());return a};ul.prototype.getUri=function(e){e=bf(this.defaults,e);var t=$F(e.baseURL,e.url);return WF(t,e.params,e.paramsSerializer)};Q1.forEach(["delete","get","head","options"],function(e){ul.prototype[e]=function(t,i){return this.request(bf(i||{},{method:e,url:t,data:(i||{}).data}))}});Q1.forEach(["post","put","patch"],function(e){function t(i){return function(s,o,a){return this.request(bf(a||{},{method:e,headers:i?{"Content-Type":"multipart/form-data"}:{},url:s,data:o}))}}ul.prototype[e]=t(),ul.prototype[e+"Form"]=t(!0)});var XF=ul,jF=wf;function hl(n){if(typeof n!="function")throw new TypeError("executor must be a function.");var e;this.promise=new Promise(function(r){e=r});var t=this;this.promise.then(function(i){if(!!t._listeners){var r,s=t._listeners.length;for(r=0;r<s;r++)t._listeners[r](i);t._listeners=null}}),this.promise.then=function(i){var r,s=new Promise(function(o){t.subscribe(o),r=o}).then(i);return s.cancel=function(){t.unsubscribe(r)},s},n(function(r){t.reason||(t.reason=new jF(r),e(t.reason))})}hl.prototype.throwIfRequested=function(){if(this.reason)throw this.reason};hl.prototype.subscribe=function(e){if(this.reason){e(this.reason);return}this._listeners?this._listeners.push(e):this._listeners=[e]};hl.prototype.unsubscribe=function(e){if(!!this._listeners){var t=this._listeners.indexOf(e);t!==-1&&this._listeners.splice(t,1)}};hl.source=function(){var e,t=new hl(function(r){e=r});return{token:t,cancel:e}};var qF=hl,YF=function(e){return function(i){return e.apply(null,i)}},KF=un,ZF=function(e){return KF.isObject(e)&&e.isAxiosError===!0},$y=un,JF=z1,ad=XF,QF=Z1,eU=Dv;function tb(n){var e=new ad(n),t=JF(ad.prototype.request,e);return $y.extend(t,ad.prototype,e),$y.extend(t,e),t.create=function(r){return tb(QF(n,r))},t}var kn=tb(eU);kn.Axios=ad;kn.CanceledError=wf;kn.CancelToken=qF;kn.isCancel=K1;kn.VERSION=J1.version;kn.toFormData=j1;kn.AxiosError=Rl;kn.Cancel=kn.CanceledError;kn.all=function(e){return Promise.all(e)};kn.spread=YF;kn.isAxiosError=ZF;Tv.exports=kn;Tv.exports.default=kn;var Nv=Tv.exports;const tU="https://dr06qxtr.api.lootlocker.io/game/leaderboards/xp/list?count=100&after=0",nU="https://dr06qxtr.api.lootlocker.io/game/leaderboards/xp/submit",iU="https://dr06qxtr.api.lootlocker.io/game/v2/session/guest";let lu=null;const nb=async()=>{lu=(await Nv.post(iU,{game_key:"6c76e5729a75c11be3de40e210250dad79f8123c",development_mode:!0,game_version:"0.1.0.0"})).data.session_token},rU=async(n,e)=>{if(!lu)throw new Error("No session ID established with LootLocker.");console.log(n,e);const t=await Nv.post(nU,{score:n,metadata:e},{headers:{"x-session-token":lu||""}});return console.log(t.data),t.data},Xy=async()=>{if(!lu)throw new Error("No session ID established with LootLocker.");return(await Nv.get(tU,{headers:{"x-session-token":lu||""}})).data.items},gc=({href:n,children:e})=>Q.createElement("a",{href:n,target:"_blank",rel:"noopener"},e),sU=({toMainMenu:n})=>Q.createElement("div",{id:"how-to-play"},Q.createElement("h1",{style:{fontSize:"3rem"}},"How to play:"),Q.createElement("br",null),Q.createElement("h1",null,Q.createElement("strong",null,"Controls"),": WASD to move, Escape to pause."),Q.createElement("h3",null,"Fend off enemies from eras of history while Father Time brings you back to the present day!"),Q.createElement("br",null),Q.createElement("h2",null,"You start with"," ",Q.createElement("strong",null,"your trusty bullet that attacks automatically"),". Move around to line it up and strike enemies!"),Q.createElement("br",null),Q.createElement("h2",null,"Defeated enemies drop ",Q.createElement("strong",null,"time rings"),". Father Time needs more time rings every minute to help you get back! ",Q.createElement("br",null),Q.createElement("strong",null,"Try to always be collecting time rings!!!")),Q.createElement("br",null),Q.createElement("h2",null,"Every minute, a number on the clock will dislodge and attack you."," ",Q.createElement("strong",null,"Defeat the number and claim its prize!")," The strength of your reward will be based on"," ",Q.createElement("strong",null,"how many time rings you picked up during that minute"),"."),Q.createElement("br",null),Q.createElement("h2",null,Q.createElement("strong",null,"Move carefully, pick up time rings always, and choose your rewards wisely.")),Q.createElement("h4",null,"And stop trifling with time, Felix!"),Q.createElement("br",null),Q.createElement("button",{className:"back-to-main-menu",onClick:()=>n()},"Back to Main Menu")),oU=({toMainMenu:n})=>{const[e,t]=wt.exports.useState(null);return wt.exports.useEffect(()=>{(async()=>{try{const i=await Xy();t(i)}catch{await nb();const r=await Xy();t(r)}})()},[]),e===null?Q.createElement("h1",null,"Looading"):Q.createElement("div",{id:"leaderboard-page"},Q.createElement("div",{id:"leaderboard"},e.length===0&&Q.createElement("h1",null,"No scores to display ..."),e.map(i=>Q.createElement("div",{className:"score-row",key:i.member_id},Q.createElement("h1",{className:"score-rank"},"#",i.rank),Q.createElement("h1",{className:"score-member"},"Felix the Cat #",i.member_id),Q.createElement("h1",null,Q.createElement("span",null,"Total XP:")," ",i.score),Q.createElement("h1",null,Q.createElement("span",null,"Weapons:")," ",i.metadata)))),Q.createElement("div",{style:{display:"flex",justifyContent:"space-between",width:"100%"}},Q.createElement("button",{onClick:()=>n(),className:"back-to-main-menu"},"Back to Main Menu"),Q.createElement("div",null,Q.createElement("h2",{style:{display:"flex",alignItems:"center"}},Q.createElement("span",{style:{paddingRight:"1rem"}},"Powered by"),Q.createElement(gc,{href:"https://lootlocker.io"},Q.createElement("img",{src:FN}))))))},aU=({onStartGame:n})=>{wt.exports.useEffect(()=>{nb()},[]);const[e,t]=wt.exports.useState("main");return e==="main"?Q.createElement("div",{id:"menu-screens"},Q.createElement("div",{id:"main-menu"},Q.createElement("img",{style:{width:"60%"},src:NN}),Q.createElement("div",{id:"main-menu-actions"},Q.createElement("h2",{onClick:()=>t("pre-start")},"Start"),Q.createElement("h2",{onClick:()=>t("help")},"How to Play"),Q.createElement("h2",{onClick:()=>t("leaderboard")},"Leaderboard"),Q.createElement("h2",{onClick:()=>t("about")},"About"))),Q.createElement("img",{style:{opacity:0,width:"3px"},className:"father-time-help",src:Wg})):e==="about"?Q.createElement("div",{id:"menu-screens"},Q.createElement("div",{id:"about"},Q.createElement("h1",null,Q.createElement("strong",null,"Wake Up, Felix!"),Q.createElement("br",null),"made by ",Q.createElement(gc,{href:"https://joejs.itch.io/"},"Joe Alves"),","," ",Q.createElement(gc,{href:"https://gamejolt.com/@lizzabizza"},"Elissa Alves"),", and Hunter Fastige."),Q.createElement("div",{id:"jam-details"},Q.createElement("h3",null,"Made in 2 weeks for"," ",Q.createElement(gc,{href:"https://gamejolt.com/c/togetherjam"},"Together Jam 2022.")),Q.createElement("h3",{style:{marginBottom:"0.25rem"}},"Allowed properties: ",Q.createElement("strong",null,"Felix the Cat"),", Xena Warrior Princess, Airwolf, Tremors, and Knight Rider."),Q.createElement("h3",{style:{marginTop:"0"}},"Special theme: ",Q.createElement("strong",null,'"Power in Numbers"'),".")),Q.createElement("div",{id:"credits"},Q.createElement("h3",null,"Felix, Father Time, and era enemies hand-drawn by Hunter Fastige."),Q.createElement("h3",{style:{marginBottom:"0.25rem"}},"Music and sound by Elissa Alves, with public domain samples from:"),Q.createElement("ul",{style:{paddingTop:0}},Q.createElement("li",null,"Minor Blues - Django Reinhardt"),Q.createElement("li",null,"Perdido Street Blues - Louis Armstrong & Sidney Bechet"),Q.createElement("li",null,"Shoe Shiner's Drag - Art Hodes' Chicagoans"),Q.createElement("li",null,"Panama Rag - Humphrey Lyttelton"),Q.createElement("li",null,"Froggie Moore - Humphrey Lyttelton"),Q.createElement("li",null,"Milenberg Joys - Tommy Dorsey And His Orchestra"))),Q.createElement("button",{style:{marginTop:"1rem"},className:"back-to-main-menu",onClick:()=>t("main")},"Back to Main Menu"))):e==="pre-start"?Q.createElement("div",{id:"menu-screens"},Q.createElement("div",{id:"help-game-start"},Q.createElement("div",null,Q.createElement("h2",null,Q.createElement("strong",null,"Felix!")," Oh, there you go,"," ",Q.createElement(gc,{href:"https://www.youtube.com/watch?v=HSXa7LNMO6s"},"trifling with time again ..."),Q.createElement("br",null),Q.createElement("br",null),Q.createElement("img",{className:"father-time-help",src:Wg}),Q.createElement("br",null),Q.createElement("br",null),"Never gets old."),Q.createElement("h1",null,"And now you're stuck in a time dream! ",Q.createElement("br",null),"You gotta fight and get back to the present!!"),Q.createElement("button",{id:"wake-up-button",onClick:()=>n()},"Wake Up!!!")),Q.createElement("button",{className:"back-to-main-menu",onClick:()=>{t("main")}},"Back to Main Menu"))):e==="help"?Q.createElement("div",{id:"menu-screens"},Q.createElement(sU,{toMainMenu:()=>t("main")})):e==="leaderboard"?Q.createElement("div",{id:"menu-screens"},Q.createElement(oU,{toMainMenu:()=>t("main")})):null},lU=({gameState:n})=>{const e=wt.exports.useRef(null),[t,i]=wt.exports.useState(!0),[r,s]=wt.exports.useState(null),{totalXp:o,chosenWeapons:a}=n;return wt.exports.useEffect(()=>{if(!o||!a)throw new Error("Game state issues, cannot submit score.");i(!0),AN.play(),(async()=>{const c=a.map(h=>O1[h].roman).join(", "),u=await rU(o,c);s(u),i(!1)})()},[]),wt.exports.useEffect(()=>{const l=setInterval(()=>{if(e.current){const c=parseInt(e.current.style.opacity,10);e.current.style.opacity=(c+.05).toString(),c>=1&&clearInterval(l)}},16);return()=>clearInterval(l)},[]),Q.createElement("div",{id:"victory-screen",ref:e},Q.createElement("h1",null,"You made it back, Felix!"),Q.createElement("img",{className:"father-time",src:U1}),t&&Q.createElement("h2",null,"Submitting your score ..."),r&&Q.createElement("div",{id:"score-and-rank"},Q.createElement("h2",null,"You collected ",Q.createElement("strong",null,r.score)," time rings."),Q.createElement("h3",null,"That makes you ",Q.createElement("strong",null,"#",r.rank)," on the all-time leaderboard!"),Q.createElement("h4",null,"Pretty nice going choosing the ",r.metadata," weapons; you understand there is power in numbers!")),Q.createElement("button",{className:"back-to-main-menu",onClick:()=>window.location.reload()},"Return to Main Menu"))},jy=n=>n.length<2?`0${n}`:n,cU=n=>{const e=Math.floor(n/1e3/60),t=n-e*60*1e3,i=Math.floor(t/1e3);return`${jy(e.toString())}:${jy(i.toString())}`},uU=({currentHP:n,totalHP:e})=>{const t=["mad-hurt","uh-oh","angry","feeling-good"];return e===5&&t.push("war"),Q.createElement("div",{id:"health-bar"},t.map((i,r)=>{let s=i;return n-1>r&&(s=t[n-1]),Q.createElement("div",{className:`felix-face ${s}`,key:r,style:{backgroundImage:`url(${II})`,opacity:n-1<r?.1:1}})}))},hU=({time:n,currentEraLabel:e})=>{const t=wt.exports.useRef(null);return wt.exports.useEffect(()=>{if(e==="")return;let i=Date.now();const r=setInterval(()=>{const s=Date.now()-i;if(t.current){const o=(Math.sin(s/100)+1)/2;t.current.style.opacity=(o/2).toString(),s>4e3&&o>.7&&(clearInterval(r),t.current.style.opacity="1")}});return()=>clearInterval(r)},[e]),Q.createElement("div",{id:"time-display"},Q.createElement("h1",null,n!==1/0?cU(n):"???"),Q.createElement("span",{className:"game-era-message",ref:t},e))},dU=({currentGemTotal:n})=>Q.createElement("div",{id:"gem-total"},Q.createElement("h1",null,"Time Rings: ",n)),fU=()=>Q.createElement("div",{id:"pause"},Q.createElement("div",null,Q.createElement("h1",null,"PAUSED"),Q.createElement("h4",null,"Press ",Q.createElement("strong",null,"Escape")," to resume"))),pU=()=>Q.createElement("div",{id:"game-over-screen"},Q.createElement("h1",null,"C'mon, Felix ... wake up!"),Q.createElement("button",{className:"back-to-main-menu",onClick:()=>window.location.reload()},"Back To Main Menu")),mU=({gameState:n})=>{const e=n.onUpgradeScreen,t=n.upgradeSelectionFn;return Q.createElement("div",{id:"game-ui-content"},n.victorious&&Q.createElement(lU,{gameState:n}),n.gameOver&&Q.createElement(pU,null),n.paused&&Q.createElement(fU,null),e&&t&&Q.createElement(IN,{gameState:n,onSelect:t}),Q.createElement(hU,{time:n.elapsedTime,currentEraLabel:n.eraMessage}),Q.createElement("div",{id:"beneath-timer"},Q.createElement(uU,{currentHP:n.felixHP,totalHP:n.felixMaxHP}),Q.createElement(dU,{currentGemTotal:n.currentXp})))};var gU=()=>{const n={elapsedTime:0,felixHP:4,felixMaxHP:4,gameStarted:!1,totalXp:0,currentXp:0,expectedMinuteXp:null,bagXps:[],chosenWeapons:[],onUpgradeScreen:null,upgradeSelectionFn:null,paused:!1,startGame:null,eraMessage:"",victorious:!1,gameOver:!1},e=window.getDOMOne("#game-ui"),t=F1(e);let i=!0;const r=()=>{n.gameStarted===!1?t.render(Q.createElement(aU,{onStartGame:()=>{n.startGame&&(DN.play(),n.startGame(),n.gameStarted=!0,window.requestAnimationFrame(r))}})):(i&&(i=!1,t.render(Q.createElement(mU,{gameState:n}))),window.requestAnimationFrame(r))};window.requestAnimationFrame(r);const s=()=>{i=!0};let o=0;return{setTime(a,l=!1){n.elapsedTime=a;const c=Math.floor(a/1e3);(l||c>o)&&(o=c,s())},setFelixHP(a){n.felixHP=a,s()},increaseFelixMaxHP(){n.felixMaxHP=5,s()},replaceCurrentXP(a){n.currentXp!==a&&(n.currentXp=a,s())},addXP(a){n.currentXp+=a,s()},storeCurrentXPInBag(a){n.bagXps.push({minute:a,total:n.currentXp}),n.totalXp+=n.currentXp,n.currentXp=0,s()},getGameState(){return n},showUpgradeScreen(a,l,c){n.onUpgradeScreen=a,n.upgradeSelectionFn=c,n.expectedMinuteXp=l,s()},hideUpgradeScreen(){n.onUpgradeScreen=null,n.upgradeSelectionFn=null,s()},addChosenWeapon(a){n.chosenWeapons.push(a),s()},showPauseScreen(){n.paused=!0,s()},hidePauseScreen(){n.paused=!1,s()},provideStartGame(a){n.startGame=a},startEndingSequence(){n.elapsedTime=1/0,n.eraMessage="???",s()},setEraMessage(a){n.eraMessage=a,s()},showVictoryScreen(){n.victorious=!0,s()},setGameOver(){n.gameOver=!0,s()}}};class vU extends Ur{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new SU(t)}),this.register(function(t){return new CU(t)}),this.register(function(t){return new RU(t)}),this.register(function(t){return new wU(t)}),this.register(function(t){return new EU(t)}),this.register(function(t){return new bU(t)}),this.register(function(t){return new TU(t)}),this.register(function(t){return new MU(t)}),this.register(function(t){return new AU(t)}),this.register(function(t){return new xU(t)}),this.register(function(t){return new LU(t)})}load(e,t,i,r){const s=this;let o;this.resourcePath!==""?o=this.resourcePath:this.path!==""?o=this.path:o=ps.extractUrlBase(e),this.manager.itemStart(e);const a=function(c){r?r(c):console.error(c),s.manager.itemError(e),s.manager.itemEnd(e)},l=new T0(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(c){try{s.parse(c,o,function(u){t(u),s.manager.itemEnd(e)},a)}catch(u){a(u)}},i,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,i,r){let s;const o={},a={};if(typeof e=="string")s=e;else if(ps.decodeText(new Uint8Array(e,0,4))===ib){try{o[Je.KHR_BINARY_GLTF]=new PU(e)}catch(h){r&&r(h);return}s=o[Je.KHR_BINARY_GLTF].content}else s=ps.decodeText(new Uint8Array(e));const l=JSON.parse(s);if(l.asset===void 0||l.asset.version[0]<2){r&&r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new WU(l,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let u=0;u<this.pluginCallbacks.length;u++){const h=this.pluginCallbacks[u](c);a[h.name]=h,o[h.name]=!0}if(l.extensionsUsed)for(let u=0;u<l.extensionsUsed.length;++u){const h=l.extensionsUsed[u],d=l.extensionsRequired||[];switch(h){case Je.KHR_MATERIALS_UNLIT:o[h]=new yU;break;case Je.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:o[h]=new NU;break;case Je.KHR_DRACO_MESH_COMPRESSION:o[h]=new DU(l,this.dracoLoader);break;case Je.KHR_TEXTURE_TRANSFORM:o[h]=new IU;break;case Je.KHR_MESH_QUANTIZATION:o[h]=new FU;break;default:d.indexOf(h)>=0&&a[h]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+h+'".')}}c.setExtensions(o),c.setPlugins(a),c.parse(i,r)}parseAsync(e,t){const i=this;return new Promise(function(r,s){i.parse(e,t,r,s)})}}function _U(){let n={};return{get:function(e){return n[e]},add:function(e,t){n[e]=t},remove:function(e){delete n[e]},removeAll:function(){n={}}}}const Je={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class xU{constructor(e){this.parser=e,this.name=Je.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let i=0,r=t.length;i<r;i++){const s=t[i];s.extensions&&s.extensions[this.name]&&s.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,s.extensions[this.name].light)}}_loadLight(e){const t=this.parser,i="light:"+e;let r=t.cache.get(i);if(r)return r;const s=t.json,l=((s.extensions&&s.extensions[this.name]||{}).lights||[])[e];let c;const u=new we(16777215);l.color!==void 0&&u.fromArray(l.color);const h=l.range!==void 0?l.range:0;switch(l.type){case"directional":c=new xw(u),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new Jn(u),c.distance=h;break;case"spot":c=new gw(u),c.distance=h,l.spot=l.spot||{},l.spot.innerConeAngle=l.spot.innerConeAngle!==void 0?l.spot.innerConeAngle:0,l.spot.outerConeAngle=l.spot.outerConeAngle!==void 0?l.spot.outerConeAngle:Math.PI/4,c.angle=l.spot.outerConeAngle,c.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return c.position.set(0,0,0),c.decay=2,l.intensity!==void 0&&(c.intensity=l.intensity),c.name=t.createUniqueName(l.name||"light_"+e),r=Promise.resolve(c),t.cache.add(i,r),r}createNodeAttachment(e){const t=this,i=this.parser,s=i.json.nodes[e],a=(s.extensions&&s.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(l){return i._getNodeRef(t.cache,a,l)})}}class yU{constructor(){this.name=Je.KHR_MATERIALS_UNLIT}getMaterialType(){return Fn}extendParams(e,t,i){const r=[];e.color=new we(1,1,1),e.opacity=1;const s=t.pbrMetallicRoughness;if(s){if(Array.isArray(s.baseColorFactor)){const o=s.baseColorFactor;e.color.fromArray(o),e.opacity=o[3]}s.baseColorTexture!==void 0&&r.push(i.assignTexture(e,"map",s.baseColorTexture,it))}return Promise.all(r)}}class MU{constructor(e){this.parser=e,this.name=Je.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const r=this.parser.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=r.extensions[this.name].emissiveStrength;return s!==void 0&&(t.emissiveIntensity=s),Promise.resolve()}}class SU{constructor(e){this.parser=e,this.name=Je.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Ps}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];if(o.clearcoatFactor!==void 0&&(t.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&s.push(i.assignTexture(t,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&s.push(i.assignTexture(t,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(s.push(i.assignTexture(t,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const a=o.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new fe(a,a)}return Promise.all(s)}}class wU{constructor(e){this.parser=e,this.name=Je.KHR_MATERIALS_SHEEN}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Ps}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[];t.sheenColor=new we(0,0,0),t.sheenRoughness=0,t.sheen=1;const o=r.extensions[this.name];return o.sheenColorFactor!==void 0&&t.sheenColor.fromArray(o.sheenColorFactor),o.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=o.sheenRoughnessFactor),o.sheenColorTexture!==void 0&&s.push(i.assignTexture(t,"sheenColorMap",o.sheenColorTexture,it)),o.sheenRoughnessTexture!==void 0&&s.push(i.assignTexture(t,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(s)}}class EU{constructor(e){this.parser=e,this.name=Je.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Ps}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];return o.transmissionFactor!==void 0&&(t.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&s.push(i.assignTexture(t,"transmissionMap",o.transmissionTexture)),Promise.all(s)}}class bU{constructor(e){this.parser=e,this.name=Je.KHR_MATERIALS_VOLUME}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Ps}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];t.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&s.push(i.assignTexture(t,"thicknessMap",o.thicknessTexture)),t.attenuationDistance=o.attenuationDistance||0;const a=o.attenuationColor||[1,1,1];return t.attenuationColor=new we(a[0],a[1],a[2]),Promise.all(s)}}class TU{constructor(e){this.parser=e,this.name=Je.KHR_MATERIALS_IOR}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Ps}extendMaterialParams(e,t){const r=this.parser.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=r.extensions[this.name];return t.ior=s.ior!==void 0?s.ior:1.5,Promise.resolve()}}class AU{constructor(e){this.parser=e,this.name=Je.KHR_MATERIALS_SPECULAR}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Ps}extendMaterialParams(e,t){const i=this.parser,r=i.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const s=[],o=r.extensions[this.name];t.specularIntensity=o.specularFactor!==void 0?o.specularFactor:1,o.specularTexture!==void 0&&s.push(i.assignTexture(t,"specularIntensityMap",o.specularTexture));const a=o.specularColorFactor||[1,1,1];return t.specularColor=new we(a[0],a[1],a[2]),o.specularColorTexture!==void 0&&s.push(i.assignTexture(t,"specularColorMap",o.specularColorTexture,it)),Promise.all(s)}}class CU{constructor(e){this.parser=e,this.name=Je.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,i=t.json,r=i.textures[e];if(!r.extensions||!r.extensions[this.name])return null;const s=r.extensions[this.name],o=t.options.ktx2Loader;if(!o){if(i.extensionsRequired&&i.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,s.source,o)}}class RU{constructor(e){this.parser=e,this.name=Je.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,i=this.parser,r=i.json,s=r.textures[e];if(!s.extensions||!s.extensions[t])return null;const o=s.extensions[t],a=r.images[o.source];let l=i.textureLoader;if(a.uri){const c=i.options.manager.getHandler(a.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return i.loadTextureImage(e,o.source,l);if(r.extensionsRequired&&r.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return i.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class LU{constructor(e){this.name=Je.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,i=t.bufferViews[e];if(i.extensions&&i.extensions[this.name]){const r=i.extensions[this.name],s=this.parser.getDependency("buffer",r.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([s,o.ready]).then(function(a){const l=r.byteOffset||0,c=r.byteLength||0,u=r.count,h=r.byteStride,d=new ArrayBuffer(u*h),p=new Uint8Array(a[0],l,c);return o.decodeGltfBuffer(new Uint8Array(d),u,h,p,r.mode,r.filter),d})}else return null}}const ib="glTF",tc=12,qy={JSON:1313821514,BIN:5130562};class PU{constructor(e){this.name=Je.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,tc);if(this.header={magic:ps.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==ib)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const i=this.header.length-tc,r=new DataView(e,tc);let s=0;for(;s<i;){const o=r.getUint32(s,!0);s+=4;const a=r.getUint32(s,!0);if(s+=4,a===qy.JSON){const l=new Uint8Array(e,tc+s,o);this.content=ps.decodeText(l)}else if(a===qy.BIN){const l=tc+s;this.body=e.slice(l,l+o)}s+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class DU{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=Je.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const i=this.json,r=this.dracoLoader,s=e.extensions[this.name].bufferView,o=e.extensions[this.name].attributes,a={},l={},c={};for(const u in o){const h=qg[u]||u.toLowerCase();a[h]=o[u]}for(const u in e.attributes){const h=qg[u]||u.toLowerCase();if(o[u]!==void 0){const d=i.accessors[e.attributes[u]],p=cu[d.componentType];c[h]=p,l[h]=d.normalized===!0}}return t.getDependency("bufferView",s).then(function(u){return new Promise(function(h){r.decodeDracoFile(u,function(d){for(const p in d.attributes){const v=d.attributes[p],m=l[p];m!==void 0&&(v.normalized=m)}h(d)},a,c)})})}}class IU{constructor(){this.name=Je.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return t.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class jg extends Ls{constructor(e){super(),this.isGLTFSpecularGlossinessMaterial=!0;const t=["#ifdef USE_SPECULARMAP","	uniform sampler2D specularMap;","#endif"].join(`
`),i=["#ifdef USE_GLOSSINESSMAP","	uniform sampler2D glossinessMap;","#endif"].join(`
`),r=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","	vec4 texelSpecular = texture2D( specularMap, vUv );","	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","	specularFactor *= texelSpecular.rgb;","#endif"].join(`
`),s=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","	vec4 texelGlossiness = texture2D( glossinessMap, vUv );","	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","	glossinessFactor *= texelGlossiness.a;","#endif"].join(`
`),o=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.specularColor = specularFactor;"].join(`
`),a={specular:{value:new we().setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=a,this.onBeforeCompile=function(l){for(const c in a)l.uniforms[c]=a[c];l.fragmentShader=l.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",t).replace("#include <metalnessmap_pars_fragment>",i).replace("#include <roughnessmap_fragment>",r).replace("#include <metalnessmap_fragment>",s).replace("#include <lights_physical_fragment>",o)},Object.defineProperties(this,{specular:{get:function(){return a.specular.value},set:function(l){a.specular.value=l}},specularMap:{get:function(){return a.specularMap.value},set:function(l){a.specularMap.value=l,l?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return a.glossiness.value},set:function(l){a.glossiness.value=l}},glossinessMap:{get:function(){return a.glossinessMap.value},set:function(l){a.glossinessMap.value=l,l?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(e)}copy(e){return super.copy(e),this.specularMap=e.specularMap,this.specular.copy(e.specular),this.glossinessMap=e.glossinessMap,this.glossiness=e.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class NU{constructor(){this.name=Je.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity"]}getMaterialType(){return jg}extendParams(e,t,i){const r=t.extensions[this.name];e.color=new we(1,1,1),e.opacity=1;const s=[];if(Array.isArray(r.diffuseFactor)){const o=r.diffuseFactor;e.color.fromArray(o),e.opacity=o[3]}if(r.diffuseTexture!==void 0&&s.push(i.assignTexture(e,"map",r.diffuseTexture,it)),e.emissive=new we(0,0,0),e.glossiness=r.glossinessFactor!==void 0?r.glossinessFactor:1,e.specular=new we(1,1,1),Array.isArray(r.specularFactor)&&e.specular.fromArray(r.specularFactor),r.specularGlossinessTexture!==void 0){const o=r.specularGlossinessTexture;s.push(i.assignTexture(e,"glossinessMap",o)),s.push(i.assignTexture(e,"specularMap",o,it))}return Promise.all(s)}createMaterial(e){const t=new jg(e);return t.fog=!0,t.color=e.color,t.map=e.map===void 0?null:e.map,t.lightMap=null,t.lightMapIntensity=1,t.aoMap=e.aoMap===void 0?null:e.aoMap,t.aoMapIntensity=1,t.emissive=e.emissive,t.emissiveIntensity=e.emissiveIntensity===void 0?1:e.emissiveIntensity,t.emissiveMap=e.emissiveMap===void 0?null:e.emissiveMap,t.bumpMap=e.bumpMap===void 0?null:e.bumpMap,t.bumpScale=1,t.normalMap=e.normalMap===void 0?null:e.normalMap,t.normalMapType=bo,e.normalScale&&(t.normalScale=e.normalScale),t.displacementMap=null,t.displacementScale=1,t.displacementBias=0,t.specularMap=e.specularMap===void 0?null:e.specularMap,t.specular=e.specular,t.glossinessMap=e.glossinessMap===void 0?null:e.glossinessMap,t.glossiness=e.glossiness,t.alphaMap=null,t.envMap=e.envMap===void 0?null:e.envMap,t.envMapIntensity=1,t}}class FU{constructor(){this.name=Je.KHR_MESH_QUANTIZATION}}class So extends Pr{constructor(e,t,i,r){super(e,t,i,r)}copySampleValue_(e){const t=this.resultBuffer,i=this.sampleValues,r=this.valueSize,s=e*r*3+r;for(let o=0;o!==r;o++)t[o]=i[s+o];return t}}So.prototype.beforeStart_=So.prototype.copySampleValue_;So.prototype.afterEnd_=So.prototype.copySampleValue_;So.prototype.interpolate_=function(n,e,t,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=o*2,l=o*3,c=i-e,u=(t-e)/c,h=u*u,d=h*u,p=n*l,v=p-l,m=-2*d+3*h,f=d-h,g=1-m,_=f-h+u;for(let M=0;M!==o;M++){const E=s[v+M+o],S=s[v+M+a]*c,T=s[p+M+o],R=s[p+M]*c;r[M]=g*E+_*S+m*T+f*R}return r};const UU=new bn;class OU extends So{interpolate_(e,t,i,r){const s=super.interpolate_(e,t,i,r);return UU.fromArray(s).normalize().toArray(s),s}}const hr={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},cu={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Yy={9728:$t,9729:mn,9984:Hm,9985:TS,9986:Gm,9987:_l},Ky={33071:ci,33648:hd,10497:Ya},Zy={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},qg={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},jr={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},BU={CUBICSPLINE:void 0,LINEAR:Za,STEP:Uc},Zp={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function zU(n){return n.DefaultMaterial===void 0&&(n.DefaultMaterial=new Ls({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Xa})),n.DefaultMaterial}function nc(n,e,t){for(const i in t.extensions)n[i]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[i]=t.extensions[i])}function Ys(n,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(n.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function kU(n,e,t){let i=!1,r=!1,s=!1;for(let c=0,u=e.length;c<u;c++){const h=e[c];if(h.POSITION!==void 0&&(i=!0),h.NORMAL!==void 0&&(r=!0),h.COLOR_0!==void 0&&(s=!0),i&&r&&s)break}if(!i&&!r&&!s)return Promise.resolve(n);const o=[],a=[],l=[];for(let c=0,u=e.length;c<u;c++){const h=e[c];if(i){const d=h.POSITION!==void 0?t.getDependency("accessor",h.POSITION):n.attributes.position;o.push(d)}if(r){const d=h.NORMAL!==void 0?t.getDependency("accessor",h.NORMAL):n.attributes.normal;a.push(d)}if(s){const d=h.COLOR_0!==void 0?t.getDependency("accessor",h.COLOR_0):n.attributes.color;l.push(d)}}return Promise.all([Promise.all(o),Promise.all(a),Promise.all(l)]).then(function(c){const u=c[0],h=c[1],d=c[2];return i&&(n.morphAttributes.position=u),r&&(n.morphAttributes.normal=h),s&&(n.morphAttributes.color=d),n.morphTargetsRelative=!0,n})}function HU(n,e){if(n.updateMorphTargets(),e.weights!==void 0)for(let t=0,i=e.weights.length;t<i;t++)n.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(n.morphTargetInfluences.length===t.length){n.morphTargetDictionary={};for(let i=0,r=t.length;i<r;i++)n.morphTargetDictionary[t[i]]=i}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function GU(n){const e=n.extensions&&n.extensions[Je.KHR_DRACO_MESH_COMPRESSION];let t;return e?t="draco:"+e.bufferView+":"+e.indices+":"+Jy(e.attributes):t=n.indices+":"+Jy(n.attributes)+":"+n.mode,t}function Jy(n){let e="";const t=Object.keys(n).sort();for(let i=0,r=t.length;i<r;i++)e+=t[i]+":"+n[t[i]]+";";return e}function Yg(n){switch(n){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function VU(n){return n.search(/\.jpe?g($|\?)/i)>0||n.search(/^data\:image\/jpeg/)===0?"image/jpeg":n.search(/\.webp($|\?)/i)>0||n.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}class WU{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new _U,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};const i=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,r=navigator.userAgent.indexOf("Firefox")>-1,s=r?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1;typeof createImageBitmap=="undefined"||i||r&&s<98?this.textureLoader=new A0(this.options.manager):this.textureLoader=new Sw(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new T0(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const i=this,r=this.json,s=this.extensions;this.cache.removeAll(),this._invokeAll(function(o){return o._markDefs&&o._markDefs()}),Promise.all(this._invokeAll(function(o){return o.beforeRoot&&o.beforeRoot()})).then(function(){return Promise.all([i.getDependencies("scene"),i.getDependencies("animation"),i.getDependencies("camera")])}).then(function(o){const a={scene:o[0][r.scene||0],scenes:o[0],animations:o[1],cameras:o[2],asset:r.asset,parser:i,userData:{}};nc(s,a,r),Ys(a,r),Promise.all(i._invokeAll(function(l){return l.afterRoot&&l.afterRoot(a)})).then(function(){e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],i=this.json.meshes||[];for(let r=0,s=t.length;r<s;r++){const o=t[r].joints;for(let a=0,l=o.length;a<l;a++)e[o[a]].isBone=!0}for(let r=0,s=e.length;r<s;r++){const o=e[r];o.mesh!==void 0&&(this._addNodeRef(this.meshCache,o.mesh),o.skin!==void 0&&(i[o.mesh].isSkinnedMesh=!0)),o.camera!==void 0&&this._addNodeRef(this.cameraCache,o.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,i){if(e.refs[t]<=1)return i;const r=i.clone(),s=(o,a)=>{const l=this.associations.get(o);l!=null&&this.associations.set(a,l);for(const[c,u]of o.children.entries())s(u,a.children[c])};return s(i,r),r.name+="_instance_"+e.uses[t]++,r}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let i=0;i<t.length;i++){const r=e(t[i]);if(r)return r}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const i=[];for(let r=0;r<t.length;r++){const s=e(t[r]);s&&i.push(s)}return i}getDependency(e,t){const i=e+":"+t;let r=this.cache.get(i);if(!r){switch(e){case"scene":r=this.loadScene(t);break;case"node":r=this.loadNode(t);break;case"mesh":r=this._invokeOne(function(s){return s.loadMesh&&s.loadMesh(t)});break;case"accessor":r=this.loadAccessor(t);break;case"bufferView":r=this._invokeOne(function(s){return s.loadBufferView&&s.loadBufferView(t)});break;case"buffer":r=this.loadBuffer(t);break;case"material":r=this._invokeOne(function(s){return s.loadMaterial&&s.loadMaterial(t)});break;case"texture":r=this._invokeOne(function(s){return s.loadTexture&&s.loadTexture(t)});break;case"skin":r=this.loadSkin(t);break;case"animation":r=this._invokeOne(function(s){return s.loadAnimation&&s.loadAnimation(t)});break;case"camera":r=this.loadCamera(t);break;default:throw new Error("Unknown type: "+e)}this.cache.add(i,r)}return r}getDependencies(e){let t=this.cache.get(e);if(!t){const i=this,r=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(r.map(function(s,o){return i.getDependency(e,o)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],i=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[Je.KHR_BINARY_GLTF].body);const r=this.options;return new Promise(function(s,o){i.load(ps.resolveURL(t.uri,r.path),s,void 0,function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(i){const r=t.byteLength||0,s=t.byteOffset||0;return i.slice(s,s+r)})}loadAccessor(e){const t=this,i=this.json,r=this.json.accessors[e];if(r.bufferView===void 0&&r.sparse===void 0)return Promise.resolve(null);const s=[];return r.bufferView!==void 0?s.push(this.getDependency("bufferView",r.bufferView)):s.push(null),r.sparse!==void 0&&(s.push(this.getDependency("bufferView",r.sparse.indices.bufferView)),s.push(this.getDependency("bufferView",r.sparse.values.bufferView))),Promise.all(s).then(function(o){const a=o[0],l=Zy[r.type],c=cu[r.componentType],u=c.BYTES_PER_ELEMENT,h=u*l,d=r.byteOffset||0,p=r.bufferView!==void 0?i.bufferViews[r.bufferView].byteStride:void 0,v=r.normalized===!0;let m,f;if(p&&p!==h){const g=Math.floor(d/p),_="InterleavedBuffer:"+r.bufferView+":"+r.componentType+":"+g+":"+r.count;let M=t.cache.get(_);M||(m=new c(a,g*p,r.count*p/u),M=new Sl(m,p/u),t.cache.add(_,M)),f=new Qa(M,l,d%p/u,v)}else a===null?m=new c(r.count*l):m=new c(a,d,r.count*l),f=new Ut(m,l,v);if(r.sparse!==void 0){const g=Zy.SCALAR,_=cu[r.sparse.indices.componentType],M=r.sparse.indices.byteOffset||0,E=r.sparse.values.byteOffset||0,S=new _(o[1],M,r.sparse.count*g),T=new c(o[2],E,r.sparse.count*l);a!==null&&(f=new Ut(f.array.slice(),f.itemSize,f.normalized));for(let R=0,x=S.length;R<x;R++){const A=S[R];if(f.setX(A,T[R*l]),l>=2&&f.setY(A,T[R*l+1]),l>=3&&f.setZ(A,T[R*l+2]),l>=4&&f.setW(A,T[R*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return f})}loadTexture(e){const t=this.json,i=this.options,s=t.textures[e].source,o=t.images[s];let a=this.textureLoader;if(o.uri){const l=i.manager.getHandler(o.uri);l!==null&&(a=l)}return this.loadTextureImage(e,s,a)}loadTextureImage(e,t,i){const r=this,s=this.json,o=s.textures[e],a=s.images[t],l=(a.uri||a.bufferView)+":"+o.sampler;if(this.textureCache[l])return this.textureCache[l];const c=this.loadImageSource(t,i).then(function(u){u.flipY=!1,o.name&&(u.name=o.name);const d=(s.samplers||{})[o.sampler]||{};return u.magFilter=Yy[d.magFilter]||mn,u.minFilter=Yy[d.minFilter]||_l,u.wrapS=Ky[d.wrapS]||Ya,u.wrapT=Ky[d.wrapT]||Ya,r.associations.set(u,{textures:e}),u}).catch(function(){return null});return this.textureCache[l]=c,c}loadImageSource(e,t){const i=this,r=this.json,s=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(h=>h.clone());const o=r.images[e],a=self.URL||self.webkitURL;let l=o.uri||"",c=!1;if(o.bufferView!==void 0)l=i.getDependency("bufferView",o.bufferView).then(function(h){c=!0;const d=new Blob([h],{type:o.mimeType});return l=a.createObjectURL(d),l});else if(o.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const u=Promise.resolve(l).then(function(h){return new Promise(function(d,p){let v=d;t.isImageBitmapLoader===!0&&(v=function(m){const f=new Ht(m);f.needsUpdate=!0,d(f)}),t.load(ps.resolveURL(h,s.path),v,void 0,p)})}).then(function(h){return c===!0&&a.revokeObjectURL(l),h.userData.mimeType=o.mimeType||VU(o.uri),h}).catch(function(h){throw console.error("THREE.GLTFLoader: Couldn't load texture",l),h});return this.sourceCache[e]=u,u}assignTexture(e,t,i,r){const s=this;return this.getDependency("texture",i.index).then(function(o){if(i.texCoord!==void 0&&i.texCoord!=0&&!(t==="aoMap"&&i.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+i.texCoord+" for texture "+t+" not yet supported."),s.extensions[Je.KHR_TEXTURE_TRANSFORM]){const a=i.extensions!==void 0?i.extensions[Je.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const l=s.associations.get(o);o=s.extensions[Je.KHR_TEXTURE_TRANSFORM].extendTexture(o,a),s.associations.set(o,l)}}return r!==void 0&&(o.encoding=r),e[t]=o,o})}assignFinalMaterial(e){const t=e.geometry;let i=e.material;const r=t.attributes.tangent===void 0,s=t.attributes.color!==void 0,o=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+i.uuid;let l=this.cache.get(a);l||(l=new Qd,Rt.prototype.copy.call(l,i),l.color.copy(i.color),l.map=i.map,l.sizeAttenuation=!1,this.cache.add(a,l)),i=l}else if(e.isLine){const a="LineBasicMaterial:"+i.uuid;let l=this.cache.get(a);l||(l=new Ro,Rt.prototype.copy.call(l,i),l.color.copy(i.color),this.cache.add(a,l)),i=l}if(r||s||o){let a="ClonedMaterial:"+i.uuid+":";i.isGLTFSpecularGlossinessMaterial&&(a+="specular-glossiness:"),r&&(a+="derivative-tangents:"),s&&(a+="vertex-colors:"),o&&(a+="flat-shading:");let l=this.cache.get(a);l||(l=i.clone(),s&&(l.vertexColors=!0),o&&(l.flatShading=!0),r&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(a,l),this.associations.set(l,this.associations.get(i))),i=l}i.aoMap&&t.attributes.uv2===void 0&&t.attributes.uv!==void 0&&t.setAttribute("uv2",t.attributes.uv),e.material=i}getMaterialType(){return Ls}loadMaterial(e){const t=this,i=this.json,r=this.extensions,s=i.materials[e];let o;const a={},l=s.extensions||{},c=[];if(l[Je.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const h=r[Je.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];o=h.getMaterialType(),c.push(h.extendParams(a,s,t))}else if(l[Je.KHR_MATERIALS_UNLIT]){const h=r[Je.KHR_MATERIALS_UNLIT];o=h.getMaterialType(),c.push(h.extendParams(a,s,t))}else{const h=s.pbrMetallicRoughness||{};if(a.color=new we(1,1,1),a.opacity=1,Array.isArray(h.baseColorFactor)){const d=h.baseColorFactor;a.color.fromArray(d),a.opacity=d[3]}h.baseColorTexture!==void 0&&c.push(t.assignTexture(a,"map",h.baseColorTexture,it)),a.metalness=h.metallicFactor!==void 0?h.metallicFactor:1,a.roughness=h.roughnessFactor!==void 0?h.roughnessFactor:1,h.metallicRoughnessTexture!==void 0&&(c.push(t.assignTexture(a,"metalnessMap",h.metallicRoughnessTexture)),c.push(t.assignTexture(a,"roughnessMap",h.metallicRoughnessTexture))),o=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),c.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,a)})))}s.doubleSided===!0&&(a.side=po);const u=s.alphaMode||Zp.OPAQUE;if(u===Zp.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,u===Zp.MASK&&(a.alphaTest=s.alphaCutoff!==void 0?s.alphaCutoff:.5)),s.normalTexture!==void 0&&o!==Fn&&(c.push(t.assignTexture(a,"normalMap",s.normalTexture)),a.normalScale=new fe(1,1),s.normalTexture.scale!==void 0)){const h=s.normalTexture.scale;a.normalScale.set(h,h)}return s.occlusionTexture!==void 0&&o!==Fn&&(c.push(t.assignTexture(a,"aoMap",s.occlusionTexture)),s.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=s.occlusionTexture.strength)),s.emissiveFactor!==void 0&&o!==Fn&&(a.emissive=new we().fromArray(s.emissiveFactor)),s.emissiveTexture!==void 0&&o!==Fn&&c.push(t.assignTexture(a,"emissiveMap",s.emissiveTexture,it)),Promise.all(c).then(function(){let h;return o===jg?h=r[Je.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a):h=new o(a),s.name&&(h.name=s.name),Ys(h,s),t.associations.set(h,{materials:e}),s.extensions&&nc(r,h,s),h})}createUniqueName(e){const t=ot.sanitizeNodeName(e||"");let i=t;for(let r=1;this.nodeNamesUsed[i];++r)i=t+"_"+r;return this.nodeNamesUsed[i]=!0,i}loadGeometries(e){const t=this,i=this.extensions,r=this.primitiveCache;function s(a){return i[Je.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(l){return Qy(l,a,t)})}const o=[];for(let a=0,l=e.length;a<l;a++){const c=e[a],u=GU(c),h=r[u];if(h)o.push(h.promise);else{let d;c.extensions&&c.extensions[Je.KHR_DRACO_MESH_COMPRESSION]?d=s(c):d=Qy(new lt,c,t),r[u]={primitive:c,promise:d},o.push(d)}}return Promise.all(o)}loadMesh(e){const t=this,i=this.json,r=this.extensions,s=i.meshes[e],o=s.primitives,a=[];for(let l=0,c=o.length;l<c;l++){const u=o[l].material===void 0?zU(this.cache):this.getDependency("material",o[l].material);a.push(u)}return a.push(t.loadGeometries(o)),Promise.all(a).then(function(l){const c=l.slice(0,l.length-1),u=l[l.length-1],h=[];for(let p=0,v=u.length;p<v;p++){const m=u[p],f=o[p];let g;const _=c[p];if(f.mode===hr.TRIANGLES||f.mode===hr.TRIANGLE_STRIP||f.mode===hr.TRIANGLE_FAN||f.mode===void 0)g=s.isSkinnedMesh===!0?new g0(m,_):new dt(m,_),g.isSkinnedMesh===!0&&!g.geometry.attributes.skinWeight.normalized&&g.normalizeSkinWeights(),f.mode===hr.TRIANGLE_STRIP?g.geometry=eM(g.geometry,$T):f.mode===hr.TRIANGLE_FAN&&(g.geometry=eM(g.geometry,CS));else if(f.mode===hr.LINES)g=new Jd(m,_);else if(f.mode===hr.LINE_STRIP)g=new Zd(m,_);else if(f.mode===hr.LINE_LOOP)g=new YS(m,_);else if(f.mode===hr.POINTS)g=new KS(m,_);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+f.mode);Object.keys(g.geometry.morphAttributes).length>0&&HU(g,s),g.name=t.createUniqueName(s.name||"mesh_"+e),Ys(g,s),f.extensions&&nc(r,g,f),t.assignFinalMaterial(g),h.push(g)}for(let p=0,v=h.length;p<v;p++)t.associations.set(h[p],{meshes:e,primitives:p});if(h.length===1)return h[0];const d=new yt;t.associations.set(d,{meshes:e});for(let p=0,v=h.length;p<v;p++)d.add(h[p]);return d})}loadCamera(e){let t;const i=this.json.cameras[e],r=i[i.type];if(!r){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return i.type==="perspective"?t=new gn(Ze.radToDeg(r.yfov),r.aspectRatio||1,r.znear||1,r.zfar||2e6):i.type==="orthographic"&&(t=new yl(-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),i.name&&(t.name=this.createUniqueName(i.name)),Ys(t,i),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],i={joints:t.joints};return t.inverseBindMatrices===void 0?Promise.resolve(i):this.getDependency("accessor",t.inverseBindMatrices).then(function(r){return i.inverseBindMatrices=r,i})}loadAnimation(e){const i=this.json.animations[e],r=[],s=[],o=[],a=[],l=[];for(let c=0,u=i.channels.length;c<u;c++){const h=i.channels[c],d=i.samplers[h.sampler],p=h.target,v=p.node!==void 0?p.node:p.id,m=i.parameters!==void 0?i.parameters[d.input]:d.input,f=i.parameters!==void 0?i.parameters[d.output]:d.output;r.push(this.getDependency("node",v)),s.push(this.getDependency("accessor",m)),o.push(this.getDependency("accessor",f)),a.push(d),l.push(p)}return Promise.all([Promise.all(r),Promise.all(s),Promise.all(o),Promise.all(a),Promise.all(l)]).then(function(c){const u=c[0],h=c[1],d=c[2],p=c[3],v=c[4],m=[];for(let g=0,_=u.length;g<_;g++){const M=u[g],E=h[g],S=d[g],T=p[g],R=v[g];if(M===void 0)continue;M.updateMatrix(),M.matrixAutoUpdate=!0;let x;switch(jr[R.path]){case jr.weights:x=Vc;break;case jr.rotation:x=go;break;case jr.position:case jr.scale:default:x=Wc;break}const A=M.name?M.name:M.uuid,I=T.interpolation!==void 0?BU[T.interpolation]:Za,N=[];jr[R.path]===jr.weights?M.traverse(function(q){q.morphTargetInfluences&&N.push(q.name?q.name:q.uuid)}):N.push(A);let J=S.array;if(S.normalized){const q=Yg(J.constructor),L=new Float32Array(J.length);for(let $=0,z=J.length;$<z;$++)L[$]=J[$]*q;J=L}for(let q=0,L=N.length;q<L;q++){const $=new x(N[q]+"."+jr[R.path],E.array,J,I);T.interpolation==="CUBICSPLINE"&&($.createInterpolant=function(W){const U=this instanceof go?OU:So;return new U(this.times,this.values,this.getValueSize()/3,W)},$.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),m.push($)}}const f=i.name?i.name:"animation_"+e;return new Zm(f,void 0,m)})}createNodeMesh(e){const t=this.json,i=this,r=t.nodes[e];return r.mesh===void 0?null:i.getDependency("mesh",r.mesh).then(function(s){const o=i._getNodeRef(i.meshCache,r.mesh,s);return r.weights!==void 0&&o.traverse(function(a){if(!!a.isMesh)for(let l=0,c=r.weights.length;l<c;l++)a.morphTargetInfluences[l]=r.weights[l]}),o})}loadNode(e){const t=this.json,i=this.extensions,r=this,s=t.nodes[e],o=s.name?r.createUniqueName(s.name):"";return function(){const a=[],l=r._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(e)});return l&&a.push(l),s.camera!==void 0&&a.push(r.getDependency("camera",s.camera).then(function(c){return r._getNodeRef(r.cameraCache,s.camera,c)})),r._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(e)}).forEach(function(c){a.push(c)}),Promise.all(a)}().then(function(a){let l;if(s.isBone===!0?l=new v0:a.length>1?l=new yt:a.length===1?l=a[0]:l=new at,l!==a[0])for(let c=0,u=a.length;c<u;c++)l.add(a[c]);if(s.name&&(l.userData.name=s.name,l.name=o),Ys(l,s),s.extensions&&nc(i,l,s),s.matrix!==void 0){const c=new Ve;c.fromArray(s.matrix),l.applyMatrix4(c)}else s.translation!==void 0&&l.position.fromArray(s.translation),s.rotation!==void 0&&l.quaternion.fromArray(s.rotation),s.scale!==void 0&&l.scale.fromArray(s.scale);return r.associations.has(l)||r.associations.set(l,{}),r.associations.get(l).nodes=e,l})}loadScene(e){const t=this.json,i=this.extensions,r=this.json.scenes[e],s=this,o=new yt;r.name&&(o.name=s.createUniqueName(r.name)),Ys(o,r),r.extensions&&nc(i,o,r);const a=r.nodes||[],l=[];for(let c=0,u=a.length;c<u;c++)l.push(rb(a[c],o,t,s));return Promise.all(l).then(function(){const c=u=>{const h=new Map;for(const[d,p]of s.associations)(d instanceof Rt||d instanceof Ht)&&h.set(d,p);return u.traverse(d=>{const p=s.associations.get(d);p!=null&&h.set(d,p)}),h};return s.associations=c(o),o})}}function rb(n,e,t,i){const r=t.nodes[n];return i.getDependency("node",n).then(function(s){if(r.skin===void 0)return s;let o;return i.getDependency("skin",r.skin).then(function(a){o=a;const l=[];for(let c=0,u=o.joints.length;c<u;c++)l.push(i.getDependency("node",o.joints[c]));return Promise.all(l)}).then(function(a){return s.traverse(function(l){if(!l.isMesh)return;const c=[],u=[];for(let h=0,d=a.length;h<d;h++){const p=a[h];if(p){c.push(p);const v=new Ve;o.inverseBindMatrices!==void 0&&v.fromArray(o.inverseBindMatrices.array,h*16),u.push(v)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',o.joints[h])}l.bind(new _0(c,u),l.matrixWorld)}),s})}).then(function(s){e.add(s);const o=[];if(r.children){const a=r.children;for(let l=0,c=a.length;l<c;l++){const u=a[l];o.push(rb(u,s,t,i))}}return Promise.all(o)})}function $U(n,e,t){const i=e.attributes,r=new Mn;if(i.POSITION!==void 0){const a=t.json.accessors[i.POSITION],l=a.min,c=a.max;if(l!==void 0&&c!==void 0){if(r.set(new B(l[0],l[1],l[2]),new B(c[0],c[1],c[2])),a.normalized){const u=Yg(cu[a.componentType]);r.min.multiplyScalar(u),r.max.multiplyScalar(u)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const s=e.targets;if(s!==void 0){const a=new B,l=new B;for(let c=0,u=s.length;c<u;c++){const h=s[c];if(h.POSITION!==void 0){const d=t.json.accessors[h.POSITION],p=d.min,v=d.max;if(p!==void 0&&v!==void 0){if(l.setX(Math.max(Math.abs(p[0]),Math.abs(v[0]))),l.setY(Math.max(Math.abs(p[1]),Math.abs(v[1]))),l.setZ(Math.max(Math.abs(p[2]),Math.abs(v[2]))),d.normalized){const m=Yg(cu[d.componentType]);l.multiplyScalar(m)}a.max(l)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}r.expandByVector(a)}n.boundingBox=r;const o=new Gi;r.getCenter(o.center),o.radius=r.min.distanceTo(r.max)/2,n.boundingSphere=o}function Qy(n,e,t){const i=e.attributes,r=[];function s(o,a){return t.getDependency("accessor",o).then(function(l){n.setAttribute(a,l)})}for(const o in i){const a=qg[o]||o.toLowerCase();a in n.attributes||r.push(s(i[o],a))}if(e.indices!==void 0&&!n.index){const o=t.getDependency("accessor",e.indices).then(function(a){n.setIndex(a)});r.push(o)}return Ys(n,e),$U(n,e,t),Promise.all(r).then(function(){return e.targets!==void 0?kU(n,e.targets,t):n})}function eM(n,e){let t=n.getIndex();if(t===null){const o=[],a=n.getAttribute("position");if(a!==void 0){for(let l=0;l<a.count;l++)o.push(l);n.setIndex(o),t=n.getIndex()}else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),n}const i=t.count-2,r=[];if(e===CS)for(let o=1;o<=i;o++)r.push(t.getX(0)),r.push(t.getX(o)),r.push(t.getX(o+1));else for(let o=0;o<i;o++)o%2===0?(r.push(t.getX(o)),r.push(t.getX(o+1)),r.push(t.getX(o+2))):(r.push(t.getX(o+2)),r.push(t.getX(o+1)),r.push(t.getX(o)));r.length/3!==i&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=n.clone();return s.setIndex(r),s}var XU="/assets/clockNumbers.86db1478.glb";const jU=new vU,qU=[XU],YU=n=>new Promise((e,t)=>{jU.load(n,i=>{e(i)},()=>{},i=>{t(i)})}),KU=async()=>await Promise.all(qU.map(YU)),sb=class{constructor(){this.wDown=!1,this.aDown=!1,this.sDown=!1,this.dDown=!1,this.ctrlDown=!1,this.spaceDown=!1,this.escapeDown=!1,this._listener=null,this._offListener=null,this._setupListeners()}_setupListeners(){const n=this,{W_KEY_CODE:e,A_KEY_CODE:t,S_KEY_CODE:i,D_KEY_CODE:r,CTRL_KEY_CODE:s,SPACE_CODE:o,ESCAPE_CODE:a}=sb,l=c=>u=>{switch(u.code){case e:this.wDown=c;break;case i:this.sDown=c;break;case r:this.dDown=c;break;case t:this.aDown=c;break;case s:this.ctrlDown=c;break;case o:this.spaceDown=c;break;case a:this.escapeDown=c;break}};n._listener=l(!0),n._offListener=l(!1),document.addEventListener("keydown",n._listener),document.addEventListener("keyup",n._offListener)}destroy(){this._listener&&this._offListener&&(document.removeEventListener("keydown",this._listener),document.removeEventListener("keyup",this._offListener))}};let Fs=sb;Fs.W_KEY_CODE="KeyW";Fs.A_KEY_CODE="KeyA";Fs.S_KEY_CODE="KeyS";Fs.D_KEY_CODE="KeyD";Fs.CTRL_KEY_CODE="ShiftLeft";Fs.SPACE_CODE="Space";Fs.ESCAPE_CODE="Escape";var ZU="/assets/bullet.b9986489.png";const JU="140",QU=0,tM=1,eO=2,ob=1,tO=2,vc=3,uu=0,Hi=1,dl=2,nO=1,ws=0,Va=1,nM=2,iM=3,rM=4,iO=5,ga=100,rO=101,sO=102,sM=103,oM=104,oO=200,aO=201,lO=202,cO=203,ab=204,lb=205,uO=206,hO=207,dO=208,fO=209,pO=210,mO=0,gO=1,vO=2,Kg=3,_O=4,xO=5,yO=6,MO=7,cb=0,SO=1,wO=2,Rr=0,EO=1,bO=2,TO=3,AO=4,CO=5,ub=300,fl=301,pl=302,Zg=303,Jg=304,Tf=306,Qg=1e3,Fi=1001,e0=1002,Nn=1003,aM=1004,lM=1005,li=1006,RO=1007,Af=1008,wo=1009,LO=1010,PO=1011,hu=1012,DO=1013,ld=1014,ro=1015,du=1016,IO=1017,NO=1018,Wa=1020,FO=1021,UO=1022,Ui=1023,OO=1024,BO=1025,uo=1026,ml=1027,zO=1028,kO=1029,HO=1030,GO=1031,VO=1033,Jp=33776,Qp=33777,em=33778,tm=33779,cM=35840,uM=35841,hM=35842,dM=35843,WO=36196,fM=37492,pM=37496,mM=37808,gM=37809,vM=37810,_M=37811,xM=37812,yM=37813,MM=37814,SM=37815,wM=37816,EM=37817,bM=37818,TM=37819,AM=37820,CM=37821,RM=36492,Eo=3e3,St=3001,$O=3200,XO=3201,jO=0,qO=1,yr="srgb",so="srgb-linear",nm=7680,YO=519,LM=35044,PM="300 es",t0=1035,tn=[];for(let n=0;n<256;n++)tn[n]=(n<16?"0":"")+n.toString(16);const im=Math.PI/180,DM=180/Math.PI;function bu(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(tn[n&255]+tn[n>>8&255]+tn[n>>16&255]+tn[n>>24&255]+"-"+tn[e&255]+tn[e>>8&255]+"-"+tn[e>>16&15|64]+tn[e>>24&255]+"-"+tn[t&63|128]+tn[t>>8&255]+"-"+tn[t>>16&255]+tn[t>>24&255]+tn[i&255]+tn[i>>8&255]+tn[i>>16&255]+tn[i>>24&255]).toLowerCase()}function Kn(n,e,t){return Math.max(e,Math.min(t,n))}function KO(n,e){return(n%e+e)%e}function rm(n,e,t){return(1-t)*n+t*e}function IM(n){return(n&n-1)===0&&n!==0}function n0(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}class Ll{constructor(e=0,t=0,i=0,r=1){this._x=e,this._y=t,this._z=i,this._w=r}static slerp(e,t,i,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),i.slerpQuaternions(e,t,r)}static slerpFlat(e,t,i,r,s,o,a){let l=i[r+0],c=i[r+1],u=i[r+2],h=i[r+3];const d=s[o+0],p=s[o+1],v=s[o+2],m=s[o+3];if(a===0){e[t+0]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h;return}if(a===1){e[t+0]=d,e[t+1]=p,e[t+2]=v,e[t+3]=m;return}if(h!==m||l!==d||c!==p||u!==v){let f=1-a;const g=l*d+c*p+u*v+h*m,_=g>=0?1:-1,M=1-g*g;if(M>Number.EPSILON){const S=Math.sqrt(M),T=Math.atan2(S,g*_);f=Math.sin(f*T)/S,a=Math.sin(a*T)/S}const E=a*_;if(l=l*f+d*E,c=c*f+p*E,u=u*f+v*E,h=h*f+m*E,f===1-a){const S=1/Math.sqrt(l*l+c*c+u*u+h*h);l*=S,c*=S,u*=S,h*=S}}e[t]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h}static multiplyQuaternionsFlat(e,t,i,r,s,o){const a=i[r],l=i[r+1],c=i[r+2],u=i[r+3],h=s[o],d=s[o+1],p=s[o+2],v=s[o+3];return e[t]=a*v+u*h+l*p-c*d,e[t+1]=l*v+u*d+c*h-a*p,e[t+2]=c*v+u*p+a*d-l*h,e[t+3]=u*v-a*h-l*d-c*p,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,i,r){return this._x=e,this._y=t,this._z=i,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=e._x,r=e._y,s=e._z,o=e._order,a=Math.cos,l=Math.sin,c=a(i/2),u=a(r/2),h=a(s/2),d=l(i/2),p=l(r/2),v=l(s/2);switch(o){case"XYZ":this._x=d*u*h+c*p*v,this._y=c*p*h-d*u*v,this._z=c*u*v+d*p*h,this._w=c*u*h-d*p*v;break;case"YXZ":this._x=d*u*h+c*p*v,this._y=c*p*h-d*u*v,this._z=c*u*v-d*p*h,this._w=c*u*h+d*p*v;break;case"ZXY":this._x=d*u*h-c*p*v,this._y=c*p*h+d*u*v,this._z=c*u*v+d*p*h,this._w=c*u*h-d*p*v;break;case"ZYX":this._x=d*u*h-c*p*v,this._y=c*p*h+d*u*v,this._z=c*u*v-d*p*h,this._w=c*u*h+d*p*v;break;case"YZX":this._x=d*u*h+c*p*v,this._y=c*p*h+d*u*v,this._z=c*u*v-d*p*h,this._w=c*u*h-d*p*v;break;case"XZY":this._x=d*u*h-c*p*v,this._y=c*p*h-d*u*v,this._z=c*u*v+d*p*h,this._w=c*u*h+d*p*v;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const i=t/2,r=Math.sin(i);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,i=t[0],r=t[4],s=t[8],o=t[1],a=t[5],l=t[9],c=t[2],u=t[6],h=t[10],d=i+a+h;if(d>0){const p=.5/Math.sqrt(d+1);this._w=.25/p,this._x=(u-l)*p,this._y=(s-c)*p,this._z=(o-r)*p}else if(i>a&&i>h){const p=2*Math.sqrt(1+i-a-h);this._w=(u-l)/p,this._x=.25*p,this._y=(r+o)/p,this._z=(s+c)/p}else if(a>h){const p=2*Math.sqrt(1+a-i-h);this._w=(s-c)/p,this._x=(r+o)/p,this._y=.25*p,this._z=(l+u)/p}else{const p=2*Math.sqrt(1+h-i-a);this._w=(o-r)/p,this._x=(s+c)/p,this._y=(l+u)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let i=e.dot(t)+1;return i<Number.EPSILON?(i=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=i):(this._x=0,this._y=-e.z,this._z=e.y,this._w=i)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=i),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Kn(this.dot(e),-1,1)))}rotateTowards(e,t){const i=this.angleTo(e);if(i===0)return this;const r=Math.min(1,t/i);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const i=e._x,r=e._y,s=e._z,o=e._w,a=t._x,l=t._y,c=t._z,u=t._w;return this._x=i*u+o*a+r*c-s*l,this._y=r*u+o*l+s*a-i*c,this._z=s*u+o*c+i*l-r*a,this._w=o*u-i*a-r*l-s*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const i=this._x,r=this._y,s=this._z,o=this._w;let a=o*e._w+i*e._x+r*e._y+s*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=i,this._y=r,this._z=s,this;const l=1-a*a;if(l<=Number.EPSILON){const p=1-t;return this._w=p*o+t*this._w,this._x=p*i+t*this._x,this._y=p*r+t*this._y,this._z=p*s+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),u=Math.atan2(c,a),h=Math.sin((1-t)*u)/c,d=Math.sin(t*u)/c;return this._w=o*h+this._w*d,this._x=i*h+this._x*d,this._y=r*h+this._y*d,this._z=s*h+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,i){return this.copy(e).slerp(t,i)}random(){const e=Math.random(),t=Math.sqrt(1-e),i=Math.sqrt(e),r=2*Math.PI*Math.random(),s=2*Math.PI*Math.random();return this.set(t*Math.cos(r),i*Math.sin(s),i*Math.cos(s),t*Math.sin(r))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}Ll.prototype.isQuaternion=!0;class se{constructor(e=0,t=0,i=0){this.x=e,this.y=t,this.z=i}set(e,t,i){return i===void 0&&(i=this.z),this.x=e,this.y=t,this.z=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(NM.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(NM.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,i=this.y,r=this.z,s=e.elements;return this.x=s[0]*t+s[3]*i+s[6]*r,this.y=s[1]*t+s[4]*i+s[7]*r,this.z=s[2]*t+s[5]*i+s[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,i=this.y,r=this.z,s=e.elements,o=1/(s[3]*t+s[7]*i+s[11]*r+s[15]);return this.x=(s[0]*t+s[4]*i+s[8]*r+s[12])*o,this.y=(s[1]*t+s[5]*i+s[9]*r+s[13])*o,this.z=(s[2]*t+s[6]*i+s[10]*r+s[14])*o,this}applyQuaternion(e){const t=this.x,i=this.y,r=this.z,s=e.x,o=e.y,a=e.z,l=e.w,c=l*t+o*r-a*i,u=l*i+a*t-s*r,h=l*r+s*i-o*t,d=-s*t-o*i-a*r;return this.x=c*l+d*-s+u*-a-h*-o,this.y=u*l+d*-o+h*-s-c*-a,this.z=h*l+d*-a+c*-o-u*-s,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,i=this.y,r=this.z,s=e.elements;return this.x=s[0]*t+s[4]*i+s[8]*r,this.y=s[1]*t+s[5]*i+s[9]*r,this.z=s[2]*t+s[6]*i+s[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const i=e.x,r=e.y,s=e.z,o=t.x,a=t.y,l=t.z;return this.x=r*l-s*a,this.y=s*o-i*l,this.z=i*a-r*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const i=e.dot(this)/t;return this.copy(e).multiplyScalar(i)}projectOnPlane(e){return sm.copy(this).projectOnVector(e),this.sub(sm)}reflect(e){return this.sub(sm.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const i=this.dot(e)/t;return Math.acos(Kn(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y,r=this.z-e.z;return t*t+i*i+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,i){const r=Math.sin(t)*e;return this.x=r*Math.sin(i),this.y=Math.cos(t)*e,this.z=r*Math.cos(i),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,i){return this.x=e*Math.sin(t),this.y=i,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),i=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=i,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,i){return i!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,i=Math.sqrt(1-e**2);return this.x=i*Math.cos(t),this.y=i*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}se.prototype.isVector3=!0;const sm=new se,NM=new Ll;class Pl{constructor(e=new se(1/0,1/0,1/0),t=new se(-1/0,-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,i=1/0,r=1/0,s=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.length;l<c;l+=3){const u=e[l],h=e[l+1],d=e[l+2];u<t&&(t=u),h<i&&(i=h),d<r&&(r=d),u>s&&(s=u),h>o&&(o=h),d>a&&(a=d)}return this.min.set(t,i,r),this.max.set(s,o,a),this}setFromBufferAttribute(e){let t=1/0,i=1/0,r=1/0,s=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.count;l<c;l++){const u=e.getX(l),h=e.getY(l),d=e.getZ(l);u<t&&(t=u),h<i&&(i=h),d<r&&(r=d),u>s&&(s=u),h>o&&(o=h),d>a&&(a=d)}return this.min.set(t,i,r),this.max.set(s,o,a),this}setFromPoints(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const i=Vs.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(i),this.max.copy(e).add(i),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const i=e.geometry;if(i!==void 0)if(t&&i.attributes!=null&&i.attributes.position!==void 0){const s=i.attributes.position;for(let o=0,a=s.count;o<a;o++)Vs.fromBufferAttribute(s,o).applyMatrix4(e.matrixWorld),this.expandByPoint(Vs)}else i.boundingBox===null&&i.computeBoundingBox(),om.copy(i.boundingBox),om.applyMatrix4(e.matrixWorld),this.union(om);const r=e.children;for(let s=0,o=r.length;s<o;s++)this.expandByObject(r[s],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,Vs),Vs.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,i;return e.normal.x>0?(t=e.normal.x*this.min.x,i=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,i=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,i+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,i+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,i+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,i+=e.normal.z*this.min.z),t<=-e.constant&&i>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(ic),bh.subVectors(this.max,ic),ea.subVectors(e.a,ic),ta.subVectors(e.b,ic),na.subVectors(e.c,ic),qr.subVectors(ta,ea),Yr.subVectors(na,ta),Ws.subVectors(ea,na);let t=[0,-qr.z,qr.y,0,-Yr.z,Yr.y,0,-Ws.z,Ws.y,qr.z,0,-qr.x,Yr.z,0,-Yr.x,Ws.z,0,-Ws.x,-qr.y,qr.x,0,-Yr.y,Yr.x,0,-Ws.y,Ws.x,0];return!am(t,ea,ta,na,bh)||(t=[1,0,0,0,1,0,0,0,1],!am(t,ea,ta,na,bh))?!1:(Th.crossVectors(qr,Yr),t=[Th.x,Th.y,Th.z],am(t,ea,ta,na,bh))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return Vs.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=this.getSize(Vs).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(dr[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),dr[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),dr[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),dr[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),dr[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),dr[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),dr[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),dr[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(dr),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}Pl.prototype.isBox3=!0;const dr=[new se,new se,new se,new se,new se,new se,new se,new se],Vs=new se,om=new Pl,ea=new se,ta=new se,na=new se,qr=new se,Yr=new se,Ws=new se,ic=new se,bh=new se,Th=new se,$s=new se;function am(n,e,t,i,r){for(let s=0,o=n.length-3;s<=o;s+=3){$s.fromArray(n,s);const a=r.x*Math.abs($s.x)+r.y*Math.abs($s.y)+r.z*Math.abs($s.z),l=e.dot($s),c=t.dot($s),u=i.dot($s);if(Math.max(-Math.max(l,c,u),Math.min(l,c,u))>a)return!1}return!0}const ZO=new Pl,FM=new se,Ah=new se,lm=new se;class Fv{constructor(e=new se,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const i=this.center;t!==void 0?i.copy(t):ZO.setFromPoints(e).getCenter(i);let r=0;for(let s=0,o=e.length;s<o;s++)r=Math.max(r,i.distanceToSquared(e[s]));return this.radius=Math.sqrt(r),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const i=this.center.distanceToSquared(e);return t.copy(e),i>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){lm.subVectors(e,this.center);const t=lm.lengthSq();if(t>this.radius*this.radius){const i=Math.sqrt(t),r=(i-this.radius)*.5;this.center.add(lm.multiplyScalar(r/i)),this.radius+=r}return this}union(e){return this.center.equals(e.center)===!0?Ah.set(0,0,1).multiplyScalar(e.radius):Ah.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(FM.copy(e.center).add(Ah)),this.expandByPoint(FM.copy(e.center).sub(Ah)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}class Oi{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,i,r,s,o,a,l,c){const u=this.elements;return u[0]=e,u[1]=r,u[2]=a,u[3]=t,u[4]=s,u[5]=l,u[6]=i,u[7]=o,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],this}extractBasis(e,t,i){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,r=t.elements,s=this.elements,o=i[0],a=i[3],l=i[6],c=i[1],u=i[4],h=i[7],d=i[2],p=i[5],v=i[8],m=r[0],f=r[3],g=r[6],_=r[1],M=r[4],E=r[7],S=r[2],T=r[5],R=r[8];return s[0]=o*m+a*_+l*S,s[3]=o*f+a*M+l*T,s[6]=o*g+a*E+l*R,s[1]=c*m+u*_+h*S,s[4]=c*f+u*M+h*T,s[7]=c*g+u*E+h*R,s[2]=d*m+p*_+v*S,s[5]=d*f+p*M+v*T,s[8]=d*g+p*E+v*R,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8];return t*o*u-t*a*c-i*s*u+i*a*l+r*s*c-r*o*l}invert(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=u*o-a*c,d=a*l-u*s,p=c*s-o*l,v=t*h+i*d+r*p;if(v===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/v;return e[0]=h*m,e[1]=(r*c-u*i)*m,e[2]=(a*i-r*o)*m,e[3]=d*m,e[4]=(u*t-r*l)*m,e[5]=(r*s-a*t)*m,e[6]=p*m,e[7]=(i*l-c*t)*m,e[8]=(o*t-i*s)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,i,r,s,o,a){const l=Math.cos(s),c=Math.sin(s);return this.set(i*l,i*c,-i*(l*o+c*a)+o+e,-r*c,r*l,-r*(-c*o+l*a)+a+t,0,0,1),this}scale(e,t){const i=this.elements;return i[0]*=e,i[3]*=e,i[6]*=e,i[1]*=t,i[4]*=t,i[7]*=t,this}rotate(e){const t=Math.cos(e),i=Math.sin(e),r=this.elements,s=r[0],o=r[3],a=r[6],l=r[1],c=r[4],u=r[7];return r[0]=t*s+i*l,r[3]=t*o+i*c,r[6]=t*a+i*u,r[1]=-i*s+t*l,r[4]=-i*o+t*c,r[7]=-i*a+t*u,this}translate(e,t){const i=this.elements;return i[0]+=e*i[2],i[3]+=e*i[5],i[6]+=e*i[8],i[1]+=t*i[2],i[4]+=t*i[5],i[7]+=t*i[8],this}equals(e){const t=this.elements,i=e.elements;for(let r=0;r<9;r++)if(t[r]!==i[r])return!1;return!0}fromArray(e,t=0){for(let i=0;i<9;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e}clone(){return new this.constructor().fromArray(this.elements)}}Oi.prototype.isMatrix3=!0;const cm=new se,JO=new se,QO=new Oi;class ss{constructor(e=new se(1,0,0),t=0){this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,i,r){return this.normal.set(e,t,i),this.constant=r,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,i){const r=cm.subVectors(i,t).cross(JO.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(r,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const i=e.delta(cm),r=this.normal.dot(i);if(r===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const s=-(e.start.dot(this.normal)+this.constant)/r;return s<0||s>1?null:t.copy(i).multiplyScalar(s).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),i=this.distanceToPoint(e.end);return t<0&&i>0||i<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const i=t||QO.getNormalMatrix(e),r=this.coplanarPoint(cm).applyMatrix4(e),s=this.normal.applyMatrix3(i).normalize();return this.constant=-r.dot(s),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}ss.prototype.isPlane=!0;const ia=new Fv,Ch=new se;class hb{constructor(e=new ss,t=new ss,i=new ss,r=new ss,s=new ss,o=new ss){this.planes=[e,t,i,r,s,o]}set(e,t,i,r,s,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(i),a[3].copy(r),a[4].copy(s),a[5].copy(o),this}copy(e){const t=this.planes;for(let i=0;i<6;i++)t[i].copy(e.planes[i]);return this}setFromProjectionMatrix(e){const t=this.planes,i=e.elements,r=i[0],s=i[1],o=i[2],a=i[3],l=i[4],c=i[5],u=i[6],h=i[7],d=i[8],p=i[9],v=i[10],m=i[11],f=i[12],g=i[13],_=i[14],M=i[15];return t[0].setComponents(a-r,h-l,m-d,M-f).normalize(),t[1].setComponents(a+r,h+l,m+d,M+f).normalize(),t[2].setComponents(a+s,h+c,m+p,M+g).normalize(),t[3].setComponents(a-s,h-c,m-p,M-g).normalize(),t[4].setComponents(a-o,h-u,m-v,M-_).normalize(),t[5].setComponents(a+o,h+u,m+v,M+_).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),ia.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(ia)}intersectsSprite(e){return ia.center.set(0,0,0),ia.radius=.7071067811865476,ia.applyMatrix4(e.matrixWorld),this.intersectsSphere(ia)}intersectsSphere(e){const t=this.planes,i=e.center,r=-e.radius;for(let s=0;s<6;s++)if(t[s].distanceToPoint(i)<r)return!1;return!0}intersectsBox(e){const t=this.planes;for(let i=0;i<6;i++){const r=t[i];if(Ch.x=r.normal.x>0?e.max.x:e.min.x,Ch.y=r.normal.y>0?e.max.y:e.min.y,Ch.z=r.normal.z>0?e.max.z:e.min.z,r.distanceToPoint(Ch)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let i=0;i<6;i++)if(t[i].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}class ln{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,i,r,s,o,a,l,c,u,h,d,p,v,m,f){const g=this.elements;return g[0]=e,g[4]=t,g[8]=i,g[12]=r,g[1]=s,g[5]=o,g[9]=a,g[13]=l,g[2]=c,g[6]=u,g[10]=h,g[14]=d,g[3]=p,g[7]=v,g[11]=m,g[15]=f,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new ln().fromArray(this.elements)}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],t[9]=i[9],t[10]=i[10],t[11]=i[11],t[12]=i[12],t[13]=i[13],t[14]=i[14],t[15]=i[15],this}copyPosition(e){const t=this.elements,i=e.elements;return t[12]=i[12],t[13]=i[13],t[14]=i[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,i){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(e,t,i){return this.set(e.x,t.x,i.x,0,e.y,t.y,i.y,0,e.z,t.z,i.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,i=e.elements,r=1/ra.setFromMatrixColumn(e,0).length(),s=1/ra.setFromMatrixColumn(e,1).length(),o=1/ra.setFromMatrixColumn(e,2).length();return t[0]=i[0]*r,t[1]=i[1]*r,t[2]=i[2]*r,t[3]=0,t[4]=i[4]*s,t[5]=i[5]*s,t[6]=i[6]*s,t[7]=0,t[8]=i[8]*o,t[9]=i[9]*o,t[10]=i[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,i=e.x,r=e.y,s=e.z,o=Math.cos(i),a=Math.sin(i),l=Math.cos(r),c=Math.sin(r),u=Math.cos(s),h=Math.sin(s);if(e.order==="XYZ"){const d=o*u,p=o*h,v=a*u,m=a*h;t[0]=l*u,t[4]=-l*h,t[8]=c,t[1]=p+v*c,t[5]=d-m*c,t[9]=-a*l,t[2]=m-d*c,t[6]=v+p*c,t[10]=o*l}else if(e.order==="YXZ"){const d=l*u,p=l*h,v=c*u,m=c*h;t[0]=d+m*a,t[4]=v*a-p,t[8]=o*c,t[1]=o*h,t[5]=o*u,t[9]=-a,t[2]=p*a-v,t[6]=m+d*a,t[10]=o*l}else if(e.order==="ZXY"){const d=l*u,p=l*h,v=c*u,m=c*h;t[0]=d-m*a,t[4]=-o*h,t[8]=v+p*a,t[1]=p+v*a,t[5]=o*u,t[9]=m-d*a,t[2]=-o*c,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const d=o*u,p=o*h,v=a*u,m=a*h;t[0]=l*u,t[4]=v*c-p,t[8]=d*c+m,t[1]=l*h,t[5]=m*c+d,t[9]=p*c-v,t[2]=-c,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const d=o*l,p=o*c,v=a*l,m=a*c;t[0]=l*u,t[4]=m-d*h,t[8]=v*h+p,t[1]=h,t[5]=o*u,t[9]=-a*u,t[2]=-c*u,t[6]=p*h+v,t[10]=d-m*h}else if(e.order==="XZY"){const d=o*l,p=o*c,v=a*l,m=a*c;t[0]=l*u,t[4]=-h,t[8]=c*u,t[1]=d*h+m,t[5]=o*u,t[9]=p*h-v,t[2]=v*h-p,t[6]=a*u,t[10]=m*h+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(eB,e,tB)}lookAt(e,t,i){const r=this.elements;return jn.subVectors(e,t),jn.lengthSq()===0&&(jn.z=1),jn.normalize(),Kr.crossVectors(i,jn),Kr.lengthSq()===0&&(Math.abs(i.z)===1?jn.x+=1e-4:jn.z+=1e-4,jn.normalize(),Kr.crossVectors(i,jn)),Kr.normalize(),Rh.crossVectors(jn,Kr),r[0]=Kr.x,r[4]=Rh.x,r[8]=jn.x,r[1]=Kr.y,r[5]=Rh.y,r[9]=jn.y,r[2]=Kr.z,r[6]=Rh.z,r[10]=jn.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,r=t.elements,s=this.elements,o=i[0],a=i[4],l=i[8],c=i[12],u=i[1],h=i[5],d=i[9],p=i[13],v=i[2],m=i[6],f=i[10],g=i[14],_=i[3],M=i[7],E=i[11],S=i[15],T=r[0],R=r[4],x=r[8],A=r[12],I=r[1],N=r[5],J=r[9],q=r[13],L=r[2],$=r[6],z=r[10],W=r[14],U=r[3],P=r[7],k=r[11],Y=r[15];return s[0]=o*T+a*I+l*L+c*U,s[4]=o*R+a*N+l*$+c*P,s[8]=o*x+a*J+l*z+c*k,s[12]=o*A+a*q+l*W+c*Y,s[1]=u*T+h*I+d*L+p*U,s[5]=u*R+h*N+d*$+p*P,s[9]=u*x+h*J+d*z+p*k,s[13]=u*A+h*q+d*W+p*Y,s[2]=v*T+m*I+f*L+g*U,s[6]=v*R+m*N+f*$+g*P,s[10]=v*x+m*J+f*z+g*k,s[14]=v*A+m*q+f*W+g*Y,s[3]=_*T+M*I+E*L+S*U,s[7]=_*R+M*N+E*$+S*P,s[11]=_*x+M*J+E*z+S*k,s[15]=_*A+M*q+E*W+S*Y,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[4],r=e[8],s=e[12],o=e[1],a=e[5],l=e[9],c=e[13],u=e[2],h=e[6],d=e[10],p=e[14],v=e[3],m=e[7],f=e[11],g=e[15];return v*(+s*l*h-r*c*h-s*a*d+i*c*d+r*a*p-i*l*p)+m*(+t*l*p-t*c*d+s*o*d-r*o*p+r*c*u-s*l*u)+f*(+t*c*h-t*a*p-s*o*h+i*o*p+s*a*u-i*c*u)+g*(-r*a*u-t*l*h+t*a*d+r*o*h-i*o*d+i*l*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,i){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=i),this}invert(){const e=this.elements,t=e[0],i=e[1],r=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],d=e[10],p=e[11],v=e[12],m=e[13],f=e[14],g=e[15],_=h*f*c-m*d*c+m*l*p-a*f*p-h*l*g+a*d*g,M=v*d*c-u*f*c-v*l*p+o*f*p+u*l*g-o*d*g,E=u*m*c-v*h*c+v*a*p-o*m*p-u*a*g+o*h*g,S=v*h*l-u*m*l-v*a*d+o*m*d+u*a*f-o*h*f,T=t*_+i*M+r*E+s*S;if(T===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const R=1/T;return e[0]=_*R,e[1]=(m*d*s-h*f*s-m*r*p+i*f*p+h*r*g-i*d*g)*R,e[2]=(a*f*s-m*l*s+m*r*c-i*f*c-a*r*g+i*l*g)*R,e[3]=(h*l*s-a*d*s-h*r*c+i*d*c+a*r*p-i*l*p)*R,e[4]=M*R,e[5]=(u*f*s-v*d*s+v*r*p-t*f*p-u*r*g+t*d*g)*R,e[6]=(v*l*s-o*f*s-v*r*c+t*f*c+o*r*g-t*l*g)*R,e[7]=(o*d*s-u*l*s+u*r*c-t*d*c-o*r*p+t*l*p)*R,e[8]=E*R,e[9]=(v*h*s-u*m*s-v*i*p+t*m*p+u*i*g-t*h*g)*R,e[10]=(o*m*s-v*a*s+v*i*c-t*m*c-o*i*g+t*a*g)*R,e[11]=(u*a*s-o*h*s-u*i*c+t*h*c+o*i*p-t*a*p)*R,e[12]=S*R,e[13]=(u*m*r-v*h*r+v*i*d-t*m*d-u*i*f+t*h*f)*R,e[14]=(v*a*r-o*m*r-v*i*l+t*m*l+o*i*f-t*a*f)*R,e[15]=(o*h*r-u*a*r+u*i*l-t*h*l-o*i*d+t*a*d)*R,this}scale(e){const t=this.elements,i=e.x,r=e.y,s=e.z;return t[0]*=i,t[4]*=r,t[8]*=s,t[1]*=i,t[5]*=r,t[9]*=s,t[2]*=i,t[6]*=r,t[10]*=s,t[3]*=i,t[7]*=r,t[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],i=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,i,r))}makeTranslation(e,t,i){return this.set(1,0,0,e,0,1,0,t,0,0,1,i,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),i=Math.sin(e);return this.set(1,0,0,0,0,t,-i,0,0,i,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,0,i,0,0,1,0,0,-i,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,-i,0,0,i,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const i=Math.cos(t),r=Math.sin(t),s=1-i,o=e.x,a=e.y,l=e.z,c=s*o,u=s*a;return this.set(c*o+i,c*a-r*l,c*l+r*a,0,c*a+r*l,u*a+i,u*l-r*o,0,c*l-r*a,u*l+r*o,s*l*l+i,0,0,0,0,1),this}makeScale(e,t,i){return this.set(e,0,0,0,0,t,0,0,0,0,i,0,0,0,0,1),this}makeShear(e,t,i,r,s,o){return this.set(1,i,s,0,e,1,o,0,t,r,1,0,0,0,0,1),this}compose(e,t,i){const r=this.elements,s=t._x,o=t._y,a=t._z,l=t._w,c=s+s,u=o+o,h=a+a,d=s*c,p=s*u,v=s*h,m=o*u,f=o*h,g=a*h,_=l*c,M=l*u,E=l*h,S=i.x,T=i.y,R=i.z;return r[0]=(1-(m+g))*S,r[1]=(p+E)*S,r[2]=(v-M)*S,r[3]=0,r[4]=(p-E)*T,r[5]=(1-(d+g))*T,r[6]=(f+_)*T,r[7]=0,r[8]=(v+M)*R,r[9]=(f-_)*R,r[10]=(1-(d+m))*R,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,i){const r=this.elements;let s=ra.set(r[0],r[1],r[2]).length();const o=ra.set(r[4],r[5],r[6]).length(),a=ra.set(r[8],r[9],r[10]).length();this.determinant()<0&&(s=-s),e.x=r[12],e.y=r[13],e.z=r[14],Ai.copy(this);const c=1/s,u=1/o,h=1/a;return Ai.elements[0]*=c,Ai.elements[1]*=c,Ai.elements[2]*=c,Ai.elements[4]*=u,Ai.elements[5]*=u,Ai.elements[6]*=u,Ai.elements[8]*=h,Ai.elements[9]*=h,Ai.elements[10]*=h,t.setFromRotationMatrix(Ai),i.x=s,i.y=o,i.z=a,this}makePerspective(e,t,i,r,s,o){o===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,l=2*s/(t-e),c=2*s/(i-r),u=(t+e)/(t-e),h=(i+r)/(i-r),d=-(o+s)/(o-s),p=-2*o*s/(o-s);return a[0]=l,a[4]=0,a[8]=u,a[12]=0,a[1]=0,a[5]=c,a[9]=h,a[13]=0,a[2]=0,a[6]=0,a[10]=d,a[14]=p,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,i,r,s,o){const a=this.elements,l=1/(t-e),c=1/(i-r),u=1/(o-s),h=(t+e)*l,d=(i+r)*c,p=(o+s)*u;return a[0]=2*l,a[4]=0,a[8]=0,a[12]=-h,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-d,a[2]=0,a[6]=0,a[10]=-2*u,a[14]=-p,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){const t=this.elements,i=e.elements;for(let r=0;r<16;r++)if(t[r]!==i[r])return!1;return!0}fromArray(e,t=0){for(let i=0;i<16;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e[t+9]=i[9],e[t+10]=i[10],e[t+11]=i[11],e[t+12]=i[12],e[t+13]=i[13],e[t+14]=i[14],e[t+15]=i[15],e}}ln.prototype.isMatrix4=!0;const ra=new se,Ai=new ln,eB=new se(0,0,0),tB=new se(1,1,1),Kr=new se,Rh=new se,jn=new se;class mt{constructor(e=0,t=0){this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,i=this.y,r=e.elements;return this.x=r[0]*t+r[3]*i+r[6],this.y=r[1]*t+r[4]*i+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y;return t*t+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,i){return i!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const i=Math.cos(t),r=Math.sin(t),s=this.x-e.x,o=this.y-e.y;return this.x=s*i-o*r+e.x,this.y=s*r+o*i+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}mt.prototype.isVector2=!0;class _n{constructor(e=0,t=0,i=0,r=1){this.x=e,this.y=t,this.z=i,this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,i,r){return this.x=e,this.y=t,this.z=i,this.w=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,i=this.y,r=this.z,s=this.w,o=e.elements;return this.x=o[0]*t+o[4]*i+o[8]*r+o[12]*s,this.y=o[1]*t+o[5]*i+o[9]*r+o[13]*s,this.z=o[2]*t+o[6]*i+o[10]*r+o[14]*s,this.w=o[3]*t+o[7]*i+o[11]*r+o[15]*s,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,i,r,s;const l=e.elements,c=l[0],u=l[4],h=l[8],d=l[1],p=l[5],v=l[9],m=l[2],f=l[6],g=l[10];if(Math.abs(u-d)<.01&&Math.abs(h-m)<.01&&Math.abs(v-f)<.01){if(Math.abs(u+d)<.1&&Math.abs(h+m)<.1&&Math.abs(v+f)<.1&&Math.abs(c+p+g-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const M=(c+1)/2,E=(p+1)/2,S=(g+1)/2,T=(u+d)/4,R=(h+m)/4,x=(v+f)/4;return M>E&&M>S?M<.01?(i=0,r=.707106781,s=.707106781):(i=Math.sqrt(M),r=T/i,s=R/i):E>S?E<.01?(i=.707106781,r=0,s=.707106781):(r=Math.sqrt(E),i=T/r,s=x/r):S<.01?(i=.707106781,r=.707106781,s=0):(s=Math.sqrt(S),i=R/s,r=x/s),this.set(i,r,s,t),this}let _=Math.sqrt((f-v)*(f-v)+(h-m)*(h-m)+(d-u)*(d-u));return Math.abs(_)<.001&&(_=1),this.x=(f-v)/_,this.y=(h-m)/_,this.z=(d-u)/_,this.w=Math.acos((c+p+g-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this.w=e.w+(t.w-e.w)*i,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,i){return i!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}_n.prototype.isVector4=!0;function db(){let n=null,e=!1,t=null,i=null;function r(s,o){t(s,o),i=n.requestAnimationFrame(r)}return{start:function(){e!==!0&&t!==null&&(i=n.requestAnimationFrame(r),e=!0)},stop:function(){n.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(s){t=s},setContext:function(s){n=s}}}function nB(n,e){const t=e.isWebGL2,i=new WeakMap;function r(c,u){const h=c.array,d=c.usage,p=n.createBuffer();n.bindBuffer(u,p),n.bufferData(u,h,d),c.onUploadCallback();let v;if(h instanceof Float32Array)v=n.FLOAT;else if(h instanceof Uint16Array)if(c.isFloat16BufferAttribute)if(t)v=n.HALF_FLOAT;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else v=n.UNSIGNED_SHORT;else if(h instanceof Int16Array)v=n.SHORT;else if(h instanceof Uint32Array)v=n.UNSIGNED_INT;else if(h instanceof Int32Array)v=n.INT;else if(h instanceof Int8Array)v=n.BYTE;else if(h instanceof Uint8Array)v=n.UNSIGNED_BYTE;else if(h instanceof Uint8ClampedArray)v=n.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+h);return{buffer:p,type:v,bytesPerElement:h.BYTES_PER_ELEMENT,version:c.version}}function s(c,u,h){const d=u.array,p=u.updateRange;n.bindBuffer(h,c),p.count===-1?n.bufferSubData(h,0,d):(t?n.bufferSubData(h,p.offset*d.BYTES_PER_ELEMENT,d,p.offset,p.count):n.bufferSubData(h,p.offset*d.BYTES_PER_ELEMENT,d.subarray(p.offset,p.offset+p.count)),p.count=-1)}function o(c){return c.isInterleavedBufferAttribute&&(c=c.data),i.get(c)}function a(c){c.isInterleavedBufferAttribute&&(c=c.data);const u=i.get(c);u&&(n.deleteBuffer(u.buffer),i.delete(c))}function l(c,u){if(c.isGLBufferAttribute){const d=i.get(c);(!d||d.version<c.version)&&i.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const h=i.get(c);h===void 0?i.set(c,r(c,u)):h.version<c.version&&(s(h.buffer,c,u),h.version=c.version)}return{get:o,remove:a,update:l}}class Dl{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[e]===void 0&&(i[e]=[]),i[e].indexOf(t)===-1&&i[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const i=this._listeners;return i[e]!==void 0&&i[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const r=this._listeners[e];if(r!==void 0){const s=r.indexOf(t);s!==-1&&r.splice(s,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const i=this._listeners[e.type];if(i!==void 0){e.target=this;const r=i.slice(0);for(let s=0,o=r.length;s<o;s++)r[s].call(this,e);e.target=null}}}function ho(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function cd(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}const um={[yr]:{[so]:ho},[so]:{[yr]:cd}},Ci={legacyMode:!0,get workingColorSpace(){return so},set workingColorSpace(n){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(n,e,t){if(this.legacyMode||e===t||!e||!t)return n;if(um[e]&&um[e][t]!==void 0){const i=um[e][t];return n.r=i(n.r),n.g=i(n.g),n.b=i(n.b),n}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(n,e){return this.convert(n,this.workingColorSpace,e)},toWorkingColorSpace:function(n,e){return this.convert(n,e,this.workingColorSpace)}},fb={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Vt={r:0,g:0,b:0},Ri={h:0,s:0,l:0},Lh={h:0,s:0,l:0};function hm(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}function Ph(n,e){return e.r=n.r,e.g=n.g,e.b=n.b,e}class ht{constructor(e,t,i){return t===void 0&&i===void 0?this.set(e):this.setRGB(e,t,i)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=yr){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Ci.toWorkingColorSpace(this,t),this}setRGB(e,t,i,r=so){return this.r=e,this.g=t,this.b=i,Ci.toWorkingColorSpace(this,r),this}setHSL(e,t,i,r=so){if(e=KO(e,1),t=Kn(t,0,1),i=Kn(i,0,1),t===0)this.r=this.g=this.b=i;else{const s=i<=.5?i*(1+t):i+t-i*t,o=2*i-s;this.r=hm(o,s,e+1/3),this.g=hm(o,s,e),this.b=hm(o,s,e-1/3)}return Ci.toWorkingColorSpace(this,r),this}setStyle(e,t=yr){function i(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let r;if(r=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let s;const o=r[1],a=r[2];switch(o){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(s[1],10))/255,this.g=Math.min(255,parseInt(s[2],10))/255,this.b=Math.min(255,parseInt(s[3],10))/255,Ci.toWorkingColorSpace(this,t),i(s[4]),this;if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(s[1],10))/100,this.g=Math.min(100,parseInt(s[2],10))/100,this.b=Math.min(100,parseInt(s[3],10))/100,Ci.toWorkingColorSpace(this,t),i(s[4]),this;break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){const l=parseFloat(s[1])/360,c=parseInt(s[2],10)/100,u=parseInt(s[3],10)/100;return i(s[4]),this.setHSL(l,c,u,t)}break}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(e)){const s=r[1],o=s.length;if(o===3)return this.r=parseInt(s.charAt(0)+s.charAt(0),16)/255,this.g=parseInt(s.charAt(1)+s.charAt(1),16)/255,this.b=parseInt(s.charAt(2)+s.charAt(2),16)/255,Ci.toWorkingColorSpace(this,t),this;if(o===6)return this.r=parseInt(s.charAt(0)+s.charAt(1),16)/255,this.g=parseInt(s.charAt(2)+s.charAt(3),16)/255,this.b=parseInt(s.charAt(4)+s.charAt(5),16)/255,Ci.toWorkingColorSpace(this,t),this}return e&&e.length>0?this.setColorName(e,t):this}setColorName(e,t=yr){const i=fb[e.toLowerCase()];return i!==void 0?this.setHex(i,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=ho(e.r),this.g=ho(e.g),this.b=ho(e.b),this}copyLinearToSRGB(e){return this.r=cd(e.r),this.g=cd(e.g),this.b=cd(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=yr){return Ci.fromWorkingColorSpace(Ph(this,Vt),e),Kn(Vt.r*255,0,255)<<16^Kn(Vt.g*255,0,255)<<8^Kn(Vt.b*255,0,255)<<0}getHexString(e=yr){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=so){Ci.fromWorkingColorSpace(Ph(this,Vt),t);const i=Vt.r,r=Vt.g,s=Vt.b,o=Math.max(i,r,s),a=Math.min(i,r,s);let l,c;const u=(a+o)/2;if(a===o)l=0,c=0;else{const h=o-a;switch(c=u<=.5?h/(o+a):h/(2-o-a),o){case i:l=(r-s)/h+(r<s?6:0);break;case r:l=(s-i)/h+2;break;case s:l=(i-r)/h+4;break}l/=6}return e.h=l,e.s=c,e.l=u,e}getRGB(e,t=so){return Ci.fromWorkingColorSpace(Ph(this,Vt),t),e.r=Vt.r,e.g=Vt.g,e.b=Vt.b,e}getStyle(e=yr){return Ci.fromWorkingColorSpace(Ph(this,Vt),e),e!==yr?`color(${e} ${Vt.r} ${Vt.g} ${Vt.b})`:`rgb(${Vt.r*255|0},${Vt.g*255|0},${Vt.b*255|0})`}offsetHSL(e,t,i){return this.getHSL(Ri),Ri.h+=e,Ri.s+=t,Ri.l+=i,this.setHSL(Ri.h,Ri.s,Ri.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,i){return this.r=e.r+(t.r-e.r)*i,this.g=e.g+(t.g-e.g)*i,this.b=e.b+(t.b-e.b)*i,this}lerpHSL(e,t){this.getHSL(Ri),e.getHSL(Lh);const i=rm(Ri.h,Lh.h,t),r=rm(Ri.s,Lh.s,t),s=rm(Ri.l,Lh.l,t);return this.setHSL(i,r,s),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}ht.NAMES=fb;ht.prototype.isColor=!0;ht.prototype.r=1;ht.prototype.g=1;ht.prototype.b=1;const Bt=new se,Dh=new mt;class pi{constructor(e,t,i){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=i===!0,this.usage=LM,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,i){e*=this.itemSize,i*=t.itemSize;for(let r=0,s=this.itemSize;r<s;r++)this.array[e+r]=t.array[i+r];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){const t=this.array;let i=0;for(let r=0,s=e.length;r<s;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),o=new ht),t[i++]=o.r,t[i++]=o.g,t[i++]=o.b}return this}copyVector2sArray(e){const t=this.array;let i=0;for(let r=0,s=e.length;r<s;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),o=new mt),t[i++]=o.x,t[i++]=o.y}return this}copyVector3sArray(e){const t=this.array;let i=0;for(let r=0,s=e.length;r<s;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),o=new se),t[i++]=o.x,t[i++]=o.y,t[i++]=o.z}return this}copyVector4sArray(e){const t=this.array;let i=0;for(let r=0,s=e.length;r<s;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),o=new _n),t[i++]=o.x,t[i++]=o.y,t[i++]=o.z,t[i++]=o.w}return this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,i=this.count;t<i;t++)Dh.fromBufferAttribute(this,t),Dh.applyMatrix3(e),this.setXY(t,Dh.x,Dh.y);else if(this.itemSize===3)for(let t=0,i=this.count;t<i;t++)Bt.fromBufferAttribute(this,t),Bt.applyMatrix3(e),this.setXYZ(t,Bt.x,Bt.y,Bt.z);return this}applyMatrix4(e){for(let t=0,i=this.count;t<i;t++)Bt.fromBufferAttribute(this,t),Bt.applyMatrix4(e),this.setXYZ(t,Bt.x,Bt.y,Bt.z);return this}applyNormalMatrix(e){for(let t=0,i=this.count;t<i;t++)Bt.fromBufferAttribute(this,t),Bt.applyNormalMatrix(e),this.setXYZ(t,Bt.x,Bt.y,Bt.z);return this}transformDirection(e){for(let t=0,i=this.count;t<i;t++)Bt.fromBufferAttribute(this,t),Bt.transformDirection(e),this.setXYZ(t,Bt.x,Bt.y,Bt.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=i,this}setXYZ(e,t,i,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=r,this}setXYZW(e,t,i,r,s){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=r,this.array[e+3]=s,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==LM&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}}pi.prototype.isBufferAttribute=!0;class pb extends pi{constructor(e,t,i){super(new Uint16Array(e),t,i)}}class mb extends pi{constructor(e,t,i){super(new Uint32Array(e),t,i)}}class iB extends pi{constructor(e,t,i){super(new Uint16Array(e),t,i)}}iB.prototype.isFloat16BufferAttribute=!0;class fo extends pi{constructor(e,t,i){super(new Float32Array(e),t,i)}}const UM=new ln,OM=new Ll;class Il{constructor(e=0,t=0,i=0,r=Il.DefaultOrder){this._x=e,this._y=t,this._z=i,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,i,r=this._order){return this._x=e,this._y=t,this._z=i,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,i=!0){const r=e.elements,s=r[0],o=r[4],a=r[8],l=r[1],c=r[5],u=r[9],h=r[2],d=r[6],p=r[10];switch(t){case"XYZ":this._y=Math.asin(Kn(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-o,s)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Kn(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,p),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-h,s),this._z=0);break;case"ZXY":this._x=Math.asin(Kn(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,p),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(l,s));break;case"ZYX":this._y=Math.asin(-Kn(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(l,s)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin(Kn(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,c),this._y=Math.atan2(-h,s)):(this._x=0,this._y=Math.atan2(a,p));break;case"XZY":this._z=Math.asin(-Kn(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(a,s)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,i===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,i){return UM.makeRotationFromQuaternion(e),this.setFromRotationMatrix(UM,t,i)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return OM.setFromEuler(this),this.setFromQuaternion(OM,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Il.prototype.isEuler=!0;Il.DefaultOrder="XYZ";Il.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class gb{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let rB=0;const BM=new se,sa=new Ll,fr=new ln,Ih=new se,rc=new se,sB=new se,oB=new Ll,zM=new se(1,0,0),kM=new se(0,1,0),HM=new se(0,0,1),aB={type:"added"},GM={type:"removed"};class Wi extends Dl{constructor(){super(),Object.defineProperty(this,"id",{value:rB++}),this.uuid=bu(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Wi.DefaultUp.clone();const e=new se,t=new Il,i=new Ll,r=new se(1,1,1);function s(){i.setFromEuler(t,!1)}function o(){t.setFromQuaternion(i,void 0,!1)}t._onChange(s),i._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new ln},normalMatrix:{value:new Oi}}),this.matrix=new ln,this.matrixWorld=new ln,this.matrixAutoUpdate=Wi.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new gb,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return sa.setFromAxisAngle(e,t),this.quaternion.multiply(sa),this}rotateOnWorldAxis(e,t){return sa.setFromAxisAngle(e,t),this.quaternion.premultiply(sa),this}rotateX(e){return this.rotateOnAxis(zM,e)}rotateY(e){return this.rotateOnAxis(kM,e)}rotateZ(e){return this.rotateOnAxis(HM,e)}translateOnAxis(e,t){return BM.copy(e).applyQuaternion(this.quaternion),this.position.add(BM.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(zM,e)}translateY(e){return this.translateOnAxis(kM,e)}translateZ(e){return this.translateOnAxis(HM,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(fr.copy(this.matrixWorld).invert())}lookAt(e,t,i){e.isVector3?Ih.copy(e):Ih.set(e,t,i);const r=this.parent;this.updateWorldMatrix(!0,!1),rc.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?fr.lookAt(rc,Ih,this.up):fr.lookAt(Ih,rc,this.up),this.quaternion.setFromRotationMatrix(fr),r&&(fr.extractRotation(r.matrixWorld),sa.setFromRotationMatrix(fr),this.quaternion.premultiply(sa.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(aB)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(GM)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(GM)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),fr.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),fr.multiply(e.parent.matrixWorld)),e.applyMatrix4(fr),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let i=0,r=this.children.length;i<r;i++){const o=this.children[i].getObjectByProperty(e,t);if(o!==void 0)return o}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(rc,e,sB),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(rc,oB,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].updateMatrixWorld(e)}updateWorldMatrix(e,t){const i=this.parent;if(e===!0&&i!==null&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const r=this.children;for(let s=0,o=r.length;s<o;s++)r[s].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",i={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(r.instanceColor=this.instanceColor.toJSON()));function s(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&(r.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=s(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let c=0,u=l.length;c<u;c++){const h=l[c];s(e.shapes,h)}else s(e.shapes,l)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(e.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,c=this.material.length;l<c;l++)a.push(s(e.materials,this.material[l]));r.material=a}else r.material=s(e.materials,this.material);if(this.children.length>0){r.children=[];for(let a=0;a<this.children.length;a++)r.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];r.animations.push(s(e.animations,l))}}if(t){const a=o(e.geometries),l=o(e.materials),c=o(e.textures),u=o(e.images),h=o(e.shapes),d=o(e.skeletons),p=o(e.animations),v=o(e.nodes);a.length>0&&(i.geometries=a),l.length>0&&(i.materials=l),c.length>0&&(i.textures=c),u.length>0&&(i.images=u),h.length>0&&(i.shapes=h),d.length>0&&(i.skeletons=d),p.length>0&&(i.animations=p),v.length>0&&(i.nodes=v)}return i.object=r,i;function o(a){const l=[];for(const c in a){const u=a[c];delete u.metadata,l.push(u)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let i=0;i<e.children.length;i++){const r=e.children[i];this.add(r.clone())}return this}}Wi.DefaultUp=new se(0,1,0);Wi.DefaultMatrixAutoUpdate=!0;Wi.prototype.isObject3D=!0;function vb(n){for(let e=n.length-1;e>=0;--e)if(n[e]>65535)return!0;return!1}function Hd(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}let lB=0;const si=new ln,dm=new Wi,oa=new se,qn=new Pl,sc=new Pl,qt=new se;class Us extends Dl{constructor(){super(),Object.defineProperty(this,"id",{value:lB++}),this.uuid=bu(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(vb(e)?mb:pb)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,i=0){this.groups.push({start:e,count:t,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const i=this.attributes.normal;if(i!==void 0){const s=new Oi().getNormalMatrix(e);i.applyNormalMatrix(s),i.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(e),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return si.makeRotationFromQuaternion(e),this.applyMatrix4(si),this}rotateX(e){return si.makeRotationX(e),this.applyMatrix4(si),this}rotateY(e){return si.makeRotationY(e),this.applyMatrix4(si),this}rotateZ(e){return si.makeRotationZ(e),this.applyMatrix4(si),this}translate(e,t,i){return si.makeTranslation(e,t,i),this.applyMatrix4(si),this}scale(e,t,i){return si.makeScale(e,t,i),this.applyMatrix4(si),this}lookAt(e){return dm.lookAt(e),dm.updateMatrix(),this.applyMatrix4(dm.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(oa).negate(),this.translate(oa.x,oa.y,oa.z),this}setFromPoints(e){const t=[];for(let i=0,r=e.length;i<r;i++){const s=e[i];t.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new fo(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Pl);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new se(-1/0,-1/0,-1/0),new se(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let i=0,r=t.length;i<r;i++){const s=t[i];qn.setFromBufferAttribute(s),this.morphTargetsRelative?(qt.addVectors(this.boundingBox.min,qn.min),this.boundingBox.expandByPoint(qt),qt.addVectors(this.boundingBox.max,qn.max),this.boundingBox.expandByPoint(qt)):(this.boundingBox.expandByPoint(qn.min),this.boundingBox.expandByPoint(qn.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Fv);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new se,1/0);return}if(e){const i=this.boundingSphere.center;if(qn.setFromBufferAttribute(e),t)for(let s=0,o=t.length;s<o;s++){const a=t[s];sc.setFromBufferAttribute(a),this.morphTargetsRelative?(qt.addVectors(qn.min,sc.min),qn.expandByPoint(qt),qt.addVectors(qn.max,sc.max),qn.expandByPoint(qt)):(qn.expandByPoint(sc.min),qn.expandByPoint(sc.max))}qn.getCenter(i);let r=0;for(let s=0,o=e.count;s<o;s++)qt.fromBufferAttribute(e,s),r=Math.max(r,i.distanceToSquared(qt));if(t)for(let s=0,o=t.length;s<o;s++){const a=t[s],l=this.morphTargetsRelative;for(let c=0,u=a.count;c<u;c++)qt.fromBufferAttribute(a,c),l&&(oa.fromBufferAttribute(e,c),qt.add(oa)),r=Math.max(r,i.distanceToSquared(qt))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const i=e.array,r=t.position.array,s=t.normal.array,o=t.uv.array,a=r.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new pi(new Float32Array(4*a),4));const l=this.getAttribute("tangent").array,c=[],u=[];for(let I=0;I<a;I++)c[I]=new se,u[I]=new se;const h=new se,d=new se,p=new se,v=new mt,m=new mt,f=new mt,g=new se,_=new se;function M(I,N,J){h.fromArray(r,I*3),d.fromArray(r,N*3),p.fromArray(r,J*3),v.fromArray(o,I*2),m.fromArray(o,N*2),f.fromArray(o,J*2),d.sub(h),p.sub(h),m.sub(v),f.sub(v);const q=1/(m.x*f.y-f.x*m.y);!isFinite(q)||(g.copy(d).multiplyScalar(f.y).addScaledVector(p,-m.y).multiplyScalar(q),_.copy(p).multiplyScalar(m.x).addScaledVector(d,-f.x).multiplyScalar(q),c[I].add(g),c[N].add(g),c[J].add(g),u[I].add(_),u[N].add(_),u[J].add(_))}let E=this.groups;E.length===0&&(E=[{start:0,count:i.length}]);for(let I=0,N=E.length;I<N;++I){const J=E[I],q=J.start,L=J.count;for(let $=q,z=q+L;$<z;$+=3)M(i[$+0],i[$+1],i[$+2])}const S=new se,T=new se,R=new se,x=new se;function A(I){R.fromArray(s,I*3),x.copy(R);const N=c[I];S.copy(N),S.sub(R.multiplyScalar(R.dot(N))).normalize(),T.crossVectors(x,N);const q=T.dot(u[I])<0?-1:1;l[I*4]=S.x,l[I*4+1]=S.y,l[I*4+2]=S.z,l[I*4+3]=q}for(let I=0,N=E.length;I<N;++I){const J=E[I],q=J.start,L=J.count;for(let $=q,z=q+L;$<z;$+=3)A(i[$+0]),A(i[$+1]),A(i[$+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let i=this.getAttribute("normal");if(i===void 0)i=new pi(new Float32Array(t.count*3),3),this.setAttribute("normal",i);else for(let d=0,p=i.count;d<p;d++)i.setXYZ(d,0,0,0);const r=new se,s=new se,o=new se,a=new se,l=new se,c=new se,u=new se,h=new se;if(e)for(let d=0,p=e.count;d<p;d+=3){const v=e.getX(d+0),m=e.getX(d+1),f=e.getX(d+2);r.fromBufferAttribute(t,v),s.fromBufferAttribute(t,m),o.fromBufferAttribute(t,f),u.subVectors(o,s),h.subVectors(r,s),u.cross(h),a.fromBufferAttribute(i,v),l.fromBufferAttribute(i,m),c.fromBufferAttribute(i,f),a.add(u),l.add(u),c.add(u),i.setXYZ(v,a.x,a.y,a.z),i.setXYZ(m,l.x,l.y,l.z),i.setXYZ(f,c.x,c.y,c.z)}else for(let d=0,p=t.count;d<p;d+=3)r.fromBufferAttribute(t,d+0),s.fromBufferAttribute(t,d+1),o.fromBufferAttribute(t,d+2),u.subVectors(o,s),h.subVectors(r,s),u.cross(h),i.setXYZ(d+0,u.x,u.y,u.z),i.setXYZ(d+1,u.x,u.y,u.z),i.setXYZ(d+2,u.x,u.y,u.z);this.normalizeNormals(),i.needsUpdate=!0}}merge(e,t){if(!(e&&e.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);return}t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const i=this.attributes;for(const r in i){if(e.attributes[r]===void 0)continue;const o=i[r].array,a=e.attributes[r],l=a.array,c=a.itemSize*t,u=Math.min(l.length,o.length-c);for(let h=0,d=c;h<u;h++,d++)o[d]=l[h]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,i=e.count;t<i;t++)qt.fromBufferAttribute(e,t),qt.normalize(),e.setXYZ(t,qt.x,qt.y,qt.z)}toNonIndexed(){function e(a,l){const c=a.array,u=a.itemSize,h=a.normalized,d=new c.constructor(l.length*u);let p=0,v=0;for(let m=0,f=l.length;m<f;m++){a.isInterleavedBufferAttribute?p=l[m]*a.data.stride+a.offset:p=l[m]*u;for(let g=0;g<u;g++)d[v++]=c[p++]}return new pi(d,u,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Us,i=this.index.array,r=this.attributes;for(const a in r){const l=r[a],c=e(l,i);t.setAttribute(a,c)}const s=this.morphAttributes;for(const a in s){const l=[],c=s[a];for(let u=0,h=c.length;u<h;u++){const d=c[u],p=e(d,i);l.push(p)}t.morphAttributes[a]=l}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const c=o[a];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const i=this.attributes;for(const l in i){const c=i[l];e.data.attributes[l]=c.toJSON(e.data)}const r={};let s=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],u=[];for(let h=0,d=c.length;h<d;h++){const p=c[h];u.push(p.toJSON(e.data))}u.length>0&&(r[l]=u,s=!0)}s&&(e.data.morphAttributes=r,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const i=e.index;i!==null&&this.setIndex(i.clone(t));const r=e.attributes;for(const c in r){const u=r[c];this.setAttribute(c,u.clone(t))}const s=e.morphAttributes;for(const c in s){const u=[],h=s[c];for(let d=0,p=h.length;d<p;d++)u.push(h[d].clone(t));this.morphAttributes[c]=u}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let c=0,u=o.length;c<u;c++){const h=o[c];this.addGroup(h.start,h.count,h.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,e.parameters!==void 0&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}Us.prototype.isBufferGeometry=!0;class Tu extends Us{constructor(e=1,t=1,i=1,r=1,s=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:i,widthSegments:r,heightSegments:s,depthSegments:o};const a=this;r=Math.floor(r),s=Math.floor(s),o=Math.floor(o);const l=[],c=[],u=[],h=[];let d=0,p=0;v("z","y","x",-1,-1,i,t,e,o,s,0),v("z","y","x",1,-1,i,t,-e,o,s,1),v("x","z","y",1,1,e,i,t,r,o,2),v("x","z","y",1,-1,e,i,-t,r,o,3),v("x","y","z",1,-1,e,t,i,r,s,4),v("x","y","z",-1,-1,e,t,-i,r,s,5),this.setIndex(l),this.setAttribute("position",new fo(c,3)),this.setAttribute("normal",new fo(u,3)),this.setAttribute("uv",new fo(h,2));function v(m,f,g,_,M,E,S,T,R,x,A){const I=E/R,N=S/x,J=E/2,q=S/2,L=T/2,$=R+1,z=x+1;let W=0,U=0;const P=new se;for(let k=0;k<z;k++){const Y=k*N-q;for(let j=0;j<$;j++){const K=j*I-J;P[m]=K*_,P[f]=Y*M,P[g]=L,c.push(P.x,P.y,P.z),P[m]=0,P[f]=0,P[g]=T>0?1:-1,u.push(P.x,P.y,P.z),h.push(j/R),h.push(1-k/x),W+=1}}for(let k=0;k<x;k++)for(let Y=0;Y<R;Y++){const j=d+Y+$*k,K=d+Y+$*(k+1),ce=d+(Y+1)+$*(k+1),de=d+(Y+1)+$*k;l.push(j,K,de),l.push(K,ce,de),U+=6}a.addGroup(p,U,A),p+=U,d+=W}}static fromJSON(e){return new Tu(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}class Uv extends Us{constructor(e=1,t=1,i=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:i,heightSegments:r};const s=e/2,o=t/2,a=Math.floor(i),l=Math.floor(r),c=a+1,u=l+1,h=e/a,d=t/l,p=[],v=[],m=[],f=[];for(let g=0;g<u;g++){const _=g*d-o;for(let M=0;M<c;M++){const E=M*h-s;v.push(E,-_,0),m.push(0,0,1),f.push(M/a),f.push(1-g/l)}}for(let g=0;g<l;g++)for(let _=0;_<a;_++){const M=_+c*g,E=_+c*(g+1),S=_+1+c*(g+1),T=_+1+c*g;p.push(M,E,T),p.push(E,S,T)}this.setIndex(p),this.setAttribute("position",new fo(v,3)),this.setAttribute("normal",new fo(m,3)),this.setAttribute("uv",new fo(f,2))}static fromJSON(e){return new Uv(e.width,e.height,e.widthSegments,e.heightSegments)}}let cB=0;class Nl extends Dl{constructor(){super(),Object.defineProperty(this,"id",{value:cB++}),this.uuid=bu(),this.name="",this.type="Material",this.blending=Va,this.side=uu,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=ab,this.blendDst=lb,this.blendEquation=ga,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Kg,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=YO,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=nm,this.stencilZFail=nm,this.stencilZPass=nm,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const i=e[t];if(i===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=i===nO;continue}const r=this[t];if(r===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}r&&r.isColor?r.set(i):r&&r.isVector3&&i&&i.isVector3?r.copy(i):this[t]=i}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const i={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),this.roughness!==void 0&&(i.roughness=this.roughness),this.metalness!==void 0&&(i.metalness=this.metalness),this.sheen!==void 0&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(i.shininess=this.shininess),this.clearcoat!==void 0&&(i.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(e).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(e).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(e).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(e).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(e).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(i.combine=this.combine)),this.envMapIntensity!==void 0&&(i.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(i.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&(i.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(i.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(i.size=this.size),this.shadowSide!==null&&(i.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==Va&&(i.blending=this.blending),this.side!==uu&&(i.side=this.side),this.vertexColors&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),this.transparent===!0&&(i.transparent=this.transparent),i.depthFunc=this.depthFunc,i.depthTest=this.depthTest,i.depthWrite=this.depthWrite,i.colorWrite=this.colorWrite,i.stencilWrite=this.stencilWrite,i.stencilWriteMask=this.stencilWriteMask,i.stencilFunc=this.stencilFunc,i.stencilRef=this.stencilRef,i.stencilFuncMask=this.stencilFuncMask,i.stencilFail=this.stencilFail,i.stencilZFail=this.stencilZFail,i.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(i.rotation=this.rotation),this.polygonOffset===!0&&(i.polygonOffset=!0),this.polygonOffsetFactor!==0&&(i.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(i.linewidth=this.linewidth),this.dashSize!==void 0&&(i.dashSize=this.dashSize),this.gapSize!==void 0&&(i.gapSize=this.gapSize),this.scale!==void 0&&(i.scale=this.scale),this.dithering===!0&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(i.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(i.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(i.wireframe=this.wireframe),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(i.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(i.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(i.flatShading=this.flatShading),this.visible===!1&&(i.visible=!1),this.toneMapped===!1&&(i.toneMapped=!1),this.fog===!1&&(i.fog=!1),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData);function r(s){const o=[];for(const a in s){const l=s[a];delete l.metadata,o.push(l)}return o}if(t){const s=r(e.textures),o=r(e.images);s.length>0&&(i.textures=s),o.length>0&&(i.images=o)}return i}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let i=null;if(t!==null){const r=t.length;i=new Array(r);for(let s=0;s!==r;++s)i[s]=t[s].clone()}return this.clippingPlanes=i,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}Nl.prototype.isMaterial=!0;Nl.fromType=function(){return null};function gl(n){const e={};for(const t in n){e[t]={};for(const i in n[t]){const r=n[t][i];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?e[t][i]=r.clone():Array.isArray(r)?e[t][i]=r.slice():e[t][i]=r}}return e}function pn(n){const e={};for(let t=0;t<n.length;t++){const i=gl(n[t]);for(const r in i)e[r]=i[r]}return e}const uB={clone:gl,merge:pn};var hB=`
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`,dB=`
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`;class Rs extends Nl{constructor(e){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=hB,this.fragmentShader=dB,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=gl(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const r in this.uniforms){const o=this.uniforms[r].value;o&&o.isTexture?t.uniforms[r]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[r]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[r]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[r]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[r]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[r]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[r]={type:"m4",value:o.toArray()}:t.uniforms[r]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const i={};for(const r in this.extensions)this.extensions[r]===!0&&(i[r]=!0);return Object.keys(i).length>0&&(t.extensions=i),t}}Rs.prototype.isShaderMaterial=!0;const pr=new se,fm=new se,Nh=new se,Zr=new se,pm=new se,Fh=new se,mm=new se;class fB{constructor(e=new se,t=new se(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,pr)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const i=t.dot(this.direction);return i<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(i).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=pr.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(pr.copy(this.direction).multiplyScalar(t).add(this.origin),pr.distanceToSquared(e))}distanceSqToSegment(e,t,i,r){fm.copy(e).add(t).multiplyScalar(.5),Nh.copy(t).sub(e).normalize(),Zr.copy(this.origin).sub(fm);const s=e.distanceTo(t)*.5,o=-this.direction.dot(Nh),a=Zr.dot(this.direction),l=-Zr.dot(Nh),c=Zr.lengthSq(),u=Math.abs(1-o*o);let h,d,p,v;if(u>0)if(h=o*l-a,d=o*a-l,v=s*u,h>=0)if(d>=-v)if(d<=v){const m=1/u;h*=m,d*=m,p=h*(h+o*d+2*a)+d*(o*h+d+2*l)+c}else d=s,h=Math.max(0,-(o*d+a)),p=-h*h+d*(d+2*l)+c;else d=-s,h=Math.max(0,-(o*d+a)),p=-h*h+d*(d+2*l)+c;else d<=-v?(h=Math.max(0,-(-o*s+a)),d=h>0?-s:Math.min(Math.max(-s,-l),s),p=-h*h+d*(d+2*l)+c):d<=v?(h=0,d=Math.min(Math.max(-s,-l),s),p=d*(d+2*l)+c):(h=Math.max(0,-(o*s+a)),d=h>0?s:Math.min(Math.max(-s,-l),s),p=-h*h+d*(d+2*l)+c);else d=o>0?-s:s,h=Math.max(0,-(o*d+a)),p=-h*h+d*(d+2*l)+c;return i&&i.copy(this.direction).multiplyScalar(h).add(this.origin),r&&r.copy(Nh).multiplyScalar(d).add(fm),p}intersectSphere(e,t){pr.subVectors(e.center,this.origin);const i=pr.dot(this.direction),r=pr.dot(pr)-i*i,s=e.radius*e.radius;if(r>s)return null;const o=Math.sqrt(s-r),a=i-o,l=i+o;return a<0&&l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(e.normal)+e.constant)/t;return i>=0?i:null}intersectPlane(e,t){const i=this.distanceToPlane(e);return i===null?null:this.at(i,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let i,r,s,o,a,l;const c=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,d=this.origin;return c>=0?(i=(e.min.x-d.x)*c,r=(e.max.x-d.x)*c):(i=(e.max.x-d.x)*c,r=(e.min.x-d.x)*c),u>=0?(s=(e.min.y-d.y)*u,o=(e.max.y-d.y)*u):(s=(e.max.y-d.y)*u,o=(e.min.y-d.y)*u),i>o||s>r||((s>i||i!==i)&&(i=s),(o<r||r!==r)&&(r=o),h>=0?(a=(e.min.z-d.z)*h,l=(e.max.z-d.z)*h):(a=(e.max.z-d.z)*h,l=(e.min.z-d.z)*h),i>l||a>r)||((a>i||i!==i)&&(i=a),(l<r||r!==r)&&(r=l),r<0)?null:this.at(i>=0?i:r,t)}intersectsBox(e){return this.intersectBox(e,pr)!==null}intersectTriangle(e,t,i,r,s){pm.subVectors(t,e),Fh.subVectors(i,e),mm.crossVectors(pm,Fh);let o=this.direction.dot(mm),a;if(o>0){if(r)return null;a=1}else if(o<0)a=-1,o=-o;else return null;Zr.subVectors(this.origin,e);const l=a*this.direction.dot(Fh.crossVectors(Zr,Fh));if(l<0)return null;const c=a*this.direction.dot(pm.cross(Zr));if(c<0||l+c>o)return null;const u=-a*Zr.dot(mm);return u<0?null:this.at(u/o,s)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}const Li=new se,mr=new se,gm=new se,gr=new se,aa=new se,la=new se,VM=new se,vm=new se,_m=new se,xm=new se;class wr{constructor(e=new se,t=new se,i=new se){this.a=e,this.b=t,this.c=i}static getNormal(e,t,i,r){r.subVectors(i,t),Li.subVectors(e,t),r.cross(Li);const s=r.lengthSq();return s>0?r.multiplyScalar(1/Math.sqrt(s)):r.set(0,0,0)}static getBarycoord(e,t,i,r,s){Li.subVectors(r,t),mr.subVectors(i,t),gm.subVectors(e,t);const o=Li.dot(Li),a=Li.dot(mr),l=Li.dot(gm),c=mr.dot(mr),u=mr.dot(gm),h=o*c-a*a;if(h===0)return s.set(-2,-1,-1);const d=1/h,p=(c*l-a*u)*d,v=(o*u-a*l)*d;return s.set(1-p-v,v,p)}static containsPoint(e,t,i,r){return this.getBarycoord(e,t,i,r,gr),gr.x>=0&&gr.y>=0&&gr.x+gr.y<=1}static getUV(e,t,i,r,s,o,a,l){return this.getBarycoord(e,t,i,r,gr),l.set(0,0),l.addScaledVector(s,gr.x),l.addScaledVector(o,gr.y),l.addScaledVector(a,gr.z),l}static isFrontFacing(e,t,i,r){return Li.subVectors(i,t),mr.subVectors(e,t),Li.cross(mr).dot(r)<0}set(e,t,i){return this.a.copy(e),this.b.copy(t),this.c.copy(i),this}setFromPointsAndIndices(e,t,i,r){return this.a.copy(e[t]),this.b.copy(e[i]),this.c.copy(e[r]),this}setFromAttributeAndIndices(e,t,i,r){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,i),this.c.fromBufferAttribute(e,r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Li.subVectors(this.c,this.b),mr.subVectors(this.a,this.b),Li.cross(mr).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return wr.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return wr.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,i,r,s){return wr.getUV(e,this.a,this.b,this.c,t,i,r,s)}containsPoint(e){return wr.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return wr.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const i=this.a,r=this.b,s=this.c;let o,a;aa.subVectors(r,i),la.subVectors(s,i),vm.subVectors(e,i);const l=aa.dot(vm),c=la.dot(vm);if(l<=0&&c<=0)return t.copy(i);_m.subVectors(e,r);const u=aa.dot(_m),h=la.dot(_m);if(u>=0&&h<=u)return t.copy(r);const d=l*h-u*c;if(d<=0&&l>=0&&u<=0)return o=l/(l-u),t.copy(i).addScaledVector(aa,o);xm.subVectors(e,s);const p=aa.dot(xm),v=la.dot(xm);if(v>=0&&p<=v)return t.copy(s);const m=p*c-l*v;if(m<=0&&c>=0&&v<=0)return a=c/(c-v),t.copy(i).addScaledVector(la,a);const f=u*v-p*h;if(f<=0&&h-u>=0&&p-v>=0)return VM.subVectors(s,r),a=(h-u)/(h-u+(p-v)),t.copy(r).addScaledVector(VM,a);const g=1/(f+m+d);return o=m*g,a=d*g,t.copy(i).addScaledVector(aa,o).addScaledVector(la,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}class Ov extends Nl{constructor(e){super(),this.type="MeshBasicMaterial",this.color=new ht(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=cb,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}Ov.prototype.isMeshBasicMaterial=!0;const WM=new ln,ca=new fB,ym=new Fv,Jr=new se,Qr=new se,es=new se,Mm=new se,Sm=new se,wm=new se,Uh=new se,Oh=new se,Bh=new se,zh=new mt,kh=new mt,Hh=new mt,Em=new se,Gh=new se;class Tr extends Wi{constructor(e=new Us,t=new Ov){super(),this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,i=Object.keys(t);if(i.length>0){const r=t[i[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=r.length;s<o;s++){const a=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(e,t){const i=this.geometry,r=this.material,s=this.matrixWorld;if(r===void 0||(i.boundingSphere===null&&i.computeBoundingSphere(),ym.copy(i.boundingSphere),ym.applyMatrix4(s),e.ray.intersectsSphere(ym)===!1)||(WM.copy(s).invert(),ca.copy(e.ray).applyMatrix4(WM),i.boundingBox!==null&&ca.intersectsBox(i.boundingBox)===!1))return;let o;if(i.isBufferGeometry){const a=i.index,l=i.attributes.position,c=i.morphAttributes.position,u=i.morphTargetsRelative,h=i.attributes.uv,d=i.attributes.uv2,p=i.groups,v=i.drawRange;if(a!==null)if(Array.isArray(r))for(let m=0,f=p.length;m<f;m++){const g=p[m],_=r[g.materialIndex],M=Math.max(g.start,v.start),E=Math.min(a.count,Math.min(g.start+g.count,v.start+v.count));for(let S=M,T=E;S<T;S+=3){const R=a.getX(S),x=a.getX(S+1),A=a.getX(S+2);o=Vh(this,_,e,ca,l,c,u,h,d,R,x,A),o&&(o.faceIndex=Math.floor(S/3),o.face.materialIndex=g.materialIndex,t.push(o))}}else{const m=Math.max(0,v.start),f=Math.min(a.count,v.start+v.count);for(let g=m,_=f;g<_;g+=3){const M=a.getX(g),E=a.getX(g+1),S=a.getX(g+2);o=Vh(this,r,e,ca,l,c,u,h,d,M,E,S),o&&(o.faceIndex=Math.floor(g/3),t.push(o))}}else if(l!==void 0)if(Array.isArray(r))for(let m=0,f=p.length;m<f;m++){const g=p[m],_=r[g.materialIndex],M=Math.max(g.start,v.start),E=Math.min(l.count,Math.min(g.start+g.count,v.start+v.count));for(let S=M,T=E;S<T;S+=3){const R=S,x=S+1,A=S+2;o=Vh(this,_,e,ca,l,c,u,h,d,R,x,A),o&&(o.faceIndex=Math.floor(S/3),o.face.materialIndex=g.materialIndex,t.push(o))}}else{const m=Math.max(0,v.start),f=Math.min(l.count,v.start+v.count);for(let g=m,_=f;g<_;g+=3){const M=g,E=g+1,S=g+2;o=Vh(this,r,e,ca,l,c,u,h,d,M,E,S),o&&(o.faceIndex=Math.floor(g/3),t.push(o))}}}else i.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}Tr.prototype.isMesh=!0;function pB(n,e,t,i,r,s,o,a){let l;if(e.side===Hi?l=i.intersectTriangle(o,s,r,!0,a):l=i.intersectTriangle(r,s,o,e.side!==dl,a),l===null)return null;Gh.copy(a),Gh.applyMatrix4(n.matrixWorld);const c=t.ray.origin.distanceTo(Gh);return c<t.near||c>t.far?null:{distance:c,point:Gh.clone(),object:n}}function Vh(n,e,t,i,r,s,o,a,l,c,u,h){Jr.fromBufferAttribute(r,c),Qr.fromBufferAttribute(r,u),es.fromBufferAttribute(r,h);const d=n.morphTargetInfluences;if(s&&d){Uh.set(0,0,0),Oh.set(0,0,0),Bh.set(0,0,0);for(let v=0,m=s.length;v<m;v++){const f=d[v],g=s[v];f!==0&&(Mm.fromBufferAttribute(g,c),Sm.fromBufferAttribute(g,u),wm.fromBufferAttribute(g,h),o?(Uh.addScaledVector(Mm,f),Oh.addScaledVector(Sm,f),Bh.addScaledVector(wm,f)):(Uh.addScaledVector(Mm.sub(Jr),f),Oh.addScaledVector(Sm.sub(Qr),f),Bh.addScaledVector(wm.sub(es),f)))}Jr.add(Uh),Qr.add(Oh),es.add(Bh)}n.isSkinnedMesh&&(n.boneTransform(c,Jr),n.boneTransform(u,Qr),n.boneTransform(h,es));const p=pB(n,e,t,i,Jr,Qr,es,Em);if(p){a&&(zh.fromBufferAttribute(a,c),kh.fromBufferAttribute(a,u),Hh.fromBufferAttribute(a,h),p.uv=wr.getUV(Em,Jr,Qr,es,zh,kh,Hh,new mt)),l&&(zh.fromBufferAttribute(l,c),kh.fromBufferAttribute(l,u),Hh.fromBufferAttribute(l,h),p.uv2=wr.getUV(Em,Jr,Qr,es,zh,kh,Hh,new mt));const v={a:c,b:u,c:h,normal:new se,materialIndex:0};wr.getNormal(Jr,Qr,es,v.normal),p.face=v}return p}var mB=`
#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, vUv ).g;

#endif
`,gB=`
#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`,vB=`
#ifdef USE_ALPHATEST

	if ( diffuseColor.a < alphaTest ) discard;

#endif
`,_B=`
#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif
`,xB=`
#ifdef USE_AOMAP

	// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;

	reflectedLight.indirectDiffuse *= ambientOcclusion;

	#if defined( USE_ENVMAP ) && defined( STANDARD )

		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );

	#endif

#endif
`,yB=`
#ifdef USE_AOMAP

	uniform sampler2D aoMap;
	uniform float aoMapIntensity;

#endif
`,MB=`
vec3 transformed = vec3( position );
`,SB=`
vec3 objectNormal = vec3( normal );

#ifdef USE_TANGENT

	vec3 objectTangent = vec3( tangent.xyz );

#endif
`,wB=`

vec3 BRDF_Lambert( const in vec3 diffuseColor ) {

	return RECIPROCAL_PI * diffuseColor;

} // validated

vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotVH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );

	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );

} // validated

// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {

	float a2 = pow2( alpha );

	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );

	return 0.5 / max( gv + gl, EPSILON );

}

// Microfacet Models for Refraction through Rough Surfaces - equation (33)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disney\u2019s reparameterization
float D_GGX( const in float alpha, const in float dotNH ) {

	float a2 = pow2( alpha );

	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1

	return RECIPROCAL_PI * a2 / pow2( denom );

}

// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {

	float alpha = pow2( roughness ); // UE4's roughness

	vec3 halfDir = normalize( lightDir + viewDir );

	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );

	vec3 F = F_Schlick( f0, f90, dotVH );

	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );

	float D = D_GGX( alpha, dotNH );

	return F * ( V * D );

}

// Rect Area Light

// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	float dotNV = saturate( dot( N, V ) );

	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );

	uv = uv * LUT_SCALE + LUT_BIAS;

	return uv;

}

float LTC_ClippedSphereFormFactor( const in vec3 f ) {

	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
	// An approximation of the form factor of a horizon-clipped rectangle.

	float l = length( f );

	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );

}

vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {

	float x = dot( v1, v2 );

	float y = abs( x );

	// rational polynomial approximation to theta / sin( theta ) / 2PI
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;

	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;

	return cross( v1, v2 ) * theta_sintheta;

}

vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {

	// bail if point is on back side of plane of light
	// assumes ccw winding order of light vertices
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );

	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );

	// construct orthonormal basis around N
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system

	// compute transform
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );

	// transform rect
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );

	// project rect onto sphere
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );

	// calculate vector form factor
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );

	// adjust for horizon clipping
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );

/*
	// alternate method of adjusting for horizon clipping (see referece)
	// refactoring required
	float len = length( vectorFormFactor );
	float z = vectorFormFactor.z / len;

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	// tabulated horizon-clipped sphere, apparently...
	vec2 uv = vec2( z * 0.5 + 0.5, len );
	uv = uv * LUT_SCALE + LUT_BIAS;

	float scale = texture2D( ltc_2, uv ).w;

	float result = len * scale;
*/

	return vec3( result );

}

// End Rect Area Light


float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {

	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)
	return 0.25;

}

float D_BlinnPhong( const in float shininess, const in float dotNH ) {

	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {

	vec3 halfDir = normalize( lightDir + viewDir );

	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );

	vec3 F = F_Schlick( specularColor, 1.0, dotVH );

	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

	float D = D_BlinnPhong( shininess, dotNH );

	return F * ( G * D );

} // validated

#if defined( USE_SHEEN )

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
float D_Charlie( float roughness, float dotNH ) {

	float alpha = pow2( roughness );

	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16

	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );

}

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
float V_Neubelt( float dotNV, float dotNL ) {

	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );

}

vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {

	vec3 halfDir = normalize( lightDir + viewDir );

	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );

	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );

	return sheenColor * ( D * V );

}

#endif
`,EB=`
#ifdef USE_BUMPMAP

	uniform sampler2D bumpMap;
	uniform float bumpScale;

	// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
	// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf

	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

	vec2 dHdxy_fwd() {

		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );

		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;

		return vec2( dBx, dBy );

	}

	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;		// normalized

		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );

		float fDet = dot( vSigmaX, R1 ) * faceDirection;

		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );

	}

#endif
`,bB=`
#if NUM_CLIPPING_PLANES > 0

	vec4 plane;

	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {

		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;

	}
	#pragma unroll_loop_end

	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES

		bool clipped = true;

		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {

			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;

		}
		#pragma unroll_loop_end

		if ( clipped ) discard;

	#endif

#endif
`,TB=`
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];

#endif
`,AB=`
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

#endif
`,CB=`
#if NUM_CLIPPING_PLANES > 0

	vClipPosition = - mvPosition.xyz;

#endif
`,RB=`
#if defined( USE_COLOR_ALPHA )

	diffuseColor *= vColor;

#elif defined( USE_COLOR )

	diffuseColor.rgb *= vColor;

#endif
`,LB=`
#if defined( USE_COLOR_ALPHA )

	varying vec4 vColor;

#elif defined( USE_COLOR )

	varying vec3 vColor;

#endif
`,PB=`
#if defined( USE_COLOR_ALPHA )

	varying vec4 vColor;

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )

	varying vec3 vColor;

#endif
`,DB=`
#if defined( USE_COLOR_ALPHA )

	vColor = vec4( 1.0 );

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )

	vColor = vec3( 1.0 );

#endif

#ifdef USE_COLOR

	vColor *= color;

#endif

#ifdef USE_INSTANCING_COLOR

	vColor.xyz *= instanceColor.xyz;

#endif
`,IB=`
#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6

#ifndef saturate
// <tonemapping_pars_fragment> may have defined saturate() already
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )

float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }

// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.
// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand( const in vec2 uv ) {

	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );

	return fract( sin( sn ) * c );

}

#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif

struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};

struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};

struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};

vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

}

vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {

	// dir can be either a direction vector or a normal vector
	// upper-left 3x3 of matrix is assumed to be orthogonal

	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );

}

mat3 transposeMat3( const in mat3 m ) {

	mat3 tmp;

	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );

	return tmp;

}

// https://en.wikipedia.org/wiki/Relative_luminance
float linearToRelativeLuminance( const in vec3 color ) {

	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );

	return dot( weights, color.rgb );

}

bool isPerspectiveMatrix( mat4 m ) {

	return m[ 2 ][ 3 ] == - 1.0;

}

vec2 equirectUv( in vec3 dir ) {

	// dir is assumed to be unit length

	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;

	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

	return vec2( u, v );

}
`,NB=`
#ifdef ENVMAP_TYPE_CUBE_UV

	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0

	// These shader functions convert between the UV coordinates of a single face of
	// a cubemap, the 0-5 integer index of a cube face, and the direction vector for
	// sampling a textureCube (not generally normalized ).

	float getFace( vec3 direction ) {

		vec3 absDirection = abs( direction );

		float face = - 1.0;

		if ( absDirection.x > absDirection.z ) {

			if ( absDirection.x > absDirection.y )

				face = direction.x > 0.0 ? 0.0 : 3.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		} else {

			if ( absDirection.z > absDirection.y )

				face = direction.z > 0.0 ? 2.0 : 5.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		}

		return face;

	}

	// RH coordinate system; PMREM face-indexing convention
	vec2 getUV( vec3 direction, float face ) {

		vec2 uv;

		if ( face == 0.0 ) {

			uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x

		} else if ( face == 1.0 ) {

			uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y

		} else if ( face == 2.0 ) {

			uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z

		} else if ( face == 3.0 ) {

			uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x

		} else if ( face == 4.0 ) {

			uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y

		} else {

			uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z

		}

		return 0.5 * ( uv + 1.0 );

	}

	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {

		float face = getFace( direction );

		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );

		mipInt = max( mipInt, cubeUV_minMipLevel );

		float faceSize = exp2( mipInt );

		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;

		if ( face > 2.0 ) {

			uv.y += faceSize;

			face -= 3.0;

		}

		uv.x += face * faceSize;

		uv.x += filterInt * 3.0 * cubeUV_minTileSize;

		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );

		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;

		#ifdef texture2DGradEXT

			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb; // disable anisotropic filtering

		#else

			return texture2D( envMap, uv ).rgb;

		#endif

	}

	// These defines must match with PMREMGenerator

	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0

	float roughnessToMip( float roughness ) {

		float mip = 0.0;

		if ( roughness >= r1 ) {

			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;

		} else if ( roughness >= r4 ) {

			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;

		} else if ( roughness >= r5 ) {

			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;

		} else if ( roughness >= r6 ) {

			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;

		} else {

			mip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25
		}

		return mip;

	}

	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {

		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );

		float mipF = fract( mip );

		float mipInt = floor( mip );

		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );

		if ( mipF == 0.0 ) {

			return vec4( color0, 1.0 );

		} else {

			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );

			return vec4( mix( color0, color1, mipF ), 1.0 );

		}

	}

#endif
`,FB=`
vec3 transformedNormal = objectNormal;

#ifdef USE_INSTANCING

	// this is in lieu of a per-instance normal-matrix
	// shear transforms in the instance matrix are not supported

	mat3 m = mat3( instanceMatrix );

	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );

	transformedNormal = m * transformedNormal;

#endif

transformedNormal = normalMatrix * transformedNormal;

#ifdef FLIP_SIDED

	transformedNormal = - transformedNormal;

#endif

#ifdef USE_TANGENT

	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#ifdef FLIP_SIDED

		transformedTangent = - transformedTangent;

	#endif

#endif
`,UB=`
#ifdef USE_DISPLACEMENTMAP

	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;

#endif
`,OB=`
#ifdef USE_DISPLACEMENTMAP

	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );

#endif
`,BB=`
#ifdef USE_EMISSIVEMAP

	vec4 emissiveColor = texture2D( emissiveMap, vUv );

	totalEmissiveRadiance *= emissiveColor.rgb;

#endif
`,zB=`
#ifdef USE_EMISSIVEMAP

	uniform sampler2D emissiveMap;

#endif
`,kB=`
gl_FragColor = linearToOutputTexel( gl_FragColor );
`,HB=`

vec4 LinearToLinear( in vec4 value ) {
	return value;
}

vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

`,GB=`
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vec3 cameraToFrag;

		if ( isOrthographic ) {

			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToFrag = normalize( vWorldPosition - cameraPosition );

		}

		// Transforming Normal Vectors with the Inverse Transformation
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( cameraToFrag, worldNormal );

		#else

			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );

		#endif

	#else

		vec3 reflectVec = vReflect;

	#endif

	#ifdef ENVMAP_TYPE_CUBE

		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );

	#elif defined( ENVMAP_TYPE_CUBE_UV )

		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );

	#else

		vec4 envColor = vec4( 0.0 );

	#endif

	#ifdef ENVMAP_BLENDING_MULTIPLY

		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_MIX )

		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_ADD )

		outgoingLight += envColor.xyz * specularStrength * reflectivity;

	#endif

#endif
`,VB=`
#ifdef USE_ENVMAP

	uniform float envMapIntensity;
	uniform float flipEnvMap;

	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif
`,WB=`
#ifdef USE_ENVMAP

	uniform float reflectivity;

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif

#endif
`,$B=`
#ifdef USE_ENVMAP

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;

	#else

		varying vec3 vReflect;
		uniform float refractionRatio;

	#endif

#endif
`,XB=`
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vWorldPosition = worldPosition.xyz;

	#else

		vec3 cameraToVertex;

		if ( isOrthographic ) {

			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );

		}

		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vReflect = reflect( cameraToVertex, worldNormal );

		#else

			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );

		#endif

	#endif

#endif
`,jB=`
#ifdef USE_FOG

	vFogDepth = - mvPosition.z;

#endif
`,qB=`
#ifdef USE_FOG

	varying float vFogDepth;

#endif
`,YB=`
#ifdef USE_FOG

	#ifdef FOG_EXP2

		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );

	#else

		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );

	#endif

	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );

#endif
`,KB=`
#ifdef USE_FOG

	uniform vec3 fogColor;
	varying float vFogDepth;

	#ifdef FOG_EXP2

		uniform float fogDensity;

	#else

		uniform float fogNear;
		uniform float fogFar;

	#endif

#endif
`,ZB=`

#ifdef USE_GRADIENTMAP

	uniform sampler2D gradientMap;

#endif

vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {

	// dotNL will be from -1.0 to 1.0
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );

	#ifdef USE_GRADIENTMAP

		return vec3( texture2D( gradientMap, coord ).r );

	#else

		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );

	#endif

}
`,JB=`
#ifdef USE_LIGHTMAP

	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;

	reflectedLight.indirectDiffuse += lightMapIrradiance;

#endif
`,QB=`
#ifdef USE_LIGHTMAP

	uniform sampler2D lightMap;
	uniform float lightMapIntensity;

#endif
`,ez=`
vec3 diffuse = vec3( 1.0 );

GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );

GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;

vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif

IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;

vIndirectFront += getAmbientLightIrradiance( ambientLightColor );

vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );

#ifdef DOUBLE_SIDED

	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );

	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );

#endif

#if NUM_POINT_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		getPointLightInfo( pointLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;

		#endif

	}
	#pragma unroll_loop_end

#endif

#if NUM_SPOT_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		getSpotLightInfo( spotLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;

		#endif
	}
	#pragma unroll_loop_end

#endif

#if NUM_DIR_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;

		#endif

	}
	#pragma unroll_loop_end

#endif

#if NUM_HEMI_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );

		#ifdef DOUBLE_SIDED

			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );

		#endif

	}
	#pragma unroll_loop_end

#endif
`,tz=`
uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];

// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere
// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {

	// normal is assumed to have unit length

	float x = normal.x, y = normal.y, z = normal.z;

	// band 0
	vec3 result = shCoefficients[ 0 ] * 0.886227;

	// band 1
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;

	// band 2
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );

	return result;

}

vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {

	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );

	return irradiance;

}

vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {

	vec3 irradiance = ambientLightColor;

	return irradiance;

}

float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {

	#if defined ( PHYSICALLY_CORRECT_LIGHTS )

		// based upon Frostbite 3 Moving to Physically-based Rendering
		// page 32, equation 26: E[window1]
		// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );

		if ( cutoffDistance > 0.0 ) {

			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );

		}

		return distanceFalloff;

	#else

		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {

			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );

		}

		return 1.0;

	#endif

}

float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {

	return smoothstep( coneCosine, penumbraCosine, angleCosine );

}

#if NUM_DIR_LIGHTS > 0

	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};

	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];

	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {

		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;

	}

#endif


#if NUM_POINT_LIGHTS > 0

	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};

	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];

	// light is an out parameter as having it as a return value caused compiler errors on some devices
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {

		vec3 lVector = pointLight.position - geometry.position;

		light.direction = normalize( lVector );

		float lightDistance = length( lVector );

		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );

	}

#endif


#if NUM_SPOT_LIGHTS > 0

	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};

	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];

	// light is an out parameter as having it as a return value caused compiler errors on some devices
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {

		vec3 lVector = spotLight.position - geometry.position;

		light.direction = normalize( lVector );

		float angleCos = dot( light.direction, spotLight.direction );

		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );

		if ( spotAttenuation > 0.0 ) {

			float lightDistance = length( lVector );

			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );

		} else {

			light.color = vec3( 0.0 );
			light.visible = false;

		}

	}

#endif


#if NUM_RECT_AREA_LIGHTS > 0

	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};

	// Pre-computed values of LinearTransformedCosine approximation of BRDF
	// BRDF approximation Texture is 64x64
	uniform sampler2D ltc_1; // RGBA Float
	uniform sampler2D ltc_2; // RGBA Float

	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];

#endif


#if NUM_HEMI_LIGHTS > 0

	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};

	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];

	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {

		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;

		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );

		return irradiance;

	}

#endif
`,nz=`
#if defined( USE_ENVMAP )

	vec3 getIBLIrradiance( const in vec3 normal ) {

		#if defined( ENVMAP_TYPE_CUBE_UV )

			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );

			return PI * envMapColor.rgb * envMapIntensity;

		#else

			return vec3( 0.0 );

		#endif

	}

	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {

		#if defined( ENVMAP_TYPE_CUBE_UV )

			vec3 reflectVec = reflect( - viewDir, normal );

			// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );

			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );

			return envMapColor.rgb * envMapIntensity;

		#else

			return vec3( 0.0 );

		#endif

	}

#endif
`,iz=`
ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;
`,rz=`
varying vec3 vViewPosition;

struct ToonMaterial {

	vec3 diffuseColor;

};

void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;

	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon

#define Material_LightProbeLOD( material )	(0)
`,sz=`
BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`,oz=`
varying vec3 vViewPosition;

struct BlinnPhongMaterial {

	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;

};

void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;

	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;

}

void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong

#define Material_LightProbeLOD( material )	(0)
`,az=`
PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );

vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );

material.roughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.
material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );

#ifdef IOR

	#ifdef SPECULAR

		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;

		#ifdef USE_SPECULARINTENSITYMAP

			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;

		#endif

		#ifdef USE_SPECULARCOLORMAP

			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;

		#endif

		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );

	#else

		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;

	#endif

	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );

#else

	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;

#endif

#ifdef USE_CLEARCOAT

	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;

	#ifdef USE_CLEARCOATMAP

		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;

	#endif

	#ifdef USE_CLEARCOAT_ROUGHNESSMAP

		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;

	#endif

	material.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model
	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );

#endif

#ifdef USE_SHEEN

	material.sheenColor = sheenColor;

	#ifdef USE_SHEENCOLORMAP

		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;

	#endif

	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );

	#ifdef USE_SHEENROUGHNESSMAP

		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;

	#endif

#endif
`,lz=`
struct PhysicalMaterial {

	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;

	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif

	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif

};

// temporary
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );

// This is a curve-fit approxmation to the "Charlie sheen" BRDF integrated over the hemisphere from 
// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF". The analysis can be found
// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {

	float dotNV = saturate( dot( normal, viewDir ) );

	float r2 = roughness * roughness;

	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;

	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;

	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );

	return saturate( DG * RECIPROCAL_PI );

}

// Analytical approximation of the DFG LUT, one half of the
// split-sum approximation used in indirect specular lighting.
// via 'environmentBRDF' from "Physically Based Shading on Mobile"
// https://www.unrealengine.com/blog/physically-based-shading-on-mobile
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {

	float dotNV = saturate( dot( normal, viewDir ) );

	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );

	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );

	vec4 r = roughness * c0 + c1;

	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;

	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;

	return fab;

}

vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {

	vec2 fab = DFGApprox( normal, viewDir, roughness );

	return specularColor * fab.x + specularF90 * fab.y;

}

// Fdez-Ag\xFCera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
// Approximates multiscattering in order to preserve energy.
// http://www.jcgt.org/published/0008/01/03/
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {

	vec2 fab = DFGApprox( normal, viewDir, roughness );

	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;

	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;

	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21
	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );

	singleScatter += FssEss;
	multiScatter += Fms * Ems;

}

#if NUM_RECT_AREA_LIGHTS > 0

	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;

		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction
		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;

		vec2 uv = LTC_Uv( normal, viewDir, roughness );

		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );

		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);

		// LTC Fresnel Approximation by Stephen Hill
		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );

		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );

		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );

	}

#endif

void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );

	vec3 irradiance = dotNL * directLight.color;

	#ifdef USE_CLEARCOAT

		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );

		vec3 ccIrradiance = dotNLcc * directLight.color;

		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );

	#endif

	#ifdef USE_SHEEN

		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );

	#endif

	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );


	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}

void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {

	#ifdef USE_CLEARCOAT

		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );

	#endif

	#ifdef USE_SHEEN

		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );

	#endif

	// Both indirect specular and indirect diffuse light accumulate here

	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;

	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );

	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );

	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;

	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;

}

#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical

// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {

	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );

}
`,cz=`
/**
 * This is a template that can be used to light a material, it uses pluggable
 * RenderEquations (RE)for specific lighting scenarios.
 *
 * Instructions for use:
 * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined
 * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???
 * - Create a material parameter that is to be passed as the third parameter to your lighting functions.
 *
 * TODO:
 * - Add area light support.
 * - Add sphere light support.
 * - Add diffuse light probe (irradiance cubemap) support.
 */

GeometricContext geometry;

geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

#ifdef USE_CLEARCOAT

	geometry.clearcoatNormal = clearcoatNormal;

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`,uz=`
#if defined( RE_IndirectDiffuse )

	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;

		irradiance += lightMapIrradiance;

	#endif

	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )

		iblIrradiance += getIBLIrradiance( geometry.normal );

	#endif

#endif

#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )

	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );

	#ifdef USE_CLEARCOAT

		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );

	#endif

#endif
`,hz=`
#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );

#endif
`,dz=`
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	// Doing a strict comparison with == 1.0 can cause noise artifacts
	// on some platforms. See issue #17623.
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;

#endif
`,fz=`
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;

#endif
`,pz=`
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		varying float vFragDepth;
		varying float vIsPerspective;

	#else

		uniform float logDepthBufFC;

	#endif

#endif
`,mz=`
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );

	#else

		if ( isPerspectiveMatrix( projectionMatrix ) ) {

			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;

			gl_Position.z *= gl_Position.w;

		}

	#endif

#endif
`,gz=`
#ifdef USE_MAP

	vec4 sampledDiffuseColor = texture2D( map, vUv );

	#ifdef DECODE_VIDEO_TEXTURE

		// inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)

		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );

	#endif

	diffuseColor *= sampledDiffuseColor;

#endif
`,vz=`
#ifdef USE_MAP

	uniform sampler2D map;

#endif
`,_z=`
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;

#endif

#ifdef USE_MAP

	diffuseColor *= texture2D( map, uv );

#endif

#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, uv ).g;

#endif
`,xz=`
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	uniform mat3 uvTransform;

#endif

#ifdef USE_MAP

	uniform sampler2D map;

#endif

#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`,yz=`
float metalnessFactor = metalness;

#ifdef USE_METALNESSMAP

	vec4 texelMetalness = texture2D( metalnessMap, vUv );

	// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	metalnessFactor *= texelMetalness.b;

#endif
`,Mz=`
#ifdef USE_METALNESSMAP

	uniform sampler2D metalnessMap;

#endif
`,Sz=`
#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	vColor *= morphTargetBaseInfluence;

	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

		#if defined( USE_COLOR_ALPHA )

			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];

		#elif defined( USE_COLOR )

			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];

		#endif

	}

#endif
`,wz=`
#ifdef USE_MORPHNORMALS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	objectNormal *= morphTargetBaseInfluence;

	#ifdef MORPHTARGETS_TEXTURE

		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];

		}

	#else

		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];

	#endif

#endif
`,Ez=`
#ifdef USE_MORPHTARGETS

	uniform float morphTargetBaseInfluence;

	#ifdef MORPHTARGETS_TEXTURE

		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;

		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {

			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;

			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );

		}

	#else

		#ifndef USE_MORPHNORMALS

			uniform float morphTargetInfluences[ 8 ];

		#else

			uniform float morphTargetInfluences[ 4 ];

		#endif

	#endif

#endif
`,bz=`
#ifdef USE_MORPHTARGETS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	transformed *= morphTargetBaseInfluence;

	#ifdef MORPHTARGETS_TEXTURE

		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];

		}

	#else

		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];

		#ifndef USE_MORPHNORMALS

			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];

		#endif

	#endif

#endif
`,Tz=`
float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;

#ifdef FLAT_SHADED

	// Workaround for Adreno GPUs not able to do dFdx( vViewPosition )

	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );

#else

	vec3 normal = normalize( vNormal );

	#ifdef DOUBLE_SIDED

		normal = normal * faceDirection;

	#endif

	#ifdef USE_TANGENT

		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );

		#ifdef DOUBLE_SIDED

			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;

		#endif

		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )

			mat3 vTBN = mat3( tangent, bitangent, normal );

		#endif

	#endif

#endif

// non perturbed normal for clearcoat among others

vec3 geometryNormal = normal;

`,Az=`

#ifdef OBJECTSPACE_NORMALMAP

	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

	#ifdef FLIP_SIDED

		normal = - normal;

	#endif

	#ifdef DOUBLE_SIDED

		normal = normal * faceDirection;

	#endif

	normal = normalize( normalMatrix * normal );

#elif defined( TANGENTSPACE_NORMALMAP )

	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;

	#ifdef USE_TANGENT

		normal = normalize( vTBN * mapN );

	#else

		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );

	#endif

#elif defined( USE_BUMPMAP )

	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );

#endif
`,Cz=`
#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif
`,Rz=`
#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif
`,Lz=`
#ifndef FLAT_SHADED // normal is computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif
`,Pz=`
#ifdef USE_NORMALMAP

	uniform sampler2D normalMap;
	uniform vec2 normalScale;

#endif

#ifdef OBJECTSPACE_NORMALMAP

	uniform mat3 normalMatrix;

#endif

#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )

	// Normal Mapping Without Precomputed Tangents
	// http://www.thetenthplanet.de/archives/1180

	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );

		vec3 N = surf_norm; // normalized

		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );

		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;

		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );

		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );

	}

#endif
`,Dz=`
#ifdef USE_CLEARCOAT

	vec3 clearcoatNormal = geometryNormal;

#endif
`,Iz=`
#ifdef USE_CLEARCOAT_NORMALMAP

	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;

	#ifdef USE_TANGENT

		clearcoatNormal = normalize( vTBN * clearcoatMapN );

	#else

		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );

	#endif

#endif
`,Nz=`

#ifdef USE_CLEARCOATMAP

	uniform sampler2D clearcoatMap;

#endif

#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform sampler2D clearcoatRoughnessMap;

#endif

#ifdef USE_CLEARCOAT_NORMALMAP

	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;

#endif
`,Fz=`
#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif

// https://github.com/mrdoob/three.js/pull/22425
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif

gl_FragColor = vec4( outgoingLight, diffuseColor.a );
`,Uz=`
vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}

vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}

const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)
const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)

const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );

const float ShiftRight8 = 1. / 256.;

vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8; // tidy overflow
	return r * PackUpscale;
}

float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}

vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}

vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}

// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions

float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}

// NOTE: https://twitter.com/gonnavis/status/1377183786949959682

float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}
`,Oz=`
#ifdef PREMULTIPLIED_ALPHA

	// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.
	gl_FragColor.rgb *= gl_FragColor.a;

#endif
`,Bz=`
vec4 mvPosition = vec4( transformed, 1.0 );

#ifdef USE_INSTANCING

	mvPosition = instanceMatrix * mvPosition;

#endif

mvPosition = modelViewMatrix * mvPosition;

gl_Position = projectionMatrix * mvPosition;
`,zz=`
#ifdef DITHERING

	gl_FragColor.rgb = dithering( gl_FragColor.rgb );

#endif
`,kz=`
#ifdef DITHERING

	// based on https://www.shadertoy.com/view/MslGR8
	vec3 dithering( vec3 color ) {
		//Calculate grid position
		float grid_position = rand( gl_FragCoord.xy );

		//Shift the individual colors differently, thus making it even harder to see the dithering pattern
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );

		//modify shift according to grid position.
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );

		//shift the color by dither_shift
		return color + dither_shift_RGB;
	}

#endif
`,Hz=`
float roughnessFactor = roughness;

#ifdef USE_ROUGHNESSMAP

	vec4 texelRoughness = texture2D( roughnessMap, vUv );

	// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	roughnessFactor *= texelRoughness.g;

#endif
`,Gz=`
#ifdef USE_ROUGHNESSMAP

	uniform sampler2D roughnessMap;

#endif
`,Vz=`
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): create uniforms for area light shadows

	#endif
	*/

	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

	}

	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

		return unpackRGBATo2Half( texture2D( shadow, uv ) );

	}

	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

		float occlusion = 1.0;

		vec2 distribution = texture2DDistribution( shadow, uv );

		float hard_shadow = step( compare , distribution.x ); // Hard Shadow

		if (hard_shadow != 1.0 ) {

			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

		}
		return occlusion;

	}

	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

		float shadow = 1.0;

		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;

		// if ( something && something ) breaks ATI OpenGL shader compiler
		// if ( all( something, something ) ) using this instead

		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );

		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );

		bool frustumTest = all( frustumTestVec );

		if ( frustumTest ) {

		#if defined( SHADOWMAP_TYPE_PCF )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;

			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;

			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );

		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;

			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;

			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );

		#elif defined( SHADOWMAP_TYPE_VSM )

			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

		#else // no percentage-closer filtering:

			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

		#endif

		}

		return shadow;

	}

	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
	// vector suitable for 2D texture mapping. This code uses the following layout for the
	// 2D texture:
	//
	// xzXZ
	//  y Y
	//
	// Y - Positive y direction
	// y - Negative y direction
	// X - Positive x direction
	// x - Negative x direction
	// Z - Positive z direction
	// z - Negative z direction
	//
	// Source and test bed:
	// https://gist.github.com/tschw/da10c43c467ce8afd0c4

	vec2 cubeToUV( vec3 v, float texelSizeY ) {

		// Number of texels to avoid at the edge of each square

		vec3 absV = abs( v );

		// Intersect unit cube

		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;

		// Apply scale to avoid seams

		// two texels less per square (one texel will do for NEAREST)
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

		// Unwrap

		// space: -1 ... 1 range for each square
		//
		// #X##		dim    := ( 4 , 2 )
		//  # #		center := ( 1 , 1 )

		vec2 planar = v.xy;

		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;

		if ( absV.z >= almostOne ) {

			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;

		} else if ( absV.x >= almostOne ) {

			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;

		} else if ( absV.y >= almostOne ) {

			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;

		}

		// Transform to UV space

		// scale := 0.5 / dim
		// translate := ( center + 0.5 ) / dim
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

	}

	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

		// for point lights, the uniform @vShadowCoord is re-purposed to hold
		// the vector from the light to the world-space position of the fragment.
		vec3 lightToPosition = shadowCoord.xyz;

		// dp = normalized distance from light to fragment position
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
		dp += shadowBias;

		// bd3D = base direction 3D
		vec3 bd3D = normalize( lightToPosition );

		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )

			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;

			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );

		#else // no percentage-closer filtering

			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );

		#endif

	}

#endif
`,Wz=`
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): uniforms for area light shadows

	#endif
	*/

#endif
`,$z=`
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0

		// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;

	#endif

	#if NUM_DIR_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update vAreaShadowCoord with area light info

	#endif
	*/

#endif
`,Xz=`
float getShadowMask() {

	float shadow = 1.0;

	#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

	DirectionalLightShadow directionalLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	SpotLightShadow spotLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	PointLightShadow pointLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update shadow for Area light

	#endif
	*/

	#endif

	return shadow;

}
`,jz=`
#ifdef USE_SKINNING

	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );

#endif
`,qz=`
#ifdef USE_SKINNING

	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;

	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;

	mat4 getBoneMatrix( const in float i ) {

		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );

		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );

		y = dy * ( y + 0.5 );

		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

		mat4 bone = mat4( v1, v2, v3, v4 );

		return bone;

	}

#endif
`,Yz=`
#ifdef USE_SKINNING

	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;

	transformed = ( bindMatrixInverse * skinned ).xyz;

#endif
`,Kz=`
#ifdef USE_SKINNING

	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;

	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;

	#ifdef USE_TANGENT

		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#endif

#endif
`,Zz=`
float specularStrength;

#ifdef USE_SPECULARMAP

	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;

#else

	specularStrength = 1.0;

#endif
`,Jz=`
#ifdef USE_SPECULARMAP

	uniform sampler2D specularMap;

#endif
`,Qz=`
#if defined( TONE_MAPPING )

	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );

#endif
`,ek=`
#ifndef saturate
// <common> may have defined saturate() already
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif

uniform float toneMappingExposure;

// exposure only
vec3 LinearToneMapping( vec3 color ) {

	return toneMappingExposure * color;

}

// source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf
vec3 ReinhardToneMapping( vec3 color ) {

	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );

}

// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/
vec3 OptimizedCineonToneMapping( vec3 color ) {

	// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );

}

// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs
vec3 RRTAndODTFit( vec3 v ) {

	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;

}

// this implementation of ACES is modified to accommodate a brighter viewing environment.
// the scale factor of 1/0.6 is subjective. see discussion in #19621.

vec3 ACESFilmicToneMapping( vec3 color ) {

	// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source
		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);

	// ODT_SAT => XYZ => D60_2_D65 => sRGB
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source
		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);

	color *= toneMappingExposure / 0.6;

	color = ACESInputMat * color;

	// Apply RRT and ODT
	color = RRTAndODTFit( color );

	color = ACESOutputMat * color;

	// Clamp to [0, 1]
	return saturate( color );

}

vec3 CustomToneMapping( vec3 color ) { return color; }
`,tk=`
#ifdef USE_TRANSMISSION

	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;

	#ifdef USE_TRANSMISSIONMAP

		transmissionFactor *= texture2D( transmissionMap, vUv ).r;

	#endif

	#ifdef USE_THICKNESSMAP

		thicknessFactor *= texture2D( thicknessMap, vUv ).g;

	#endif

	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );

	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );

	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif
`,nk=`
#ifdef USE_TRANSMISSION

	// Transmission code is based on glTF-Sampler-Viewer
	// https://github.com/KhronosGroup/glTF-Sample-Viewer

	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;

	#ifdef USE_TRANSMISSIONMAP

		uniform sampler2D transmissionMap;

	#endif

	#ifdef USE_THICKNESSMAP

		uniform sampler2D thicknessMap;

	#endif

	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;

	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;

	varying vec3 vWorldPosition;

	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {

		// Direction of refracted light.
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );

		// Compute rotation-independant scaling of the model matrix.
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );

		// The thickness is specified in local space.
		return normalize( refractionVector ) * thickness * modelScale;

	}

	float applyIorToRoughness( const in float roughness, const in float ior ) {

		// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
		// an IOR of 1.5 results in the default amount of microfacet refraction.
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );

	}

	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {

		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );

		#ifdef texture2DLodEXT

			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );

		#else

			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );

		#endif

	}

	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {

		if ( attenuationDistance == 0.0 ) {

			// Attenuation distance is +\u221E (which we indicate by zero), i.e. the transmitted color is not attenuated at all.
			return radiance;

		} else {

			// Compute light attenuation using Beer's law.
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law
			return transmittance * radiance;

		}

	}

	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {

		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;

		// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;

		// Sample framebuffer to get pixel the refracted ray hits.
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );

		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );

		// Get the specular component.
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );

		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );

	}
#endif
`,ik=`
#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )

	varying vec2 vUv;

#endif
`,rk=`
#ifdef USE_UV

	#ifdef UVS_VERTEX_ONLY

		vec2 vUv;

	#else

		varying vec2 vUv;

	#endif

	uniform mat3 uvTransform;

#endif
`,sk=`
#ifdef USE_UV

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

#endif
`,ok=`
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	varying vec2 vUv2;

#endif
`,ak=`
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	attribute vec2 uv2;
	varying vec2 vUv2;

	uniform mat3 uv2Transform;

#endif
`,lk=`
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;

#endif
`,ck=`
#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )

	vec4 worldPosition = vec4( transformed, 1.0 );

	#ifdef USE_INSTANCING

		worldPosition = instanceMatrix * worldPosition;

	#endif

	worldPosition = modelMatrix * worldPosition;

#endif
`;const uk=`
varying vec2 vUv;
uniform mat3 uvTransform;

void main() {

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

	gl_Position = vec4( position.xy, 1.0, 1.0 );

}
`,hk=`
uniform sampler2D t2D;

varying vec2 vUv;

void main() {

	gl_FragColor = texture2D( t2D, vUv );

	#ifdef DECODE_VIDEO_TEXTURE

		// inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)

		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );

	#endif

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`,dk=`
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

	gl_Position.z = gl_Position.w; // set z to camera.far

}
`,fk=`
#include <envmap_common_pars_fragment>
uniform float opacity;

varying vec3 vWorldDirection;

#include <cube_uv_reflection_fragment>

void main() {

	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>

	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`,pk=`
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vHighPrecisionZW = gl_Position.zw;

}
`,mk=`
#if DEPTH_PACKING == 3200

	uniform float opacity;

#endif

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

varying vec2 vHighPrecisionZW;

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#if DEPTH_PACKING == 3200

		diffuseColor.a = opacity;

	#endif

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	#include <logdepthbuf_fragment>

	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;

	#if DEPTH_PACKING == 3200

		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );

	#elif DEPTH_PACKING == 3201

		gl_FragColor = packDepthToRGBA( fragCoordZ );

	#endif

}
`,gk=`
#define DISTANCE

varying vec3 vWorldPosition;

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>

	vWorldPosition = worldPosition.xyz;

}
`,vk=`
#define DISTANCE

uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>

void main () {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist ); // clamp to [ 0, 1 ]

	gl_FragColor = packDepthToRGBA( dist );

}
`,_k=`
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

}
`,xk=`
uniform sampler2D tEquirect;

varying vec3 vWorldDirection;

#include <common>

void main() {

	vec3 direction = normalize( vWorldDirection );

	vec2 sampleUV = equirectUv( direction );

	gl_FragColor = texture2D( tEquirect, sampleUV );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`,yk=`
uniform float scale;
attribute float lineDistance;

varying float vLineDistance;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	vLineDistance = scale * lineDistance;

	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`,Mk=`
uniform vec3 diffuse;
uniform float opacity;

uniform float dashSize;
uniform float totalSize;

varying float vLineDistance;

#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	if ( mod( vLineDistance, totalSize ) > dashSize ) {

		discard;

	}

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <color_fragment>

	outgoingLight = diffuseColor.rgb; // simple shader

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`,Sk=`
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>

	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>

}
`,wk=`
uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;

	#else

		reflectedLight.indirectDiffuse += vec3( 1.0 );

	#endif

	// modulation
	#include <aomap_fragment>

	reflectedLight.indirectDiffuse *= diffuseColor.rgb;

	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`,Ek=`
#define LAMBERT

varying vec3 vLightFront;
varying vec3 vIndirectFront;

#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`,bk=`
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

varying vec3 vLightFront;
varying vec3 vIndirectFront;

#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif


#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>

	// accumulation

	#ifdef DOUBLE_SIDED

		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;

	#else

		reflectedLight.indirectDiffuse += vIndirectFront;

	#endif

	#include <lightmap_fragment>

	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );

	#ifdef DOUBLE_SIDED

		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;

	#else

		reflectedLight.directDiffuse = vLightFront;

	#endif

	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();

	// modulation

	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <envmap_fragment>

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`,Tk=`
#define MATCAP

varying vec3 vViewPosition;

#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

	vViewPosition = - mvPosition.xyz;

}
`,Ak=`
#define MATCAP

uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;

varying vec3 vViewPosition;

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks

	#ifdef USE_MATCAP

		vec4 matcapColor = texture2D( matcap, uv );

	#else

		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 ); // default if matcap is missing

	#endif

	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`,Ck=`
#define NORMAL

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	varying vec3 vViewPosition;

#endif

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	vViewPosition = - mvPosition.xyz;

#endif

}
`,Rk=`
#define NORMAL

uniform float opacity;

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	varying vec3 vViewPosition;

#endif

#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );

	#ifdef OPAQUE

		gl_FragColor.a = 1.0;

	#endif

}
`,Lk=`
#define PHONG

varying vec3 vViewPosition;

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`,Pk=`
#define PHONG

uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`,Dk=`
#define STANDARD

varying vec3 vViewPosition;

#ifdef USE_TRANSMISSION

	varying vec3 vWorldPosition;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

#ifdef USE_TRANSMISSION

	vWorldPosition = worldPosition.xyz;

#endif
}
`,Ik=`
#define STANDARD

#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef IOR
	uniform float ior;
#endif

#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;

	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif

	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif

#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif

#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;

	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif

	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif

varying vec3 vViewPosition;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

	#include <transmission_fragment>

	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

	#ifdef USE_SHEEN

		// Sheen energy compensation approximation calculation can be found at the end of
		// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );

		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;

	#endif

	#ifdef USE_CLEARCOAT

		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );

		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );

		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;

	#endif

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`,Nk=`
#define TOON

varying vec3 vViewPosition;

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`,Fk=`
#define TOON

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`,Uk=`
uniform float size;
uniform float scale;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>

	gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );

	#endif

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>

}
`,Ok=`
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`,Bk=`
#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>

void main() {

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`,zk=`
uniform vec3 color;
uniform float opacity;

#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>

void main() {

	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`,kk=`
uniform float rotation;
uniform vec2 center;

#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	#ifndef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;

	#endif

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`,Hk=`
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`,Ke={alphamap_fragment:mB,alphamap_pars_fragment:gB,alphatest_fragment:vB,alphatest_pars_fragment:_B,aomap_fragment:xB,aomap_pars_fragment:yB,begin_vertex:MB,beginnormal_vertex:SB,bsdfs:wB,bumpmap_pars_fragment:EB,clipping_planes_fragment:bB,clipping_planes_pars_fragment:TB,clipping_planes_pars_vertex:AB,clipping_planes_vertex:CB,color_fragment:RB,color_pars_fragment:LB,color_pars_vertex:PB,color_vertex:DB,common:IB,cube_uv_reflection_fragment:NB,defaultnormal_vertex:FB,displacementmap_pars_vertex:UB,displacementmap_vertex:OB,emissivemap_fragment:BB,emissivemap_pars_fragment:zB,encodings_fragment:kB,encodings_pars_fragment:HB,envmap_fragment:GB,envmap_common_pars_fragment:VB,envmap_pars_fragment:WB,envmap_pars_vertex:$B,envmap_physical_pars_fragment:nz,envmap_vertex:XB,fog_vertex:jB,fog_pars_vertex:qB,fog_fragment:YB,fog_pars_fragment:KB,gradientmap_pars_fragment:ZB,lightmap_fragment:JB,lightmap_pars_fragment:QB,lights_lambert_vertex:ez,lights_pars_begin:tz,lights_toon_fragment:iz,lights_toon_pars_fragment:rz,lights_phong_fragment:sz,lights_phong_pars_fragment:oz,lights_physical_fragment:az,lights_physical_pars_fragment:lz,lights_fragment_begin:cz,lights_fragment_maps:uz,lights_fragment_end:hz,logdepthbuf_fragment:dz,logdepthbuf_pars_fragment:fz,logdepthbuf_pars_vertex:pz,logdepthbuf_vertex:mz,map_fragment:gz,map_pars_fragment:vz,map_particle_fragment:_z,map_particle_pars_fragment:xz,metalnessmap_fragment:yz,metalnessmap_pars_fragment:Mz,morphcolor_vertex:Sz,morphnormal_vertex:wz,morphtarget_pars_vertex:Ez,morphtarget_vertex:bz,normal_fragment_begin:Tz,normal_fragment_maps:Az,normal_pars_fragment:Cz,normal_pars_vertex:Rz,normal_vertex:Lz,normalmap_pars_fragment:Pz,clearcoat_normal_fragment_begin:Dz,clearcoat_normal_fragment_maps:Iz,clearcoat_pars_fragment:Nz,output_fragment:Fz,packing:Uz,premultiplied_alpha_fragment:Oz,project_vertex:Bz,dithering_fragment:zz,dithering_pars_fragment:kz,roughnessmap_fragment:Hz,roughnessmap_pars_fragment:Gz,shadowmap_pars_fragment:Vz,shadowmap_pars_vertex:Wz,shadowmap_vertex:$z,shadowmask_pars_fragment:Xz,skinbase_vertex:jz,skinning_pars_vertex:qz,skinning_vertex:Yz,skinnormal_vertex:Kz,specularmap_fragment:Zz,specularmap_pars_fragment:Jz,tonemapping_fragment:Qz,tonemapping_pars_fragment:ek,transmission_fragment:tk,transmission_pars_fragment:nk,uv_pars_fragment:ik,uv_pars_vertex:rk,uv_vertex:sk,uv2_pars_fragment:ok,uv2_pars_vertex:ak,uv2_vertex:lk,worldpos_vertex:ck,background_vert:uk,background_frag:hk,cube_vert:dk,cube_frag:fk,depth_vert:pk,depth_frag:mk,distanceRGBA_vert:gk,distanceRGBA_frag:vk,equirect_vert:_k,equirect_frag:xk,linedashed_vert:yk,linedashed_frag:Mk,meshbasic_vert:Sk,meshbasic_frag:wk,meshlambert_vert:Ek,meshlambert_frag:bk,meshmatcap_vert:Tk,meshmatcap_frag:Ak,meshnormal_vert:Ck,meshnormal_frag:Rk,meshphong_vert:Lk,meshphong_frag:Pk,meshphysical_vert:Dk,meshphysical_frag:Ik,meshtoon_vert:Nk,meshtoon_frag:Fk,points_vert:Uk,points_frag:Ok,shadow_vert:Bk,shadow_frag:zk,sprite_vert:kk,sprite_frag:Hk},Pe={common:{diffuse:{value:new ht(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Oi},uv2Transform:{value:new Oi},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new mt(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new ht(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new ht(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Oi}},sprite:{diffuse:{value:new ht(16777215)},opacity:{value:1},center:{value:new mt(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Oi}}},Ki={basic:{uniforms:pn([Pe.common,Pe.specularmap,Pe.envmap,Pe.aomap,Pe.lightmap,Pe.fog]),vertexShader:Ke.meshbasic_vert,fragmentShader:Ke.meshbasic_frag},lambert:{uniforms:pn([Pe.common,Pe.specularmap,Pe.envmap,Pe.aomap,Pe.lightmap,Pe.emissivemap,Pe.fog,Pe.lights,{emissive:{value:new ht(0)}}]),vertexShader:Ke.meshlambert_vert,fragmentShader:Ke.meshlambert_frag},phong:{uniforms:pn([Pe.common,Pe.specularmap,Pe.envmap,Pe.aomap,Pe.lightmap,Pe.emissivemap,Pe.bumpmap,Pe.normalmap,Pe.displacementmap,Pe.fog,Pe.lights,{emissive:{value:new ht(0)},specular:{value:new ht(1118481)},shininess:{value:30}}]),vertexShader:Ke.meshphong_vert,fragmentShader:Ke.meshphong_frag},standard:{uniforms:pn([Pe.common,Pe.envmap,Pe.aomap,Pe.lightmap,Pe.emissivemap,Pe.bumpmap,Pe.normalmap,Pe.displacementmap,Pe.roughnessmap,Pe.metalnessmap,Pe.fog,Pe.lights,{emissive:{value:new ht(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Ke.meshphysical_vert,fragmentShader:Ke.meshphysical_frag},toon:{uniforms:pn([Pe.common,Pe.aomap,Pe.lightmap,Pe.emissivemap,Pe.bumpmap,Pe.normalmap,Pe.displacementmap,Pe.gradientmap,Pe.fog,Pe.lights,{emissive:{value:new ht(0)}}]),vertexShader:Ke.meshtoon_vert,fragmentShader:Ke.meshtoon_frag},matcap:{uniforms:pn([Pe.common,Pe.bumpmap,Pe.normalmap,Pe.displacementmap,Pe.fog,{matcap:{value:null}}]),vertexShader:Ke.meshmatcap_vert,fragmentShader:Ke.meshmatcap_frag},points:{uniforms:pn([Pe.points,Pe.fog]),vertexShader:Ke.points_vert,fragmentShader:Ke.points_frag},dashed:{uniforms:pn([Pe.common,Pe.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Ke.linedashed_vert,fragmentShader:Ke.linedashed_frag},depth:{uniforms:pn([Pe.common,Pe.displacementmap]),vertexShader:Ke.depth_vert,fragmentShader:Ke.depth_frag},normal:{uniforms:pn([Pe.common,Pe.bumpmap,Pe.normalmap,Pe.displacementmap,{opacity:{value:1}}]),vertexShader:Ke.meshnormal_vert,fragmentShader:Ke.meshnormal_frag},sprite:{uniforms:pn([Pe.sprite,Pe.fog]),vertexShader:Ke.sprite_vert,fragmentShader:Ke.sprite_frag},background:{uniforms:{uvTransform:{value:new Oi},t2D:{value:null}},vertexShader:Ke.background_vert,fragmentShader:Ke.background_frag},cube:{uniforms:pn([Pe.envmap,{opacity:{value:1}}]),vertexShader:Ke.cube_vert,fragmentShader:Ke.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Ke.equirect_vert,fragmentShader:Ke.equirect_frag},distanceRGBA:{uniforms:pn([Pe.common,Pe.displacementmap,{referencePosition:{value:new se},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Ke.distanceRGBA_vert,fragmentShader:Ke.distanceRGBA_frag},shadow:{uniforms:pn([Pe.lights,Pe.fog,{color:{value:new ht(0)},opacity:{value:1}}]),vertexShader:Ke.shadow_vert,fragmentShader:Ke.shadow_frag}};Ki.physical={uniforms:pn([Ki.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new mt(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new ht(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new mt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new ht(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new ht(1,1,1)},specularColorMap:{value:null}}]),vertexShader:Ke.meshphysical_vert,fragmentShader:Ke.meshphysical_frag};function Gk(n,e,t,i,r,s){const o=new ht(0);let a=r===!0?0:1,l,c,u=null,h=0,d=null;function p(m,f){let g=!1,_=f.isScene===!0?f.background:null;_&&_.isTexture&&(_=e.get(_));const M=n.xr,E=M.getSession&&M.getSession();E&&E.environmentBlendMode==="additive"&&(_=null),_===null?v(o,a):_&&_.isColor&&(v(_,1),g=!0),(n.autoClear||g)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),_&&(_.isCubeTexture||_.mapping===Tf)?(c===void 0&&(c=new Tr(new Tu(1,1,1),new Rs({name:"BackgroundCubeMaterial",uniforms:gl(Ki.cube.uniforms),vertexShader:Ki.cube.vertexShader,fragmentShader:Ki.cube.fragmentShader,side:Hi,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(S,T,R){this.matrixWorld.copyPosition(R.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(c)),c.material.uniforms.envMap.value=_,c.material.uniforms.flipEnvMap.value=_.isCubeTexture&&_.isRenderTargetTexture===!1?-1:1,(u!==_||h!==_.version||d!==n.toneMapping)&&(c.material.needsUpdate=!0,u=_,h=_.version,d=n.toneMapping),c.layers.enableAll(),m.unshift(c,c.geometry,c.material,0,0,null)):_&&_.isTexture&&(l===void 0&&(l=new Tr(new Uv(2,2),new Rs({name:"BackgroundMaterial",uniforms:gl(Ki.background.uniforms),vertexShader:Ki.background.vertexShader,fragmentShader:Ki.background.fragmentShader,side:uu,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(l)),l.material.uniforms.t2D.value=_,_.matrixAutoUpdate===!0&&_.updateMatrix(),l.material.uniforms.uvTransform.value.copy(_.matrix),(u!==_||h!==_.version||d!==n.toneMapping)&&(l.material.needsUpdate=!0,u=_,h=_.version,d=n.toneMapping),l.layers.enableAll(),m.unshift(l,l.geometry,l.material,0,0,null))}function v(m,f){t.buffers.color.setClear(m.r,m.g,m.b,f,s)}return{getClearColor:function(){return o},setClearColor:function(m,f=1){o.set(m),a=f,v(o,a)},getClearAlpha:function(){return a},setClearAlpha:function(m){a=m,v(o,a)},render:p}}function Vk(n,e,t,i){const r=n.getParameter(n.MAX_VERTEX_ATTRIBS),s=i.isWebGL2?null:e.get("OES_vertex_array_object"),o=i.isWebGL2||s!==null,a={},l=f(null);let c=l,u=!1;function h(L,$,z,W,U){let P=!1;if(o){const k=m(W,z,$);c!==k&&(c=k,p(c.object)),P=g(L,W,z,U),P&&_(L,W,z,U)}else{const k=$.wireframe===!0;(c.geometry!==W.id||c.program!==z.id||c.wireframe!==k)&&(c.geometry=W.id,c.program=z.id,c.wireframe=k,P=!0)}U!==null&&t.update(U,n.ELEMENT_ARRAY_BUFFER),(P||u)&&(u=!1,x(L,$,z,W),U!==null&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t.get(U).buffer))}function d(){return i.isWebGL2?n.createVertexArray():s.createVertexArrayOES()}function p(L){return i.isWebGL2?n.bindVertexArray(L):s.bindVertexArrayOES(L)}function v(L){return i.isWebGL2?n.deleteVertexArray(L):s.deleteVertexArrayOES(L)}function m(L,$,z){const W=z.wireframe===!0;let U=a[L.id];U===void 0&&(U={},a[L.id]=U);let P=U[$.id];P===void 0&&(P={},U[$.id]=P);let k=P[W];return k===void 0&&(k=f(d()),P[W]=k),k}function f(L){const $=[],z=[],W=[];for(let U=0;U<r;U++)$[U]=0,z[U]=0,W[U]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:$,enabledAttributes:z,attributeDivisors:W,object:L,attributes:{},index:null}}function g(L,$,z,W){const U=c.attributes,P=$.attributes;let k=0;const Y=z.getAttributes();for(const j in Y)if(Y[j].location>=0){const ce=U[j];let de=P[j];if(de===void 0&&(j==="instanceMatrix"&&L.instanceMatrix&&(de=L.instanceMatrix),j==="instanceColor"&&L.instanceColor&&(de=L.instanceColor)),ce===void 0||ce.attribute!==de||de&&ce.data!==de.data)return!0;k++}return c.attributesNum!==k||c.index!==W}function _(L,$,z,W){const U={},P=$.attributes;let k=0;const Y=z.getAttributes();for(const j in Y)if(Y[j].location>=0){let ce=P[j];ce===void 0&&(j==="instanceMatrix"&&L.instanceMatrix&&(ce=L.instanceMatrix),j==="instanceColor"&&L.instanceColor&&(ce=L.instanceColor));const de={};de.attribute=ce,ce&&ce.data&&(de.data=ce.data),U[j]=de,k++}c.attributes=U,c.attributesNum=k,c.index=W}function M(){const L=c.newAttributes;for(let $=0,z=L.length;$<z;$++)L[$]=0}function E(L){S(L,0)}function S(L,$){const z=c.newAttributes,W=c.enabledAttributes,U=c.attributeDivisors;z[L]=1,W[L]===0&&(n.enableVertexAttribArray(L),W[L]=1),U[L]!==$&&((i.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](L,$),U[L]=$)}function T(){const L=c.newAttributes,$=c.enabledAttributes;for(let z=0,W=$.length;z<W;z++)$[z]!==L[z]&&(n.disableVertexAttribArray(z),$[z]=0)}function R(L,$,z,W,U,P){i.isWebGL2===!0&&(z===n.INT||z===n.UNSIGNED_INT)?n.vertexAttribIPointer(L,$,z,U,P):n.vertexAttribPointer(L,$,z,W,U,P)}function x(L,$,z,W){if(i.isWebGL2===!1&&(L.isInstancedMesh||W.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;M();const U=W.attributes,P=z.getAttributes(),k=$.defaultAttributeValues;for(const Y in P){const j=P[Y];if(j.location>=0){let K=U[Y];if(K===void 0&&(Y==="instanceMatrix"&&L.instanceMatrix&&(K=L.instanceMatrix),Y==="instanceColor"&&L.instanceColor&&(K=L.instanceColor)),K!==void 0){const ce=K.normalized,de=K.itemSize,F=t.get(K);if(F===void 0)continue;const We=F.buffer,Me=F.type,Ce=F.bytesPerElement;if(K.isInterleavedBufferAttribute){const re=K.data,ze=re.stride,oe=K.offset;if(re.isInstancedInterleavedBuffer){for(let ne=0;ne<j.locationSize;ne++)S(j.location+ne,re.meshPerAttribute);L.isInstancedMesh!==!0&&W._maxInstanceCount===void 0&&(W._maxInstanceCount=re.meshPerAttribute*re.count)}else for(let ne=0;ne<j.locationSize;ne++)E(j.location+ne);n.bindBuffer(n.ARRAY_BUFFER,We);for(let ne=0;ne<j.locationSize;ne++)R(j.location+ne,de/j.locationSize,Me,ce,ze*Ce,(oe+de/j.locationSize*ne)*Ce)}else{if(K.isInstancedBufferAttribute){for(let re=0;re<j.locationSize;re++)S(j.location+re,K.meshPerAttribute);L.isInstancedMesh!==!0&&W._maxInstanceCount===void 0&&(W._maxInstanceCount=K.meshPerAttribute*K.count)}else for(let re=0;re<j.locationSize;re++)E(j.location+re);n.bindBuffer(n.ARRAY_BUFFER,We);for(let re=0;re<j.locationSize;re++)R(j.location+re,de/j.locationSize,Me,ce,de*Ce,de/j.locationSize*re*Ce)}}else if(k!==void 0){const ce=k[Y];if(ce!==void 0)switch(ce.length){case 2:n.vertexAttrib2fv(j.location,ce);break;case 3:n.vertexAttrib3fv(j.location,ce);break;case 4:n.vertexAttrib4fv(j.location,ce);break;default:n.vertexAttrib1fv(j.location,ce)}}}}T()}function A(){J();for(const L in a){const $=a[L];for(const z in $){const W=$[z];for(const U in W)v(W[U].object),delete W[U];delete $[z]}delete a[L]}}function I(L){if(a[L.id]===void 0)return;const $=a[L.id];for(const z in $){const W=$[z];for(const U in W)v(W[U].object),delete W[U];delete $[z]}delete a[L.id]}function N(L){for(const $ in a){const z=a[$];if(z[L.id]===void 0)continue;const W=z[L.id];for(const U in W)v(W[U].object),delete W[U];delete z[L.id]}}function J(){q(),u=!0,c!==l&&(c=l,p(c.object))}function q(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:h,reset:J,resetDefaultState:q,dispose:A,releaseStatesOfGeometry:I,releaseStatesOfProgram:N,initAttributes:M,enableAttribute:E,disableUnusedAttributes:T}}function Wk(n,e,t,i){const r=i.isWebGL2;let s;function o(c){s=c}function a(c,u){n.drawArrays(s,c,u),t.update(u,s,1)}function l(c,u,h){if(h===0)return;let d,p;if(r)d=n,p="drawArraysInstanced";else if(d=e.get("ANGLE_instanced_arrays"),p="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[p](s,c,u,h),t.update(u,s,h)}this.setMode=o,this.render=a,this.renderInstances=l}function $k(n,e,t){let i;function r(){if(i!==void 0)return i;if(e.has("EXT_texture_filter_anisotropic")===!0){const R=e.get("EXT_texture_filter_anisotropic");i=n.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}function s(R){if(R==="highp"){if(n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision>0)return"highp";R="mediump"}return R==="mediump"&&n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext!="undefined"&&n instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&n instanceof WebGL2ComputeRenderingContext;let a=t.precision!==void 0?t.precision:"highp";const l=s(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const c=o||e.has("WEBGL_draw_buffers"),u=t.logarithmicDepthBuffer===!0,h=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),d=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),p=n.getParameter(n.MAX_TEXTURE_SIZE),v=n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),m=n.getParameter(n.MAX_VERTEX_ATTRIBS),f=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),g=n.getParameter(n.MAX_VARYING_VECTORS),_=n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),M=d>0,E=o||e.has("OES_texture_float"),S=M&&E,T=o?n.getParameter(n.MAX_SAMPLES):0;return{isWebGL2:o,drawBuffers:c,getMaxAnisotropy:r,getMaxPrecision:s,precision:a,logarithmicDepthBuffer:u,maxTextures:h,maxVertexTextures:d,maxTextureSize:p,maxCubemapSize:v,maxAttributes:m,maxVertexUniforms:f,maxVaryings:g,maxFragmentUniforms:_,vertexTextures:M,floatFragmentTextures:E,floatVertexTextures:S,maxSamples:T}}function Xk(n){const e=this;let t=null,i=0,r=!1,s=!1;const o=new ss,a=new Oi,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(h,d,p){const v=h.length!==0||d||i!==0||r;return r=d,t=u(h,p,0),i=h.length,v},this.beginShadows=function(){s=!0,u(null)},this.endShadows=function(){s=!1,c()},this.setState=function(h,d,p){const v=h.clippingPlanes,m=h.clipIntersection,f=h.clipShadows,g=n.get(h);if(!r||v===null||v.length===0||s&&!f)s?u(null):c();else{const _=s?0:i,M=_*4;let E=g.clippingState||null;l.value=E,E=u(v,d,M,p);for(let S=0;S!==M;++S)E[S]=t[S];g.clippingState=E,this.numIntersection=m?this.numPlanes:0,this.numPlanes+=_}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=i>0),e.numPlanes=i,e.numIntersection=0}function u(h,d,p,v){const m=h!==null?h.length:0;let f=null;if(m!==0){if(f=l.value,v!==!0||f===null){const g=p+m*4,_=d.matrixWorldInverse;a.getNormalMatrix(_),(f===null||f.length<g)&&(f=new Float32Array(g));for(let M=0,E=p;M!==m;++M,E+=4)o.copy(h[M]).applyMatrix4(_,a),o.normal.toArray(f,E),f[E+3]=o.constant}l.value=f,l.needsUpdate=!0}return e.numPlanes=m,e.numIntersection=0,f}}let ua;class _b{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement=="undefined")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{ua===void 0&&(ua=Hd("canvas")),ua.width=e.width,ua.height=e.height;const i=ua.getContext("2d");e instanceof ImageData?i.putImageData(e,0,0):i.drawImage(e,0,0,e.width,e.height),t=ua}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement!="undefined"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&e instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&e instanceof ImageBitmap){const t=Hd("canvas");t.width=e.width,t.height=e.height;const i=t.getContext("2d");i.drawImage(e,0,0,e.width,e.height);const r=i.getImageData(0,0,e.width,e.height),s=r.data;for(let o=0;o<s.length;o++)s[o]=ho(s[o]/255)*255;return i.putImageData(r,0,0),t}else if(e.data){const t=e.data.slice(0);for(let i=0;i<t.length;i++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[i]=Math.floor(ho(t[i]/255)*255):t[i]=ho(t[i]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}class xb{constructor(e=null){this.uuid=bu(),this.data=e,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const i={uuid:this.uuid,url:""},r=this.data;if(r!==null){let s;if(Array.isArray(r)){s=[];for(let o=0,a=r.length;o<a;o++)r[o].isDataTexture?s.push(bm(r[o].image)):s.push(bm(r[o]))}else s=bm(r);i.url=s}return t||(e.images[this.uuid]=i),i}}function bm(n){return typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&n instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&n instanceof ImageBitmap?_b.getDataURL(n):n.data?{data:Array.prototype.slice.call(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}xb.prototype.isSource=!0;let jk=0;class _i extends Dl{constructor(e=_i.DEFAULT_IMAGE,t=_i.DEFAULT_MAPPING,i=Fi,r=Fi,s=li,o=Af,a=Ui,l=wo,c=1,u=Eo){super(),Object.defineProperty(this,"id",{value:jk++}),this.uuid=bu(),this.name="",this.source=new xb(e),this.mipmaps=[],this.mapping=t,this.wrapS=i,this.wrapT=r,this.magFilter=s,this.minFilter=o,this.anisotropy=c,this.format=a,this.internalFormat=null,this.type=l,this.offset=new mt(0,0),this.repeat=new mt(1,1),this.center=new mt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Oi,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=u,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const i={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),t||(e.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==ub)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Qg:e.x=e.x-Math.floor(e.x);break;case Fi:e.x=e.x<0?0:1;break;case e0:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Qg:e.y=e.y-Math.floor(e.y);break;case Fi:e.y=e.y<0?0:1;break;case e0:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}}_i.DEFAULT_IMAGE=null;_i.DEFAULT_MAPPING=ub;_i.prototype.isTexture=!0;class Lr extends Dl{constructor(e,t,i={}){super(),this.width=e,this.height=t,this.depth=1,this.scissor=new _n(0,0,e,t),this.scissorTest=!1,this.viewport=new _n(0,0,e,t);const r={width:e,height:t,depth:1};this.texture=new _i(r,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=i.generateMipmaps!==void 0?i.generateMipmaps:!1,this.texture.internalFormat=i.internalFormat!==void 0?i.internalFormat:null,this.texture.minFilter=i.minFilter!==void 0?i.minFilter:li,this.depthBuffer=i.depthBuffer!==void 0?i.depthBuffer:!0,this.stencilBuffer=i.stencilBuffer!==void 0?i.stencilBuffer:!1,this.depthTexture=i.depthTexture!==void 0?i.depthTexture:null,this.samples=i.samples!==void 0?i.samples:0}setSize(e,t,i=1){(this.width!==e||this.height!==t||this.depth!==i)&&(this.width=e,this.height=t,this.depth=i,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=i,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0,this.texture.image=Object.assign({},e.texture.image),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}Lr.prototype.isWebGLRenderTarget=!0;class Bv extends Wi{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new ln,this.projectionMatrix=new ln,this.projectionMatrixInverse=new ln}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}Bv.prototype.isCamera=!0;class Ni extends Bv{constructor(e=50,t=1,i=.1,r=2e3){super(),this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=i,this.far=r,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=DM*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(im*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return DM*2*Math.atan(Math.tan(im*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,i,r,s,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=r,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(im*.5*this.fov)/this.zoom,i=2*t,r=this.aspect*i,s=-.5*r;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,c=o.fullHeight;s+=o.offsetX*r/l,t-=o.offsetY*i/c,r*=o.width/l,i*=o.height/c}const a=this.filmOffset;a!==0&&(s+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+r,t,t-i,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}Ni.prototype.isPerspectiveCamera=!0;const ha=90,da=1;class qk extends Wi{constructor(e,t,i){if(super(),this.type="CubeCamera",i.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=i;const r=new Ni(ha,da,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new se(1,0,0)),this.add(r);const s=new Ni(ha,da,e,t);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new se(-1,0,0)),this.add(s);const o=new Ni(ha,da,e,t);o.layers=this.layers,o.up.set(0,0,1),o.lookAt(new se(0,1,0)),this.add(o);const a=new Ni(ha,da,e,t);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new se(0,-1,0)),this.add(a);const l=new Ni(ha,da,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new se(0,0,1)),this.add(l);const c=new Ni(ha,da,e,t);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new se(0,0,-1)),this.add(c)}update(e,t){this.parent===null&&this.updateMatrixWorld();const i=this.renderTarget,[r,s,o,a,l,c]=this.children,u=e.getRenderTarget(),h=e.toneMapping,d=e.xr.enabled;e.toneMapping=Rr,e.xr.enabled=!1;const p=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,e.setRenderTarget(i,0),e.render(t,r),e.setRenderTarget(i,1),e.render(t,s),e.setRenderTarget(i,2),e.render(t,o),e.setRenderTarget(i,3),e.render(t,a),e.setRenderTarget(i,4),e.render(t,l),i.texture.generateMipmaps=p,e.setRenderTarget(i,5),e.render(t,c),e.setRenderTarget(u),e.toneMapping=h,e.xr.enabled=d,i.texture.needsPMREMUpdate=!0}}class zv extends _i{constructor(e,t,i,r,s,o,a,l,c,u){e=e!==void 0?e:[],t=t!==void 0?t:fl,super(e,t,i,r,s,o,a,l,c,u),this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}zv.prototype.isCubeTexture=!0;class yb extends Lr{constructor(e,t={}){super(e,e,t);const i={width:e,height:e,depth:1},r=[i,i,i,i,i,i];this.texture=new zv(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:li}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const i={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},r=new Tu(5,5,5),s=new Rs({name:"CubemapFromEquirect",uniforms:gl(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:Hi,blending:ws});s.uniforms.tEquirect.value=t;const o=new Tr(r,s),a=t.minFilter;return t.minFilter===Af&&(t.minFilter=li),new qk(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,i,r){const s=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,i,r);e.setRenderTarget(s)}}yb.prototype.isWebGLCubeRenderTarget=!0;function Yk(n){let e=new WeakMap;function t(o,a){return a===Zg?o.mapping=fl:a===Jg&&(o.mapping=pl),o}function i(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const a=o.mapping;if(a===Zg||a===Jg)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=new yb(l.height/2);return c.fromEquirectangularTexture(n,o),e.set(o,c),o.addEventListener("dispose",r),t(c.texture,o.mapping)}else return null}}return o}function r(o){const a=o.target;a.removeEventListener("dispose",r);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function s(){e=new WeakMap}return{get:i,dispose:s}}class Mb extends Bv{constructor(e=-1,t=1,i=1,r=-1,s=.1,o=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=i,this.bottom=r,this.near=s,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,i,r,s,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=r,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let s=i-e,o=i+e,a=r+t,l=r-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=c*this.view.offsetX,o=s+c*this.view.width,a-=u*this.view.offsetY,l=a-u*this.view.height}this.projectionMatrix.makeOrthographic(s,o,a,l,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}Mb.prototype.isOrthographicCamera=!0;const Na=4,$M=[.125,.215,.35,.446,.526,.582],Qs=20,Tm=new Mb,XM=new ht;let Am=null;const Ks=(1+Math.sqrt(5))/2,fa=1/Ks,jM=[new se(1,1,1),new se(-1,1,1),new se(1,1,-1),new se(-1,1,-1),new se(0,Ks,fa),new se(0,Ks,-fa),new se(fa,0,Ks),new se(-fa,0,Ks),new se(Ks,fa,0),new se(-Ks,fa,0)];class qM{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,i=.1,r=100){Am=this._renderer.getRenderTarget(),this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(e,i,r,s),t>0&&this._blur(s,0,0,t),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=ZM(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=KM(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(Am),e.scissorTest=!1,Wh(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===fl||e.mapping===pl?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),Am=this._renderer.getRenderTarget();const i=t||this._allocateTargets();return this._textureToCubeUV(e,i),this._applyPMREM(i),this._cleanup(i),i}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,i={magFilter:li,minFilter:li,generateMipmaps:!1,type:du,format:Ui,encoding:Eo,depthBuffer:!1},r=YM(e,t,i);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=YM(e,t,i);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=Kk(s)),this._blurMaterial=Zk(s,e,t)}return r}_compileMaterial(e){const t=new Tr(this._lodPlanes[0],e);this._renderer.compile(t,Tm)}_sceneToCubeUV(e,t,i,r){const a=new Ni(90,1,t,i),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],u=this._renderer,h=u.autoClear,d=u.toneMapping;u.getClearColor(XM),u.toneMapping=Rr,u.autoClear=!1;const p=new Ov({name:"PMREM.Background",side:Hi,depthWrite:!1,depthTest:!1}),v=new Tr(new Tu,p);let m=!1;const f=e.background;f?f.isColor&&(p.color.copy(f),e.background=null,m=!0):(p.color.copy(XM),m=!0);for(let g=0;g<6;g++){const _=g%3;_===0?(a.up.set(0,l[g],0),a.lookAt(c[g],0,0)):_===1?(a.up.set(0,0,l[g]),a.lookAt(0,c[g],0)):(a.up.set(0,l[g],0),a.lookAt(0,0,c[g]));const M=this._cubeSize;Wh(r,_*M,g>2?M:0,M,M),u.setRenderTarget(r),m&&u.render(v,a),u.render(e,a)}v.geometry.dispose(),v.material.dispose(),u.toneMapping=d,u.autoClear=h,e.background=f}_textureToCubeUV(e,t){const i=this._renderer,r=e.mapping===fl||e.mapping===pl;r?(this._cubemapMaterial===null&&(this._cubemapMaterial=ZM()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=KM());const s=r?this._cubemapMaterial:this._equirectMaterial,o=new Tr(this._lodPlanes[0],s),a=s.uniforms;a.envMap.value=e;const l=this._cubeSize;Wh(t,0,0,3*l,2*l),i.setRenderTarget(t),i.render(o,Tm)}_applyPMREM(e){const t=this._renderer,i=t.autoClear;t.autoClear=!1;for(let r=1;r<this._lodPlanes.length;r++){const s=Math.sqrt(this._sigmas[r]*this._sigmas[r]-this._sigmas[r-1]*this._sigmas[r-1]),o=jM[(r-1)%jM.length];this._blur(e,r-1,r,s,o)}t.autoClear=i}_blur(e,t,i,r,s){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,i,r,"latitudinal",s),this._halfBlur(o,e,i,i,r,"longitudinal",s)}_halfBlur(e,t,i,r,s,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,h=new Tr(this._lodPlanes[r],c),d=c.uniforms,p=this._sizeLods[i]-1,v=isFinite(s)?Math.PI/(2*p):2*Math.PI/(2*Qs-1),m=s/v,f=isFinite(s)?1+Math.floor(u*m):Qs;f>Qs&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${f} samples when the maximum is set to ${Qs}`);const g=[];let _=0;for(let R=0;R<Qs;++R){const x=R/m,A=Math.exp(-x*x/2);g.push(A),R===0?_+=A:R<f&&(_+=2*A)}for(let R=0;R<g.length;R++)g[R]=g[R]/_;d.envMap.value=e.texture,d.samples.value=f,d.weights.value=g,d.latitudinal.value=o==="latitudinal",a&&(d.poleAxis.value=a);const{_lodMax:M}=this;d.dTheta.value=v,d.mipInt.value=M-i;const E=this._sizeLods[r],S=3*E*(r>M-Na?r-M+Na:0),T=4*(this._cubeSize-E);Wh(t,S,T,3*E,2*E),l.setRenderTarget(t),l.render(h,Tm)}}function Kk(n){const e=[],t=[],i=[];let r=n;const s=n-Na+1+$M.length;for(let o=0;o<s;o++){const a=Math.pow(2,r);t.push(a);let l=1/a;o>n-Na?l=$M[o-n+Na-1]:o===0&&(l=0),i.push(l);const c=1/(a-2),u=-c,h=1+c,d=[u,u,h,u,h,h,u,u,h,h,u,h],p=6,v=6,m=3,f=2,g=1,_=new Float32Array(m*v*p),M=new Float32Array(f*v*p),E=new Float32Array(g*v*p);for(let T=0;T<p;T++){const R=T%3*2/3-1,x=T>2?0:-1,A=[R,x,0,R+2/3,x,0,R+2/3,x+1,0,R,x,0,R+2/3,x+1,0,R,x+1,0];_.set(A,m*v*T),M.set(d,f*v*T);const I=[T,T,T,T,T,T];E.set(I,g*v*T)}const S=new Us;S.setAttribute("position",new pi(_,m)),S.setAttribute("uv",new pi(M,f)),S.setAttribute("faceIndex",new pi(E,g)),e.push(S),r>Na&&r--}return{lodPlanes:e,sizeLods:t,sigmas:i}}function YM(n,e,t){const i=new Lr(n,e,t);return i.texture.mapping=Tf,i.texture.name="PMREM.cubeUv",i.scissorTest=!0,i}function Wh(n,e,t,i,r){n.viewport.set(e,t,i,r),n.scissor.set(e,t,i,r)}function Zk(n,e,t){const i=new Float32Array(Qs),r=new se(0,1,0);return new Rs({name:"SphericalGaussianBlur",defines:{n:Qs,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:i},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:r}},vertexShader:kv(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:ws,depthTest:!1,depthWrite:!1})}function KM(){return new Rs({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:kv(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:ws,depthTest:!1,depthWrite:!1})}function ZM(){return new Rs({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:kv(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:ws,depthTest:!1,depthWrite:!1})}function kv(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function Jk(n){let e=new WeakMap,t=null;function i(a){if(a&&a.isTexture){const l=a.mapping,c=l===Zg||l===Jg,u=l===fl||l===pl;if(c||u)if(a.isRenderTargetTexture&&a.needsPMREMUpdate===!0){a.needsPMREMUpdate=!1;let h=e.get(a);return t===null&&(t=new qM(n)),h=c?t.fromEquirectangular(a,h):t.fromCubemap(a,h),e.set(a,h),h.texture}else{if(e.has(a))return e.get(a).texture;{const h=a.image;if(c&&h&&h.height>0||u&&h&&r(h)){t===null&&(t=new qM(n));const d=c?t.fromEquirectangular(a):t.fromCubemap(a);return e.set(a,d),a.addEventListener("dispose",s),d.texture}else return null}}}return a}function r(a){let l=0;const c=6;for(let u=0;u<c;u++)a[u]!==void 0&&l++;return l===c}function s(a){const l=a.target;l.removeEventListener("dispose",s);const c=e.get(l);c!==void 0&&(e.delete(l),c.dispose())}function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:i,dispose:o}}function Qk(n){const e={};function t(i){if(e[i]!==void 0)return e[i];let r;switch(i){case"WEBGL_depth_texture":r=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=n.getExtension(i)}return e[i]=r,r}return{has:function(i){return t(i)!==null},init:function(i){i.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(i){const r=t(i);return r===null&&console.warn("THREE.WebGLRenderer: "+i+" extension not supported."),r}}}function e4(n,e,t,i){const r={},s=new WeakMap;function o(h){const d=h.target;d.index!==null&&e.remove(d.index);for(const v in d.attributes)e.remove(d.attributes[v]);d.removeEventListener("dispose",o),delete r[d.id];const p=s.get(d);p&&(e.remove(p),s.delete(d)),i.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}function a(h,d){return r[d.id]===!0||(d.addEventListener("dispose",o),r[d.id]=!0,t.memory.geometries++),d}function l(h){const d=h.attributes;for(const v in d)e.update(d[v],n.ARRAY_BUFFER);const p=h.morphAttributes;for(const v in p){const m=p[v];for(let f=0,g=m.length;f<g;f++)e.update(m[f],n.ARRAY_BUFFER)}}function c(h){const d=[],p=h.index,v=h.attributes.position;let m=0;if(p!==null){const _=p.array;m=p.version;for(let M=0,E=_.length;M<E;M+=3){const S=_[M+0],T=_[M+1],R=_[M+2];d.push(S,T,T,R,R,S)}}else{const _=v.array;m=v.version;for(let M=0,E=_.length/3-1;M<E;M+=3){const S=M+0,T=M+1,R=M+2;d.push(S,T,T,R,R,S)}}const f=new(vb(d)?mb:pb)(d,1);f.version=m;const g=s.get(h);g&&e.remove(g),s.set(h,f)}function u(h){const d=s.get(h);if(d){const p=h.index;p!==null&&d.version<p.version&&c(h)}else c(h);return s.get(h)}return{get:a,update:l,getWireframeAttribute:u}}function t4(n,e,t,i){const r=i.isWebGL2;let s;function o(d){s=d}let a,l;function c(d){a=d.type,l=d.bytesPerElement}function u(d,p){n.drawElements(s,p,a,d*l),t.update(p,s,1)}function h(d,p,v){if(v===0)return;let m,f;if(r)m=n,f="drawElementsInstanced";else if(m=e.get("ANGLE_instanced_arrays"),f="drawElementsInstancedANGLE",m===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[f](s,p,a,d*l,v),t.update(p,s,v)}this.setMode=o,this.setIndex=c,this.render=u,this.renderInstances=h}function n4(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function i(s,o,a){switch(t.calls++,o){case n.TRIANGLES:t.triangles+=a*(s/3);break;case n.LINES:t.lines+=a*(s/2);break;case n.LINE_STRIP:t.lines+=a*(s-1);break;case n.LINE_LOOP:t.lines+=a*s;break;case n.POINTS:t.points+=a*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function r(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:r,update:i}}class Hv extends _i{constructor(e=null,t=1,i=1,r=1){super(null),this.image={data:e,width:t,height:i,depth:r},this.magFilter=Nn,this.minFilter=Nn,this.wrapR=Fi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}Hv.prototype.isDataArrayTexture=!0;function i4(n,e){return n[0]-e[0]}function r4(n,e){return Math.abs(e[1])-Math.abs(n[1])}function Cm(n,e){let t=1;const i=e.isInterleavedBufferAttribute?e.data.array:e.array;i instanceof Int8Array?t=127:i instanceof Int16Array?t=32767:i instanceof Int32Array?t=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",i),n.divideScalar(t)}function s4(n,e,t){const i={},r=new Float32Array(8),s=new WeakMap,o=new _n,a=[];for(let c=0;c<8;c++)a[c]=[c,0];function l(c,u,h,d){const p=c.morphTargetInfluences;if(e.isWebGL2===!0){const m=u.morphAttributes.position||u.morphAttributes.normal||u.morphAttributes.color,f=m!==void 0?m.length:0;let g=s.get(u);if(g===void 0||g.count!==f){let z=function(){L.dispose(),s.delete(u),u.removeEventListener("dispose",z)};var v=z;g!==void 0&&g.texture.dispose();const E=u.morphAttributes.position!==void 0,S=u.morphAttributes.normal!==void 0,T=u.morphAttributes.color!==void 0,R=u.morphAttributes.position||[],x=u.morphAttributes.normal||[],A=u.morphAttributes.color||[];let I=0;E===!0&&(I=1),S===!0&&(I=2),T===!0&&(I=3);let N=u.attributes.position.count*I,J=1;N>e.maxTextureSize&&(J=Math.ceil(N/e.maxTextureSize),N=e.maxTextureSize);const q=new Float32Array(N*J*4*f),L=new Hv(q,N,J,f);L.type=ro,L.needsUpdate=!0;const $=I*4;for(let W=0;W<f;W++){const U=R[W],P=x[W],k=A[W],Y=N*J*4*W;for(let j=0;j<U.count;j++){const K=j*$;E===!0&&(o.fromBufferAttribute(U,j),U.normalized===!0&&Cm(o,U),q[Y+K+0]=o.x,q[Y+K+1]=o.y,q[Y+K+2]=o.z,q[Y+K+3]=0),S===!0&&(o.fromBufferAttribute(P,j),P.normalized===!0&&Cm(o,P),q[Y+K+4]=o.x,q[Y+K+5]=o.y,q[Y+K+6]=o.z,q[Y+K+7]=0),T===!0&&(o.fromBufferAttribute(k,j),k.normalized===!0&&Cm(o,k),q[Y+K+8]=o.x,q[Y+K+9]=o.y,q[Y+K+10]=o.z,q[Y+K+11]=k.itemSize===4?o.w:1)}}g={count:f,texture:L,size:new mt(N,J)},s.set(u,g),u.addEventListener("dispose",z)}let _=0;for(let E=0;E<p.length;E++)_+=p[E];const M=u.morphTargetsRelative?1:1-_;d.getUniforms().setValue(n,"morphTargetBaseInfluence",M),d.getUniforms().setValue(n,"morphTargetInfluences",p),d.getUniforms().setValue(n,"morphTargetsTexture",g.texture,t),d.getUniforms().setValue(n,"morphTargetsTextureSize",g.size)}else{const m=p===void 0?0:p.length;let f=i[u.id];if(f===void 0||f.length!==m){f=[];for(let S=0;S<m;S++)f[S]=[S,0];i[u.id]=f}for(let S=0;S<m;S++){const T=f[S];T[0]=S,T[1]=p[S]}f.sort(r4);for(let S=0;S<8;S++)S<m&&f[S][1]?(a[S][0]=f[S][0],a[S][1]=f[S][1]):(a[S][0]=Number.MAX_SAFE_INTEGER,a[S][1]=0);a.sort(i4);const g=u.morphAttributes.position,_=u.morphAttributes.normal;let M=0;for(let S=0;S<8;S++){const T=a[S],R=T[0],x=T[1];R!==Number.MAX_SAFE_INTEGER&&x?(g&&u.getAttribute("morphTarget"+S)!==g[R]&&u.setAttribute("morphTarget"+S,g[R]),_&&u.getAttribute("morphNormal"+S)!==_[R]&&u.setAttribute("morphNormal"+S,_[R]),r[S]=x,M+=x):(g&&u.hasAttribute("morphTarget"+S)===!0&&u.deleteAttribute("morphTarget"+S),_&&u.hasAttribute("morphNormal"+S)===!0&&u.deleteAttribute("morphNormal"+S),r[S]=0)}const E=u.morphTargetsRelative?1:1-M;d.getUniforms().setValue(n,"morphTargetBaseInfluence",E),d.getUniforms().setValue(n,"morphTargetInfluences",r)}}return{update:l}}function o4(n,e,t,i){let r=new WeakMap;function s(l){const c=i.render.frame,u=l.geometry,h=e.get(l,u);return r.get(h)!==c&&(e.update(h),r.set(h,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),t.update(l.instanceMatrix,n.ARRAY_BUFFER),l.instanceColor!==null&&t.update(l.instanceColor,n.ARRAY_BUFFER)),h}function o(){r=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:s,dispose:o}}class Sb extends _i{constructor(e=null,t=1,i=1,r=1){super(null),this.image={data:e,width:t,height:i,depth:r},this.magFilter=Nn,this.minFilter=Nn,this.wrapR=Fi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}Sb.prototype.isData3DTexture=!0;const wb=new _i,Eb=new Hv,bb=new Sb,Tb=new zv,JM=[],QM=[],eS=new Float32Array(16),tS=new Float32Array(9),nS=new Float32Array(4);function Fl(n,e,t){const i=n[0];if(i<=0||i>0)return n;const r=e*t;let s=JM[r];if(s===void 0&&(s=new Float32Array(r),JM[r]=s),e!==0){i.toArray(s,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(s,a)}return s}function Rn(n,e){if(n.length!==e.length)return!1;for(let t=0,i=n.length;t<i;t++)if(n[t]!==e[t])return!1;return!0}function Ln(n,e){for(let t=0,i=e.length;t<i;t++)n[t]=e[t]}function Cf(n,e){let t=QM[e];t===void 0&&(t=new Int32Array(e),QM[e]=t);for(let i=0;i!==e;++i)t[i]=n.allocateTextureUnit();return t}function a4(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function l4(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Rn(t,e))return;n.uniform2fv(this.addr,e),Ln(t,e)}}function c4(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Rn(t,e))return;n.uniform3fv(this.addr,e),Ln(t,e)}}function u4(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Rn(t,e))return;n.uniform4fv(this.addr,e),Ln(t,e)}}function h4(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(Rn(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Ln(t,e)}else{if(Rn(t,i))return;nS.set(i),n.uniformMatrix2fv(this.addr,!1,nS),Ln(t,i)}}function d4(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(Rn(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Ln(t,e)}else{if(Rn(t,i))return;tS.set(i),n.uniformMatrix3fv(this.addr,!1,tS),Ln(t,i)}}function f4(n,e){const t=this.cache,i=e.elements;if(i===void 0){if(Rn(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Ln(t,e)}else{if(Rn(t,i))return;eS.set(i),n.uniformMatrix4fv(this.addr,!1,eS),Ln(t,i)}}function p4(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function m4(n,e){const t=this.cache;Rn(t,e)||(n.uniform2iv(this.addr,e),Ln(t,e))}function g4(n,e){const t=this.cache;Rn(t,e)||(n.uniform3iv(this.addr,e),Ln(t,e))}function v4(n,e){const t=this.cache;Rn(t,e)||(n.uniform4iv(this.addr,e),Ln(t,e))}function _4(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function x4(n,e){const t=this.cache;Rn(t,e)||(n.uniform2uiv(this.addr,e),Ln(t,e))}function y4(n,e){const t=this.cache;Rn(t,e)||(n.uniform3uiv(this.addr,e),Ln(t,e))}function M4(n,e){const t=this.cache;Rn(t,e)||(n.uniform4uiv(this.addr,e),Ln(t,e))}function S4(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTexture2D(e||wb,r)}function w4(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTexture3D(e||bb,r)}function E4(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTextureCube(e||Tb,r)}function b4(n,e,t){const i=this.cache,r=t.allocateTextureUnit();i[0]!==r&&(n.uniform1i(this.addr,r),i[0]=r),t.setTexture2DArray(e||Eb,r)}function T4(n){switch(n){case 5126:return a4;case 35664:return l4;case 35665:return c4;case 35666:return u4;case 35674:return h4;case 35675:return d4;case 35676:return f4;case 5124:case 35670:return p4;case 35667:case 35671:return m4;case 35668:case 35672:return g4;case 35669:case 35673:return v4;case 5125:return _4;case 36294:return x4;case 36295:return y4;case 36296:return M4;case 35678:case 36198:case 36298:case 36306:case 35682:return S4;case 35679:case 36299:case 36307:return w4;case 35680:case 36300:case 36308:case 36293:return E4;case 36289:case 36303:case 36311:case 36292:return b4}}function A4(n,e){n.uniform1fv(this.addr,e)}function C4(n,e){const t=Fl(e,this.size,2);n.uniform2fv(this.addr,t)}function R4(n,e){const t=Fl(e,this.size,3);n.uniform3fv(this.addr,t)}function L4(n,e){const t=Fl(e,this.size,4);n.uniform4fv(this.addr,t)}function P4(n,e){const t=Fl(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function D4(n,e){const t=Fl(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function I4(n,e){const t=Fl(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function N4(n,e){n.uniform1iv(this.addr,e)}function F4(n,e){n.uniform2iv(this.addr,e)}function U4(n,e){n.uniform3iv(this.addr,e)}function O4(n,e){n.uniform4iv(this.addr,e)}function B4(n,e){n.uniform1uiv(this.addr,e)}function z4(n,e){n.uniform2uiv(this.addr,e)}function k4(n,e){n.uniform3uiv(this.addr,e)}function H4(n,e){n.uniform4uiv(this.addr,e)}function G4(n,e,t){const i=e.length,r=Cf(t,i);n.uniform1iv(this.addr,r);for(let s=0;s!==i;++s)t.setTexture2D(e[s]||wb,r[s])}function V4(n,e,t){const i=e.length,r=Cf(t,i);n.uniform1iv(this.addr,r);for(let s=0;s!==i;++s)t.setTexture3D(e[s]||bb,r[s])}function W4(n,e,t){const i=e.length,r=Cf(t,i);n.uniform1iv(this.addr,r);for(let s=0;s!==i;++s)t.setTextureCube(e[s]||Tb,r[s])}function $4(n,e,t){const i=e.length,r=Cf(t,i);n.uniform1iv(this.addr,r);for(let s=0;s!==i;++s)t.setTexture2DArray(e[s]||Eb,r[s])}function X4(n){switch(n){case 5126:return A4;case 35664:return C4;case 35665:return R4;case 35666:return L4;case 35674:return P4;case 35675:return D4;case 35676:return I4;case 5124:case 35670:return N4;case 35667:case 35671:return F4;case 35668:case 35672:return U4;case 35669:case 35673:return O4;case 5125:return B4;case 36294:return z4;case 36295:return k4;case 36296:return H4;case 35678:case 36198:case 36298:case 36306:case 35682:return G4;case 35679:case 36299:case 36307:return V4;case 35680:case 36300:case 36308:case 36293:return W4;case 36289:case 36303:case 36311:case 36292:return $4}}function j4(n,e,t){this.id=n,this.addr=t,this.cache=[],this.setValue=T4(e.type)}function q4(n,e,t){this.id=n,this.addr=t,this.cache=[],this.size=e.size,this.setValue=X4(e.type)}function Ab(n){this.id=n,this.seq=[],this.map={}}Ab.prototype.setValue=function(n,e,t){const i=this.seq;for(let r=0,s=i.length;r!==s;++r){const o=i[r];o.setValue(n,e[o.id],t)}};const Rm=/(\w+)(\])?(\[|\.)?/g;function iS(n,e){n.seq.push(e),n.map[e.id]=e}function Y4(n,e,t){const i=n.name,r=i.length;for(Rm.lastIndex=0;;){const s=Rm.exec(i),o=Rm.lastIndex;let a=s[1];const l=s[2]==="]",c=s[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===r){iS(t,c===void 0?new j4(a,n,e):new q4(a,n,e));break}else{let h=t.map[a];h===void 0&&(h=new Ab(a),iS(t,h)),t=h}}}function Es(n,e){this.seq=[],this.map={};const t=n.getProgramParameter(e,n.ACTIVE_UNIFORMS);for(let i=0;i<t;++i){const r=n.getActiveUniform(e,i),s=n.getUniformLocation(e,r.name);Y4(r,s,this)}}Es.prototype.setValue=function(n,e,t,i){const r=this.map[e];r!==void 0&&r.setValue(n,t,i)};Es.prototype.setOptional=function(n,e,t){const i=e[t];i!==void 0&&this.setValue(n,t,i)};Es.upload=function(n,e,t,i){for(let r=0,s=e.length;r!==s;++r){const o=e[r],a=t[o.id];a.needsUpdate!==!1&&o.setValue(n,a.value,i)}};Es.seqWithValue=function(n,e){const t=[];for(let i=0,r=n.length;i!==r;++i){const s=n[i];s.id in e&&t.push(s)}return t};function rS(n,e,t){const i=n.createShader(e);return n.shaderSource(i,t),n.compileShader(i),i}let K4=0;function Z4(n,e){const t=n.split(`
`),i=[],r=Math.max(e-6,0),s=Math.min(e+6,t.length);for(let o=r;o<s;o++)i.push(o+1+": "+t[o]);return i.join(`
`)}function J4(n){switch(n){case Eo:return["Linear","( value )"];case St:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",n),["Linear","( value )"]}}function sS(n,e,t){const i=n.getShaderParameter(e,n.COMPILE_STATUS),r=n.getShaderInfoLog(e).trim();if(i&&r==="")return"";const s=/ERROR: 0:(\d+)/.exec(r);if(s){const o=parseInt(s[0]);return t.toUpperCase()+`

`+r+`

`+Z4(n.getShaderSource(e),o)}else return r}function Q4(n,e){const t=J4(e);return"vec4 "+n+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function eH(n,e){let t;switch(e){case EO:t="Linear";break;case bO:t="Reinhard";break;case TO:t="OptimizedCineon";break;case AO:t="ACESFilmic";break;case CO:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function tH(n){return[n.extensionDerivatives||!!n.envMapCubeUVHeight||n.bumpMap||n.tangentSpaceNormalMap||n.clearcoatNormalMap||n.flatShading||n.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap||n.transmission)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(_c).join(`
`)}function nH(n){const e=[];for(const t in n){const i=n[t];i!==!1&&e.push("#define "+t+" "+i)}return e.join(`
`)}function iH(n,e){const t={},i=n.getProgramParameter(e,n.ACTIVE_ATTRIBUTES);for(let r=0;r<i;r++){const s=n.getActiveAttrib(e,r),o=s.name;let a=1;s.type===n.FLOAT_MAT2&&(a=2),s.type===n.FLOAT_MAT3&&(a=3),s.type===n.FLOAT_MAT4&&(a=4),t[o]={type:s.type,location:n.getAttribLocation(e,o),locationSize:a}}return t}function _c(n){return n!==""}function oS(n,e){return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function aS(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const rH=/^[ \t]*#include +<([\w\d./]+)>/gm;function i0(n){return n.replace(rH,sH)}function sH(n,e){const t=Ke[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return i0(t)}const oH=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,aH=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function lS(n){return n.replace(aH,Cb).replace(oH,lH)}function lH(n,e,t,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Cb(n,e,t,i)}function Cb(n,e,t,i){let r="";for(let s=parseInt(e);s<parseInt(t);s++)r+=i.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return r}function cS(n){let e="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function cH(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===ob?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===tO?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===vc&&(e="SHADOWMAP_TYPE_VSM"),e}function uH(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case fl:case pl:e="ENVMAP_TYPE_CUBE";break;case Tf:e="ENVMAP_TYPE_CUBE_UV";break}return e}function hH(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case pl:e="ENVMAP_MODE_REFRACTION";break}return e}function dH(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case cb:e="ENVMAP_BLENDING_MULTIPLY";break;case SO:e="ENVMAP_BLENDING_MIX";break;case wO:e="ENVMAP_BLENDING_ADD";break}return e}function fH(n){const e=n.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,i=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:i,maxMip:t}}function pH(n,e,t,i){const r=n.getContext(),s=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=cH(t),c=uH(t),u=hH(t),h=dH(t),d=fH(t),p=t.isWebGL2?"":tH(t),v=nH(s),m=r.createProgram();let f,g,_=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(f=[v].filter(_c).join(`
`),f.length>0&&(f+=`
`),g=[p,v].filter(_c).join(`
`),g.length>0&&(g+=`
`)):(f=[cS(t),"#define SHADER_NAME "+t.shaderName,v,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(_c).join(`
`),g=[p,cS(t),"#define SHADER_NAME "+t.shaderName,v,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+u:"",t.envMap?"#define "+h:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Rr?"#define TONE_MAPPING":"",t.toneMapping!==Rr?Ke.tonemapping_pars_fragment:"",t.toneMapping!==Rr?eH("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",Ke.encodings_pars_fragment,Q4("linearToOutputTexel",t.outputEncoding),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(_c).join(`
`)),o=i0(o),o=oS(o,t),o=aS(o,t),a=i0(a),a=oS(a,t),a=aS(a,t),o=lS(o),a=lS(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(_=`#version 300 es
`,f=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+f,g=["#define varying in",t.glslVersion===PM?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===PM?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+g);const M=_+f+o,E=_+g+a,S=rS(r,r.VERTEX_SHADER,M),T=rS(r,r.FRAGMENT_SHADER,E);if(r.attachShader(m,S),r.attachShader(m,T),t.index0AttributeName!==void 0?r.bindAttribLocation(m,0,t.index0AttributeName):t.morphTargets===!0&&r.bindAttribLocation(m,0,"position"),r.linkProgram(m),n.debug.checkShaderErrors){const A=r.getProgramInfoLog(m).trim(),I=r.getShaderInfoLog(S).trim(),N=r.getShaderInfoLog(T).trim();let J=!0,q=!0;if(r.getProgramParameter(m,r.LINK_STATUS)===!1){J=!1;const L=sS(r,S,"vertex"),$=sS(r,T,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(m,r.VALIDATE_STATUS)+`

Program Info Log: `+A+`
`+L+`
`+$)}else A!==""?console.warn("THREE.WebGLProgram: Program Info Log:",A):(I===""||N==="")&&(q=!1);q&&(this.diagnostics={runnable:J,programLog:A,vertexShader:{log:I,prefix:f},fragmentShader:{log:N,prefix:g}})}r.deleteShader(S),r.deleteShader(T);let R;this.getUniforms=function(){return R===void 0&&(R=new Es(r,m)),R};let x;return this.getAttributes=function(){return x===void 0&&(x=iH(r,m)),x},this.destroy=function(){i.releaseStatesOfProgram(this),r.deleteProgram(m),this.program=void 0},this.name=t.shaderName,this.id=K4++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=S,this.fragmentShader=T,this}let mH=0;class gH{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,i=e.fragmentShader,r=this._getShaderStage(t),s=this._getShaderStage(i),o=this._getShaderCacheForMaterial(e);return o.has(r)===!1&&(o.add(r),r.usedTimes++),o.has(s)===!1&&(o.add(s),s.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const i of t)i.usedTimes--,i.usedTimes===0&&this.shaderCache.delete(i.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;return t.has(e)===!1&&t.set(e,new Set),t.get(e)}_getShaderStage(e){const t=this.shaderCache;if(t.has(e)===!1){const i=new vH(e);t.set(e,i)}return t.get(e)}}class vH{constructor(e){this.id=mH++,this.code=e,this.usedTimes=0}}function _H(n,e,t,i,r,s,o){const a=new gb,l=new gH,c=[],u=r.isWebGL2,h=r.logarithmicDepthBuffer,d=r.vertexTextures;let p=r.precision;const v={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function m(x,A,I,N,J){const q=N.fog,L=J.geometry,$=x.isMeshStandardMaterial?N.environment:null,z=(x.isMeshStandardMaterial?t:e).get(x.envMap||$),W=!!z&&z.mapping===Tf?z.image.height:null,U=v[x.type];x.precision!==null&&(p=r.getMaxPrecision(x.precision),p!==x.precision&&console.warn("THREE.WebGLProgram.getParameters:",x.precision,"not supported, using",p,"instead."));const P=L.morphAttributes.position||L.morphAttributes.normal||L.morphAttributes.color,k=P!==void 0?P.length:0;let Y=0;L.morphAttributes.position!==void 0&&(Y=1),L.morphAttributes.normal!==void 0&&(Y=2),L.morphAttributes.color!==void 0&&(Y=3);let j,K,ce,de;if(U){const re=Ki[U];j=re.vertexShader,K=re.fragmentShader}else j=x.vertexShader,K=x.fragmentShader,l.update(x),ce=l.getVertexShaderID(x),de=l.getFragmentShaderID(x);const F=n.getRenderTarget(),We=x.alphaTest>0,Me=x.clearcoat>0;return{isWebGL2:u,shaderID:U,shaderName:x.type,vertexShader:j,fragmentShader:K,defines:x.defines,customVertexShaderID:ce,customFragmentShaderID:de,isRawShaderMaterial:x.isRawShaderMaterial===!0,glslVersion:x.glslVersion,precision:p,instancing:J.isInstancedMesh===!0,instancingColor:J.isInstancedMesh===!0&&J.instanceColor!==null,supportsVertexTextures:d,outputEncoding:F===null?n.outputEncoding:F.isXRRenderTarget===!0?F.texture.encoding:Eo,map:!!x.map,matcap:!!x.matcap,envMap:!!z,envMapMode:z&&z.mapping,envMapCubeUVHeight:W,lightMap:!!x.lightMap,aoMap:!!x.aoMap,emissiveMap:!!x.emissiveMap,bumpMap:!!x.bumpMap,normalMap:!!x.normalMap,objectSpaceNormalMap:x.normalMapType===qO,tangentSpaceNormalMap:x.normalMapType===jO,decodeVideoTexture:!!x.map&&x.map.isVideoTexture===!0&&x.map.encoding===St,clearcoat:Me,clearcoatMap:Me&&!!x.clearcoatMap,clearcoatRoughnessMap:Me&&!!x.clearcoatRoughnessMap,clearcoatNormalMap:Me&&!!x.clearcoatNormalMap,displacementMap:!!x.displacementMap,roughnessMap:!!x.roughnessMap,metalnessMap:!!x.metalnessMap,specularMap:!!x.specularMap,specularIntensityMap:!!x.specularIntensityMap,specularColorMap:!!x.specularColorMap,opaque:x.transparent===!1&&x.blending===Va,alphaMap:!!x.alphaMap,alphaTest:We,gradientMap:!!x.gradientMap,sheen:x.sheen>0,sheenColorMap:!!x.sheenColorMap,sheenRoughnessMap:!!x.sheenRoughnessMap,transmission:x.transmission>0,transmissionMap:!!x.transmissionMap,thicknessMap:!!x.thicknessMap,combine:x.combine,vertexTangents:!!x.normalMap&&!!L.attributes.tangent,vertexColors:x.vertexColors,vertexAlphas:x.vertexColors===!0&&!!L.attributes.color&&L.attributes.color.itemSize===4,vertexUvs:!!x.map||!!x.bumpMap||!!x.normalMap||!!x.specularMap||!!x.alphaMap||!!x.emissiveMap||!!x.roughnessMap||!!x.metalnessMap||!!x.clearcoatMap||!!x.clearcoatRoughnessMap||!!x.clearcoatNormalMap||!!x.displacementMap||!!x.transmissionMap||!!x.thicknessMap||!!x.specularIntensityMap||!!x.specularColorMap||!!x.sheenColorMap||!!x.sheenRoughnessMap,uvsVertexOnly:!(!!x.map||!!x.bumpMap||!!x.normalMap||!!x.specularMap||!!x.alphaMap||!!x.emissiveMap||!!x.roughnessMap||!!x.metalnessMap||!!x.clearcoatNormalMap||x.transmission>0||!!x.transmissionMap||!!x.thicknessMap||!!x.specularIntensityMap||!!x.specularColorMap||x.sheen>0||!!x.sheenColorMap||!!x.sheenRoughnessMap)&&!!x.displacementMap,fog:!!q,useFog:x.fog===!0,fogExp2:q&&q.isFogExp2,flatShading:!!x.flatShading,sizeAttenuation:x.sizeAttenuation,logarithmicDepthBuffer:h,skinning:J.isSkinnedMesh===!0,morphTargets:L.morphAttributes.position!==void 0,morphNormals:L.morphAttributes.normal!==void 0,morphColors:L.morphAttributes.color!==void 0,morphTargetsCount:k,morphTextureStride:Y,numDirLights:A.directional.length,numPointLights:A.point.length,numSpotLights:A.spot.length,numRectAreaLights:A.rectArea.length,numHemiLights:A.hemi.length,numDirLightShadows:A.directionalShadowMap.length,numPointLightShadows:A.pointShadowMap.length,numSpotLightShadows:A.spotShadowMap.length,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:x.dithering,shadowMapEnabled:n.shadowMap.enabled&&I.length>0,shadowMapType:n.shadowMap.type,toneMapping:x.toneMapped?n.toneMapping:Rr,physicallyCorrectLights:n.physicallyCorrectLights,premultipliedAlpha:x.premultipliedAlpha,doubleSided:x.side===dl,flipSided:x.side===Hi,useDepthPacking:!!x.depthPacking,depthPacking:x.depthPacking||0,index0AttributeName:x.index0AttributeName,extensionDerivatives:x.extensions&&x.extensions.derivatives,extensionFragDepth:x.extensions&&x.extensions.fragDepth,extensionDrawBuffers:x.extensions&&x.extensions.drawBuffers,extensionShaderTextureLOD:x.extensions&&x.extensions.shaderTextureLOD,rendererExtensionFragDepth:u||i.has("EXT_frag_depth"),rendererExtensionDrawBuffers:u||i.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:u||i.has("EXT_shader_texture_lod"),customProgramCacheKey:x.customProgramCacheKey()}}function f(x){const A=[];if(x.shaderID?A.push(x.shaderID):(A.push(x.customVertexShaderID),A.push(x.customFragmentShaderID)),x.defines!==void 0)for(const I in x.defines)A.push(I),A.push(x.defines[I]);return x.isRawShaderMaterial===!1&&(g(A,x),_(A,x),A.push(n.outputEncoding)),A.push(x.customProgramCacheKey),A.join()}function g(x,A){x.push(A.precision),x.push(A.outputEncoding),x.push(A.envMapMode),x.push(A.envMapCubeUVHeight),x.push(A.combine),x.push(A.vertexUvs),x.push(A.fogExp2),x.push(A.sizeAttenuation),x.push(A.morphTargetsCount),x.push(A.morphAttributeCount),x.push(A.numDirLights),x.push(A.numPointLights),x.push(A.numSpotLights),x.push(A.numHemiLights),x.push(A.numRectAreaLights),x.push(A.numDirLightShadows),x.push(A.numPointLightShadows),x.push(A.numSpotLightShadows),x.push(A.shadowMapType),x.push(A.toneMapping),x.push(A.numClippingPlanes),x.push(A.numClipIntersection),x.push(A.depthPacking)}function _(x,A){a.disableAll(),A.isWebGL2&&a.enable(0),A.supportsVertexTextures&&a.enable(1),A.instancing&&a.enable(2),A.instancingColor&&a.enable(3),A.map&&a.enable(4),A.matcap&&a.enable(5),A.envMap&&a.enable(6),A.lightMap&&a.enable(7),A.aoMap&&a.enable(8),A.emissiveMap&&a.enable(9),A.bumpMap&&a.enable(10),A.normalMap&&a.enable(11),A.objectSpaceNormalMap&&a.enable(12),A.tangentSpaceNormalMap&&a.enable(13),A.clearcoat&&a.enable(14),A.clearcoatMap&&a.enable(15),A.clearcoatRoughnessMap&&a.enable(16),A.clearcoatNormalMap&&a.enable(17),A.displacementMap&&a.enable(18),A.specularMap&&a.enable(19),A.roughnessMap&&a.enable(20),A.metalnessMap&&a.enable(21),A.gradientMap&&a.enable(22),A.alphaMap&&a.enable(23),A.alphaTest&&a.enable(24),A.vertexColors&&a.enable(25),A.vertexAlphas&&a.enable(26),A.vertexUvs&&a.enable(27),A.vertexTangents&&a.enable(28),A.uvsVertexOnly&&a.enable(29),A.fog&&a.enable(30),x.push(a.mask),a.disableAll(),A.useFog&&a.enable(0),A.flatShading&&a.enable(1),A.logarithmicDepthBuffer&&a.enable(2),A.skinning&&a.enable(3),A.morphTargets&&a.enable(4),A.morphNormals&&a.enable(5),A.morphColors&&a.enable(6),A.premultipliedAlpha&&a.enable(7),A.shadowMapEnabled&&a.enable(8),A.physicallyCorrectLights&&a.enable(9),A.doubleSided&&a.enable(10),A.flipSided&&a.enable(11),A.useDepthPacking&&a.enable(12),A.dithering&&a.enable(13),A.specularIntensityMap&&a.enable(14),A.specularColorMap&&a.enable(15),A.transmission&&a.enable(16),A.transmissionMap&&a.enable(17),A.thicknessMap&&a.enable(18),A.sheen&&a.enable(19),A.sheenColorMap&&a.enable(20),A.sheenRoughnessMap&&a.enable(21),A.decodeVideoTexture&&a.enable(22),A.opaque&&a.enable(23),x.push(a.mask)}function M(x){const A=v[x.type];let I;if(A){const N=Ki[A];I=uB.clone(N.uniforms)}else I=x.uniforms;return I}function E(x,A){let I;for(let N=0,J=c.length;N<J;N++){const q=c[N];if(q.cacheKey===A){I=q,++I.usedTimes;break}}return I===void 0&&(I=new pH(n,A,x,s),c.push(I)),I}function S(x){if(--x.usedTimes===0){const A=c.indexOf(x);c[A]=c[c.length-1],c.pop(),x.destroy()}}function T(x){l.remove(x)}function R(){l.dispose()}return{getParameters:m,getProgramCacheKey:f,getUniforms:M,acquireProgram:E,releaseProgram:S,releaseShaderCache:T,programs:c,dispose:R}}function xH(){let n=new WeakMap;function e(s){let o=n.get(s);return o===void 0&&(o={},n.set(s,o)),o}function t(s){n.delete(s)}function i(s,o,a){n.get(s)[o]=a}function r(){n=new WeakMap}return{get:e,remove:t,update:i,dispose:r}}function yH(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function uS(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function hS(){const n=[];let e=0;const t=[],i=[],r=[];function s(){e=0,t.length=0,i.length=0,r.length=0}function o(h,d,p,v,m,f){let g=n[e];return g===void 0?(g={id:h.id,object:h,geometry:d,material:p,groupOrder:v,renderOrder:h.renderOrder,z:m,group:f},n[e]=g):(g.id=h.id,g.object=h,g.geometry=d,g.material=p,g.groupOrder=v,g.renderOrder=h.renderOrder,g.z=m,g.group=f),e++,g}function a(h,d,p,v,m,f){const g=o(h,d,p,v,m,f);p.transmission>0?i.push(g):p.transparent===!0?r.push(g):t.push(g)}function l(h,d,p,v,m,f){const g=o(h,d,p,v,m,f);p.transmission>0?i.unshift(g):p.transparent===!0?r.unshift(g):t.unshift(g)}function c(h,d){t.length>1&&t.sort(h||yH),i.length>1&&i.sort(d||uS),r.length>1&&r.sort(d||uS)}function u(){for(let h=e,d=n.length;h<d;h++){const p=n[h];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.group=null}}return{opaque:t,transmissive:i,transparent:r,init:s,push:a,unshift:l,finish:u,sort:c}}function MH(){let n=new WeakMap;function e(i,r){let s;return n.has(i)===!1?(s=new hS,n.set(i,[s])):r>=n.get(i).length?(s=new hS,n.get(i).push(s)):s=n.get(i)[r],s}function t(){n=new WeakMap}return{get:e,dispose:t}}function SH(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new se,color:new ht};break;case"SpotLight":t={position:new se,direction:new se,color:new ht,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new se,color:new ht,distance:0,decay:0};break;case"HemisphereLight":t={direction:new se,skyColor:new ht,groundColor:new ht};break;case"RectAreaLight":t={color:new ht,position:new se,halfWidth:new se,halfHeight:new se};break}return n[e.id]=t,t}}}function wH(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new mt};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new mt};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new mt,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let EH=0;function bH(n,e){return(e.castShadow?1:0)-(n.castShadow?1:0)}function TH(n,e){const t=new SH,i=wH(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let u=0;u<9;u++)r.probe.push(new se);const s=new se,o=new ln,a=new ln;function l(u,h){let d=0,p=0,v=0;for(let A=0;A<9;A++)r.probe[A].set(0,0,0);let m=0,f=0,g=0,_=0,M=0,E=0,S=0,T=0;u.sort(bH);const R=h!==!0?Math.PI:1;for(let A=0,I=u.length;A<I;A++){const N=u[A],J=N.color,q=N.intensity,L=N.distance,$=N.shadow&&N.shadow.map?N.shadow.map.texture:null;if(N.isAmbientLight)d+=J.r*q*R,p+=J.g*q*R,v+=J.b*q*R;else if(N.isLightProbe)for(let z=0;z<9;z++)r.probe[z].addScaledVector(N.sh.coefficients[z],q);else if(N.isDirectionalLight){const z=t.get(N);if(z.color.copy(N.color).multiplyScalar(N.intensity*R),N.castShadow){const W=N.shadow,U=i.get(N);U.shadowBias=W.bias,U.shadowNormalBias=W.normalBias,U.shadowRadius=W.radius,U.shadowMapSize=W.mapSize,r.directionalShadow[m]=U,r.directionalShadowMap[m]=$,r.directionalShadowMatrix[m]=N.shadow.matrix,E++}r.directional[m]=z,m++}else if(N.isSpotLight){const z=t.get(N);if(z.position.setFromMatrixPosition(N.matrixWorld),z.color.copy(J).multiplyScalar(q*R),z.distance=L,z.coneCos=Math.cos(N.angle),z.penumbraCos=Math.cos(N.angle*(1-N.penumbra)),z.decay=N.decay,N.castShadow){const W=N.shadow,U=i.get(N);U.shadowBias=W.bias,U.shadowNormalBias=W.normalBias,U.shadowRadius=W.radius,U.shadowMapSize=W.mapSize,r.spotShadow[g]=U,r.spotShadowMap[g]=$,r.spotShadowMatrix[g]=N.shadow.matrix,T++}r.spot[g]=z,g++}else if(N.isRectAreaLight){const z=t.get(N);z.color.copy(J).multiplyScalar(q),z.halfWidth.set(N.width*.5,0,0),z.halfHeight.set(0,N.height*.5,0),r.rectArea[_]=z,_++}else if(N.isPointLight){const z=t.get(N);if(z.color.copy(N.color).multiplyScalar(N.intensity*R),z.distance=N.distance,z.decay=N.decay,N.castShadow){const W=N.shadow,U=i.get(N);U.shadowBias=W.bias,U.shadowNormalBias=W.normalBias,U.shadowRadius=W.radius,U.shadowMapSize=W.mapSize,U.shadowCameraNear=W.camera.near,U.shadowCameraFar=W.camera.far,r.pointShadow[f]=U,r.pointShadowMap[f]=$,r.pointShadowMatrix[f]=N.shadow.matrix,S++}r.point[f]=z,f++}else if(N.isHemisphereLight){const z=t.get(N);z.skyColor.copy(N.color).multiplyScalar(q*R),z.groundColor.copy(N.groundColor).multiplyScalar(q*R),r.hemi[M]=z,M++}}_>0&&(e.isWebGL2||n.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=Pe.LTC_FLOAT_1,r.rectAreaLTC2=Pe.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(r.rectAreaLTC1=Pe.LTC_HALF_1,r.rectAreaLTC2=Pe.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=d,r.ambient[1]=p,r.ambient[2]=v;const x=r.hash;(x.directionalLength!==m||x.pointLength!==f||x.spotLength!==g||x.rectAreaLength!==_||x.hemiLength!==M||x.numDirectionalShadows!==E||x.numPointShadows!==S||x.numSpotShadows!==T)&&(r.directional.length=m,r.spot.length=g,r.rectArea.length=_,r.point.length=f,r.hemi.length=M,r.directionalShadow.length=E,r.directionalShadowMap.length=E,r.pointShadow.length=S,r.pointShadowMap.length=S,r.spotShadow.length=T,r.spotShadowMap.length=T,r.directionalShadowMatrix.length=E,r.pointShadowMatrix.length=S,r.spotShadowMatrix.length=T,x.directionalLength=m,x.pointLength=f,x.spotLength=g,x.rectAreaLength=_,x.hemiLength=M,x.numDirectionalShadows=E,x.numPointShadows=S,x.numSpotShadows=T,r.version=EH++)}function c(u,h){let d=0,p=0,v=0,m=0,f=0;const g=h.matrixWorldInverse;for(let _=0,M=u.length;_<M;_++){const E=u[_];if(E.isDirectionalLight){const S=r.directional[d];S.direction.setFromMatrixPosition(E.matrixWorld),s.setFromMatrixPosition(E.target.matrixWorld),S.direction.sub(s),S.direction.transformDirection(g),d++}else if(E.isSpotLight){const S=r.spot[v];S.position.setFromMatrixPosition(E.matrixWorld),S.position.applyMatrix4(g),S.direction.setFromMatrixPosition(E.matrixWorld),s.setFromMatrixPosition(E.target.matrixWorld),S.direction.sub(s),S.direction.transformDirection(g),v++}else if(E.isRectAreaLight){const S=r.rectArea[m];S.position.setFromMatrixPosition(E.matrixWorld),S.position.applyMatrix4(g),a.identity(),o.copy(E.matrixWorld),o.premultiply(g),a.extractRotation(o),S.halfWidth.set(E.width*.5,0,0),S.halfHeight.set(0,E.height*.5,0),S.halfWidth.applyMatrix4(a),S.halfHeight.applyMatrix4(a),m++}else if(E.isPointLight){const S=r.point[p];S.position.setFromMatrixPosition(E.matrixWorld),S.position.applyMatrix4(g),p++}else if(E.isHemisphereLight){const S=r.hemi[f];S.direction.setFromMatrixPosition(E.matrixWorld),S.direction.transformDirection(g),f++}}}return{setup:l,setupView:c,state:r}}function dS(n,e){const t=new TH(n,e),i=[],r=[];function s(){i.length=0,r.length=0}function o(h){i.push(h)}function a(h){r.push(h)}function l(h){t.setup(i,h)}function c(h){t.setupView(i,h)}return{init:s,state:{lightsArray:i,shadowsArray:r,lights:t},setupLights:l,setupLightsView:c,pushLight:o,pushShadow:a}}function AH(n,e){let t=new WeakMap;function i(s,o=0){let a;return t.has(s)===!1?(a=new dS(n,e),t.set(s,[a])):o>=t.get(s).length?(a=new dS(n,e),t.get(s).push(a)):a=t.get(s)[o],a}function r(){t=new WeakMap}return{get:i,dispose:r}}class Rb extends Nl{constructor(e){super(),this.type="MeshDepthMaterial",this.depthPacking=$O,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}Rb.prototype.isMeshDepthMaterial=!0;class Lb extends Nl{constructor(e){super(),this.type="MeshDistanceMaterial",this.referencePosition=new se,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}Lb.prototype.isMeshDistanceMaterial=!0;const CH=`
void main() {

	gl_Position = vec4( position, 1.0 );

}
`,RH=`
uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;

#include <packing>

void main() {

	const float samples = float( VSM_SAMPLES );

	float mean = 0.0;
	float squared_mean = 0.0;

	// This seems totally useless but it's a crazy work around for a Adreno compiler bug
	// float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );

	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {

		float uvOffset = uvStart + i * uvStride;

		#ifdef HORIZONTAL_PASS

			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;

		#else

			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;

		#endif

	}

	mean = mean / samples;
	squared_mean = squared_mean / samples;

	float std_dev = sqrt( squared_mean - mean * mean );

	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );

}
`;function LH(n,e,t){let i=new hb;const r=new mt,s=new mt,o=new _n,a=new Rb({depthPacking:XO}),l=new Lb,c={},u=t.maxTextureSize,h={0:Hi,1:uu,2:dl},d=new Rs({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new mt},radius:{value:4}},vertexShader:CH,fragmentShader:RH}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const v=new Us;v.setAttribute("position",new pi(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const m=new Tr(v,d),f=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=ob,this.render=function(E,S,T){if(f.enabled===!1||f.autoUpdate===!1&&f.needsUpdate===!1||E.length===0)return;const R=n.getRenderTarget(),x=n.getActiveCubeFace(),A=n.getActiveMipmapLevel(),I=n.state;I.setBlending(ws),I.buffers.color.setClear(1,1,1,1),I.buffers.depth.setTest(!0),I.setScissorTest(!1);for(let N=0,J=E.length;N<J;N++){const q=E[N],L=q.shadow;if(L===void 0){console.warn("THREE.WebGLShadowMap:",q,"has no shadow.");continue}if(L.autoUpdate===!1&&L.needsUpdate===!1)continue;r.copy(L.mapSize);const $=L.getFrameExtents();if(r.multiply($),s.copy(L.mapSize),(r.x>u||r.y>u)&&(r.x>u&&(s.x=Math.floor(u/$.x),r.x=s.x*$.x,L.mapSize.x=s.x),r.y>u&&(s.y=Math.floor(u/$.y),r.y=s.y*$.y,L.mapSize.y=s.y)),L.map===null&&!L.isPointLightShadow&&this.type===vc&&(L.map=new Lr(r.x,r.y),L.map.texture.name=q.name+".shadowMap",L.mapPass=new Lr(r.x,r.y),L.camera.updateProjectionMatrix()),L.map===null){const W={minFilter:Nn,magFilter:Nn,format:Ui};L.map=new Lr(r.x,r.y,W),L.map.texture.name=q.name+".shadowMap",L.camera.updateProjectionMatrix()}n.setRenderTarget(L.map),n.clear();const z=L.getViewportCount();for(let W=0;W<z;W++){const U=L.getViewport(W);o.set(s.x*U.x,s.y*U.y,s.x*U.z,s.y*U.w),I.viewport(o),L.updateMatrices(q,W),i=L.getFrustum(),M(S,T,L.camera,q,this.type)}!L.isPointLightShadow&&this.type===vc&&g(L,T),L.needsUpdate=!1}f.needsUpdate=!1,n.setRenderTarget(R,x,A)};function g(E,S){const T=e.update(m);d.defines.VSM_SAMPLES!==E.blurSamples&&(d.defines.VSM_SAMPLES=E.blurSamples,p.defines.VSM_SAMPLES=E.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),d.uniforms.shadow_pass.value=E.map.texture,d.uniforms.resolution.value=E.mapSize,d.uniforms.radius.value=E.radius,n.setRenderTarget(E.mapPass),n.clear(),n.renderBufferDirect(S,null,T,d,m,null),p.uniforms.shadow_pass.value=E.mapPass.texture,p.uniforms.resolution.value=E.mapSize,p.uniforms.radius.value=E.radius,n.setRenderTarget(E.map),n.clear(),n.renderBufferDirect(S,null,T,p,m,null)}function _(E,S,T,R,x,A){let I=null;const N=T.isPointLight===!0?E.customDistanceMaterial:E.customDepthMaterial;if(N!==void 0?I=N:I=T.isPointLight===!0?l:a,n.localClippingEnabled&&S.clipShadows===!0&&S.clippingPlanes.length!==0||S.displacementMap&&S.displacementScale!==0||S.alphaMap&&S.alphaTest>0){const J=I.uuid,q=S.uuid;let L=c[J];L===void 0&&(L={},c[J]=L);let $=L[q];$===void 0&&($=I.clone(),L[q]=$),I=$}return I.visible=S.visible,I.wireframe=S.wireframe,A===vc?I.side=S.shadowSide!==null?S.shadowSide:S.side:I.side=S.shadowSide!==null?S.shadowSide:h[S.side],I.alphaMap=S.alphaMap,I.alphaTest=S.alphaTest,I.clipShadows=S.clipShadows,I.clippingPlanes=S.clippingPlanes,I.clipIntersection=S.clipIntersection,I.displacementMap=S.displacementMap,I.displacementScale=S.displacementScale,I.displacementBias=S.displacementBias,I.wireframeLinewidth=S.wireframeLinewidth,I.linewidth=S.linewidth,T.isPointLight===!0&&I.isMeshDistanceMaterial===!0&&(I.referencePosition.setFromMatrixPosition(T.matrixWorld),I.nearDistance=R,I.farDistance=x),I}function M(E,S,T,R,x){if(E.visible===!1)return;if(E.layers.test(S.layers)&&(E.isMesh||E.isLine||E.isPoints)&&(E.castShadow||E.receiveShadow&&x===vc)&&(!E.frustumCulled||i.intersectsObject(E))){E.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse,E.matrixWorld);const N=e.update(E),J=E.material;if(Array.isArray(J)){const q=N.groups;for(let L=0,$=q.length;L<$;L++){const z=q[L],W=J[z.materialIndex];if(W&&W.visible){const U=_(E,W,R,T.near,T.far,x);n.renderBufferDirect(T,null,N,U,E,z)}}}else if(J.visible){const q=_(E,J,R,T.near,T.far,x);n.renderBufferDirect(T,null,N,q,E,null)}}const I=E.children;for(let N=0,J=I.length;N<J;N++)M(I[N],S,T,R,x)}}function PH(n,e,t){const i=t.isWebGL2;function r(){let C=!1;const ie=new _n;let te=null;const _e=new _n(0,0,0,0);return{setMask:function(ue){te!==ue&&!C&&(n.colorMask(ue,ue,ue,ue),te=ue)},setLocked:function(ue){C=ue},setClear:function(ue,ge,ee,xe,He){He===!0&&(ue*=xe,ge*=xe,ee*=xe),ie.set(ue,ge,ee,xe),_e.equals(ie)===!1&&(n.clearColor(ue,ge,ee,xe),_e.copy(ie))},reset:function(){C=!1,te=null,_e.set(-1,0,0,0)}}}function s(){let C=!1,ie=null,te=null,_e=null;return{setTest:function(ue){ue?de(n.DEPTH_TEST):F(n.DEPTH_TEST)},setMask:function(ue){ie!==ue&&!C&&(n.depthMask(ue),ie=ue)},setFunc:function(ue){if(te!==ue){if(ue)switch(ue){case mO:n.depthFunc(n.NEVER);break;case gO:n.depthFunc(n.ALWAYS);break;case vO:n.depthFunc(n.LESS);break;case Kg:n.depthFunc(n.LEQUAL);break;case _O:n.depthFunc(n.EQUAL);break;case xO:n.depthFunc(n.GEQUAL);break;case yO:n.depthFunc(n.GREATER);break;case MO:n.depthFunc(n.NOTEQUAL);break;default:n.depthFunc(n.LEQUAL)}else n.depthFunc(n.LEQUAL);te=ue}},setLocked:function(ue){C=ue},setClear:function(ue){_e!==ue&&(n.clearDepth(ue),_e=ue)},reset:function(){C=!1,ie=null,te=null,_e=null}}}function o(){let C=!1,ie=null,te=null,_e=null,ue=null,ge=null,ee=null,xe=null,He=null;return{setTest:function(Ne){C||(Ne?de(n.STENCIL_TEST):F(n.STENCIL_TEST))},setMask:function(Ne){ie!==Ne&&!C&&(n.stencilMask(Ne),ie=Ne)},setFunc:function(Ne,Lt,Pt){(te!==Ne||_e!==Lt||ue!==Pt)&&(n.stencilFunc(Ne,Lt,Pt),te=Ne,_e=Lt,ue=Pt)},setOp:function(Ne,Lt,Pt){(ge!==Ne||ee!==Lt||xe!==Pt)&&(n.stencilOp(Ne,Lt,Pt),ge=Ne,ee=Lt,xe=Pt)},setLocked:function(Ne){C=Ne},setClear:function(Ne){He!==Ne&&(n.clearStencil(Ne),He=Ne)},reset:function(){C=!1,ie=null,te=null,_e=null,ue=null,ge=null,ee=null,xe=null,He=null}}}const a=new r,l=new s,c=new o;let u={},h={},d=new WeakMap,p=[],v=null,m=!1,f=null,g=null,_=null,M=null,E=null,S=null,T=null,R=!1,x=null,A=null,I=null,N=null,J=null;const q=n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let L=!1,$=0;const z=n.getParameter(n.VERSION);z.indexOf("WebGL")!==-1?($=parseFloat(/^WebGL (\d)/.exec(z)[1]),L=$>=1):z.indexOf("OpenGL ES")!==-1&&($=parseFloat(/^OpenGL ES (\d)/.exec(z)[1]),L=$>=2);let W=null,U={};const P=n.getParameter(n.SCISSOR_BOX),k=n.getParameter(n.VIEWPORT),Y=new _n().fromArray(P),j=new _n().fromArray(k);function K(C,ie,te){const _e=new Uint8Array(4),ue=n.createTexture();n.bindTexture(C,ue),n.texParameteri(C,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(C,n.TEXTURE_MAG_FILTER,n.NEAREST);for(let ge=0;ge<te;ge++)n.texImage2D(ie+ge,0,n.RGBA,1,1,0,n.RGBA,n.UNSIGNED_BYTE,_e);return ue}const ce={};ce[n.TEXTURE_2D]=K(n.TEXTURE_2D,n.TEXTURE_2D,1),ce[n.TEXTURE_CUBE_MAP]=K(n.TEXTURE_CUBE_MAP,n.TEXTURE_CUBE_MAP_POSITIVE_X,6),a.setClear(0,0,0,1),l.setClear(1),c.setClear(0),de(n.DEPTH_TEST),l.setFunc(Kg),pe(!1),De(tM),de(n.CULL_FACE),oe(ws);function de(C){u[C]!==!0&&(n.enable(C),u[C]=!0)}function F(C){u[C]!==!1&&(n.disable(C),u[C]=!1)}function We(C,ie){return h[C]!==ie?(n.bindFramebuffer(C,ie),h[C]=ie,i&&(C===n.DRAW_FRAMEBUFFER&&(h[n.FRAMEBUFFER]=ie),C===n.FRAMEBUFFER&&(h[n.DRAW_FRAMEBUFFER]=ie)),!0):!1}function Me(C,ie){let te=p,_e=!1;if(C)if(te=d.get(ie),te===void 0&&(te=[],d.set(ie,te)),C.isWebGLMultipleRenderTargets){const ue=C.texture;if(te.length!==ue.length||te[0]!==n.COLOR_ATTACHMENT0){for(let ge=0,ee=ue.length;ge<ee;ge++)te[ge]=n.COLOR_ATTACHMENT0+ge;te.length=ue.length,_e=!0}}else te[0]!==n.COLOR_ATTACHMENT0&&(te[0]=n.COLOR_ATTACHMENT0,_e=!0);else te[0]!==n.BACK&&(te[0]=n.BACK,_e=!0);_e&&(t.isWebGL2?n.drawBuffers(te):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(te))}function Ce(C){return v!==C?(n.useProgram(C),v=C,!0):!1}const re={[ga]:n.FUNC_ADD,[rO]:n.FUNC_SUBTRACT,[sO]:n.FUNC_REVERSE_SUBTRACT};if(i)re[sM]=n.MIN,re[oM]=n.MAX;else{const C=e.get("EXT_blend_minmax");C!==null&&(re[sM]=C.MIN_EXT,re[oM]=C.MAX_EXT)}const ze={[oO]:n.ZERO,[aO]:n.ONE,[lO]:n.SRC_COLOR,[ab]:n.SRC_ALPHA,[pO]:n.SRC_ALPHA_SATURATE,[dO]:n.DST_COLOR,[uO]:n.DST_ALPHA,[cO]:n.ONE_MINUS_SRC_COLOR,[lb]:n.ONE_MINUS_SRC_ALPHA,[fO]:n.ONE_MINUS_DST_COLOR,[hO]:n.ONE_MINUS_DST_ALPHA};function oe(C,ie,te,_e,ue,ge,ee,xe){if(C===ws){m===!0&&(F(n.BLEND),m=!1);return}if(m===!1&&(de(n.BLEND),m=!0),C!==iO){if(C!==f||xe!==R){if((g!==ga||E!==ga)&&(n.blendEquation(n.FUNC_ADD),g=ga,E=ga),xe)switch(C){case Va:n.blendFuncSeparate(n.ONE,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case nM:n.blendFunc(n.ONE,n.ONE);break;case iM:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case rM:n.blendFuncSeparate(n.ZERO,n.SRC_COLOR,n.ZERO,n.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",C);break}else switch(C){case Va:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case nM:n.blendFunc(n.SRC_ALPHA,n.ONE);break;case iM:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case rM:n.blendFunc(n.ZERO,n.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",C);break}_=null,M=null,S=null,T=null,f=C,R=xe}return}ue=ue||ie,ge=ge||te,ee=ee||_e,(ie!==g||ue!==E)&&(n.blendEquationSeparate(re[ie],re[ue]),g=ie,E=ue),(te!==_||_e!==M||ge!==S||ee!==T)&&(n.blendFuncSeparate(ze[te],ze[_e],ze[ge],ze[ee]),_=te,M=_e,S=ge,T=ee),f=C,R=null}function ne(C,ie){C.side===dl?F(n.CULL_FACE):de(n.CULL_FACE);let te=C.side===Hi;ie&&(te=!te),pe(te),C.blending===Va&&C.transparent===!1?oe(ws):oe(C.blending,C.blendEquation,C.blendSrc,C.blendDst,C.blendEquationAlpha,C.blendSrcAlpha,C.blendDstAlpha,C.premultipliedAlpha),l.setFunc(C.depthFunc),l.setTest(C.depthTest),l.setMask(C.depthWrite),a.setMask(C.colorWrite);const _e=C.stencilWrite;c.setTest(_e),_e&&(c.setMask(C.stencilWriteMask),c.setFunc(C.stencilFunc,C.stencilRef,C.stencilFuncMask),c.setOp(C.stencilFail,C.stencilZFail,C.stencilZPass)),$e(C.polygonOffset,C.polygonOffsetFactor,C.polygonOffsetUnits),C.alphaToCoverage===!0?de(n.SAMPLE_ALPHA_TO_COVERAGE):F(n.SAMPLE_ALPHA_TO_COVERAGE)}function pe(C){x!==C&&(C?n.frontFace(n.CW):n.frontFace(n.CCW),x=C)}function De(C){C!==QU?(de(n.CULL_FACE),C!==A&&(C===tM?n.cullFace(n.BACK):C===eO?n.cullFace(n.FRONT):n.cullFace(n.FRONT_AND_BACK))):F(n.CULL_FACE),A=C}function Se(C){C!==I&&(L&&n.lineWidth(C),I=C)}function $e(C,ie,te){C?(de(n.POLYGON_OFFSET_FILL),(N!==ie||J!==te)&&(n.polygonOffset(ie,te),N=ie,J=te)):F(n.POLYGON_OFFSET_FILL)}function Oe(C){C?de(n.SCISSOR_TEST):F(n.SCISSOR_TEST)}function Te(C){C===void 0&&(C=n.TEXTURE0+q-1),W!==C&&(n.activeTexture(C),W=C)}function et(C,ie){W===null&&Te();let te=U[W];te===void 0&&(te={type:void 0,texture:void 0},U[W]=te),(te.type!==C||te.texture!==ie)&&(n.bindTexture(C,ie||ce[C]),te.type=C,te.texture=ie)}function qe(){const C=U[W];C!==void 0&&C.type!==void 0&&(n.bindTexture(C.type,null),C.type=void 0,C.texture=void 0)}function b(){try{n.compressedTexImage2D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function y(){try{n.texSubImage2D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function G(){try{n.texSubImage3D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function Z(){try{n.compressedTexSubImage2D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function ae(){try{n.texStorage2D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function le(){try{n.texStorage3D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function me(){try{n.texImage2D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function V(){try{n.texImage3D.apply(n,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function Ae(C){Y.equals(C)===!1&&(n.scissor(C.x,C.y,C.z,C.w),Y.copy(C))}function Ie(C){j.equals(C)===!1&&(n.viewport(C.x,C.y,C.z,C.w),j.copy(C))}function he(){n.disable(n.BLEND),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SCISSOR_TEST),n.disable(n.STENCIL_TEST),n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ZERO),n.blendFuncSeparate(n.ONE,n.ZERO,n.ONE,n.ZERO),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(n.LESS),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(n.ALWAYS,0,4294967295),n.stencilOp(n.KEEP,n.KEEP,n.KEEP),n.clearStencil(0),n.cullFace(n.BACK),n.frontFace(n.CCW),n.polygonOffset(0,0),n.activeTexture(n.TEXTURE0),n.bindFramebuffer(n.FRAMEBUFFER,null),i===!0&&(n.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),n.bindFramebuffer(n.READ_FRAMEBUFFER,null)),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),u={},W=null,U={},h={},d=new WeakMap,p=[],v=null,m=!1,f=null,g=null,_=null,M=null,E=null,S=null,T=null,R=!1,x=null,A=null,I=null,N=null,J=null,Y.set(0,0,n.canvas.width,n.canvas.height),j.set(0,0,n.canvas.width,n.canvas.height),a.reset(),l.reset(),c.reset()}return{buffers:{color:a,depth:l,stencil:c},enable:de,disable:F,bindFramebuffer:We,drawBuffers:Me,useProgram:Ce,setBlending:oe,setMaterial:ne,setFlipSided:pe,setCullFace:De,setLineWidth:Se,setPolygonOffset:$e,setScissorTest:Oe,activeTexture:Te,bindTexture:et,unbindTexture:qe,compressedTexImage2D:b,texImage2D:me,texImage3D:V,texStorage2D:ae,texStorage3D:le,texSubImage2D:y,texSubImage3D:G,compressedTexSubImage2D:Z,scissor:Ae,viewport:Ie,reset:he}}function DH(n,e,t,i,r,s,o){const a=r.isWebGL2,l=r.maxTextures,c=r.maxCubemapSize,u=r.maxTextureSize,h=r.maxSamples,d=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,p=/OculusBrowser/g.test(navigator.userAgent),v=new WeakMap;let m;const f=new WeakMap;let g=!1;try{g=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function _(b,y){return g?new OffscreenCanvas(b,y):Hd("canvas")}function M(b,y,G,Z){let ae=1;if((b.width>Z||b.height>Z)&&(ae=Z/Math.max(b.width,b.height)),ae<1||y===!0)if(typeof HTMLImageElement!="undefined"&&b instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&b instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&b instanceof ImageBitmap){const le=y?n0:Math.floor,me=le(ae*b.width),V=le(ae*b.height);m===void 0&&(m=_(me,V));const Ae=G?_(me,V):m;return Ae.width=me,Ae.height=V,Ae.getContext("2d").drawImage(b,0,0,me,V),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+b.width+"x"+b.height+") to ("+me+"x"+V+")."),Ae}else return"data"in b&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+b.width+"x"+b.height+")."),b;return b}function E(b){return IM(b.width)&&IM(b.height)}function S(b){return a?!1:b.wrapS!==Fi||b.wrapT!==Fi||b.minFilter!==Nn&&b.minFilter!==li}function T(b,y){return b.generateMipmaps&&y&&b.minFilter!==Nn&&b.minFilter!==li}function R(b){n.generateMipmap(b)}function x(b,y,G,Z,ae=!1){if(a===!1)return y;if(b!==null){if(n[b]!==void 0)return n[b];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+b+"'")}let le=y;return y===n.RED&&(G===n.FLOAT&&(le=n.R32F),G===n.HALF_FLOAT&&(le=n.R16F),G===n.UNSIGNED_BYTE&&(le=n.R8)),y===n.RG&&(G===n.FLOAT&&(le=n.RG32F),G===n.HALF_FLOAT&&(le=n.RG16F),G===n.UNSIGNED_BYTE&&(le=n.RG8)),y===n.RGBA&&(G===n.FLOAT&&(le=n.RGBA32F),G===n.HALF_FLOAT&&(le=n.RGBA16F),G===n.UNSIGNED_BYTE&&(le=Z===St&&ae===!1?n.SRGB8_ALPHA8:n.RGBA8),G===n.UNSIGNED_SHORT_4_4_4_4&&(le=n.RGBA4),G===n.UNSIGNED_SHORT_5_5_5_1&&(le=n.RGB5_A1)),(le===n.R16F||le===n.R32F||le===n.RG16F||le===n.RG32F||le===n.RGBA16F||le===n.RGBA32F)&&e.get("EXT_color_buffer_float"),le}function A(b,y,G){return T(b,G)===!0||b.isFramebufferTexture&&b.minFilter!==Nn&&b.minFilter!==li?Math.log2(Math.max(y.width,y.height))+1:b.mipmaps!==void 0&&b.mipmaps.length>0?b.mipmaps.length:b.isCompressedTexture&&Array.isArray(b.image)?y.mipmaps.length:1}function I(b){return b===Nn||b===aM||b===lM?n.NEAREST:n.LINEAR}function N(b){const y=b.target;y.removeEventListener("dispose",N),q(y),y.isVideoTexture&&v.delete(y)}function J(b){const y=b.target;y.removeEventListener("dispose",J),$(y)}function q(b){const y=i.get(b);if(y.__webglInit===void 0)return;const G=b.source,Z=f.get(G);if(Z){const ae=Z[y.__cacheKey];ae.usedTimes--,ae.usedTimes===0&&L(b),Object.keys(Z).length===0&&f.delete(G)}i.remove(b)}function L(b){const y=i.get(b);n.deleteTexture(y.__webglTexture);const G=b.source,Z=f.get(G);delete Z[y.__cacheKey],o.memory.textures--}function $(b){const y=b.texture,G=i.get(b),Z=i.get(y);if(Z.__webglTexture!==void 0&&(n.deleteTexture(Z.__webglTexture),o.memory.textures--),b.depthTexture&&b.depthTexture.dispose(),b.isWebGLCubeRenderTarget)for(let ae=0;ae<6;ae++)n.deleteFramebuffer(G.__webglFramebuffer[ae]),G.__webglDepthbuffer&&n.deleteRenderbuffer(G.__webglDepthbuffer[ae]);else n.deleteFramebuffer(G.__webglFramebuffer),G.__webglDepthbuffer&&n.deleteRenderbuffer(G.__webglDepthbuffer),G.__webglMultisampledFramebuffer&&n.deleteFramebuffer(G.__webglMultisampledFramebuffer),G.__webglColorRenderbuffer&&n.deleteRenderbuffer(G.__webglColorRenderbuffer),G.__webglDepthRenderbuffer&&n.deleteRenderbuffer(G.__webglDepthRenderbuffer);if(b.isWebGLMultipleRenderTargets)for(let ae=0,le=y.length;ae<le;ae++){const me=i.get(y[ae]);me.__webglTexture&&(n.deleteTexture(me.__webglTexture),o.memory.textures--),i.remove(y[ae])}i.remove(y),i.remove(b)}let z=0;function W(){z=0}function U(){const b=z;return b>=l&&console.warn("THREE.WebGLTextures: Trying to use "+b+" texture units while this GPU supports only "+l),z+=1,b}function P(b){const y=[];return y.push(b.wrapS),y.push(b.wrapT),y.push(b.magFilter),y.push(b.minFilter),y.push(b.anisotropy),y.push(b.internalFormat),y.push(b.format),y.push(b.type),y.push(b.generateMipmaps),y.push(b.premultiplyAlpha),y.push(b.flipY),y.push(b.unpackAlignment),y.push(b.encoding),y.join()}function k(b,y){const G=i.get(b);if(b.isVideoTexture&&et(b),b.isRenderTargetTexture===!1&&b.version>0&&G.__version!==b.version){const Z=b.image;if(Z===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(Z.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Me(G,b,y);return}}t.activeTexture(n.TEXTURE0+y),t.bindTexture(n.TEXTURE_2D,G.__webglTexture)}function Y(b,y){const G=i.get(b);if(b.version>0&&G.__version!==b.version){Me(G,b,y);return}t.activeTexture(n.TEXTURE0+y),t.bindTexture(n.TEXTURE_2D_ARRAY,G.__webglTexture)}function j(b,y){const G=i.get(b);if(b.version>0&&G.__version!==b.version){Me(G,b,y);return}t.activeTexture(n.TEXTURE0+y),t.bindTexture(n.TEXTURE_3D,G.__webglTexture)}function K(b,y){const G=i.get(b);if(b.version>0&&G.__version!==b.version){Ce(G,b,y);return}t.activeTexture(n.TEXTURE0+y),t.bindTexture(n.TEXTURE_CUBE_MAP,G.__webglTexture)}const ce={[Qg]:n.REPEAT,[Fi]:n.CLAMP_TO_EDGE,[e0]:n.MIRRORED_REPEAT},de={[Nn]:n.NEAREST,[aM]:n.NEAREST_MIPMAP_NEAREST,[lM]:n.NEAREST_MIPMAP_LINEAR,[li]:n.LINEAR,[RO]:n.LINEAR_MIPMAP_NEAREST,[Af]:n.LINEAR_MIPMAP_LINEAR};function F(b,y,G){if(G?(n.texParameteri(b,n.TEXTURE_WRAP_S,ce[y.wrapS]),n.texParameteri(b,n.TEXTURE_WRAP_T,ce[y.wrapT]),(b===n.TEXTURE_3D||b===n.TEXTURE_2D_ARRAY)&&n.texParameteri(b,n.TEXTURE_WRAP_R,ce[y.wrapR]),n.texParameteri(b,n.TEXTURE_MAG_FILTER,de[y.magFilter]),n.texParameteri(b,n.TEXTURE_MIN_FILTER,de[y.minFilter])):(n.texParameteri(b,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(b,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),(b===n.TEXTURE_3D||b===n.TEXTURE_2D_ARRAY)&&n.texParameteri(b,n.TEXTURE_WRAP_R,n.CLAMP_TO_EDGE),(y.wrapS!==Fi||y.wrapT!==Fi)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(b,n.TEXTURE_MAG_FILTER,I(y.magFilter)),n.texParameteri(b,n.TEXTURE_MIN_FILTER,I(y.minFilter)),y.minFilter!==Nn&&y.minFilter!==li&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),e.has("EXT_texture_filter_anisotropic")===!0){const Z=e.get("EXT_texture_filter_anisotropic");if(y.type===ro&&e.has("OES_texture_float_linear")===!1||a===!1&&y.type===du&&e.has("OES_texture_half_float_linear")===!1)return;(y.anisotropy>1||i.get(y).__currentAnisotropy)&&(n.texParameterf(b,Z.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(y.anisotropy,r.getMaxAnisotropy())),i.get(y).__currentAnisotropy=y.anisotropy)}}function We(b,y){let G=!1;b.__webglInit===void 0&&(b.__webglInit=!0,y.addEventListener("dispose",N));const Z=y.source;let ae=f.get(Z);ae===void 0&&(ae={},f.set(Z,ae));const le=P(y);if(le!==b.__cacheKey){ae[le]===void 0&&(ae[le]={texture:n.createTexture(),usedTimes:0},o.memory.textures++,G=!0),ae[le].usedTimes++;const me=ae[b.__cacheKey];me!==void 0&&(ae[b.__cacheKey].usedTimes--,me.usedTimes===0&&L(y)),b.__cacheKey=le,b.__webglTexture=ae[le].texture}return G}function Me(b,y,G){let Z=n.TEXTURE_2D;y.isDataArrayTexture&&(Z=n.TEXTURE_2D_ARRAY),y.isData3DTexture&&(Z=n.TEXTURE_3D);const ae=We(b,y),le=y.source;if(t.activeTexture(n.TEXTURE0+G),t.bindTexture(Z,b.__webglTexture),le.version!==le.__currentVersion||ae===!0){n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,y.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,y.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,y.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,n.NONE);const me=S(y)&&E(y.image)===!1;let V=M(y.image,me,!1,u);V=qe(y,V);const Ae=E(V)||a,Ie=s.convert(y.format,y.encoding);let he=s.convert(y.type),C=x(y.internalFormat,Ie,he,y.encoding,y.isVideoTexture);F(Z,y,Ae);let ie;const te=y.mipmaps,_e=a&&y.isVideoTexture!==!0,ue=b.__version===void 0||ae===!0,ge=A(y,V,Ae);if(y.isDepthTexture)C=n.DEPTH_COMPONENT,a?y.type===ro?C=n.DEPTH_COMPONENT32F:y.type===ld?C=n.DEPTH_COMPONENT24:y.type===Wa?C=n.DEPTH24_STENCIL8:C=n.DEPTH_COMPONENT16:y.type===ro&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),y.format===uo&&C===n.DEPTH_COMPONENT&&y.type!==hu&&y.type!==ld&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),y.type=hu,he=s.convert(y.type)),y.format===ml&&C===n.DEPTH_COMPONENT&&(C=n.DEPTH_STENCIL,y.type!==Wa&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),y.type=Wa,he=s.convert(y.type))),ue&&(_e?t.texStorage2D(n.TEXTURE_2D,1,C,V.width,V.height):t.texImage2D(n.TEXTURE_2D,0,C,V.width,V.height,0,Ie,he,null));else if(y.isDataTexture)if(te.length>0&&Ae){_e&&ue&&t.texStorage2D(n.TEXTURE_2D,ge,C,te[0].width,te[0].height);for(let ee=0,xe=te.length;ee<xe;ee++)ie=te[ee],_e?t.texSubImage2D(n.TEXTURE_2D,ee,0,0,ie.width,ie.height,Ie,he,ie.data):t.texImage2D(n.TEXTURE_2D,ee,C,ie.width,ie.height,0,Ie,he,ie.data);y.generateMipmaps=!1}else _e?(ue&&t.texStorage2D(n.TEXTURE_2D,ge,C,V.width,V.height),t.texSubImage2D(n.TEXTURE_2D,0,0,0,V.width,V.height,Ie,he,V.data)):t.texImage2D(n.TEXTURE_2D,0,C,V.width,V.height,0,Ie,he,V.data);else if(y.isCompressedTexture){_e&&ue&&t.texStorage2D(n.TEXTURE_2D,ge,C,te[0].width,te[0].height);for(let ee=0,xe=te.length;ee<xe;ee++)ie=te[ee],y.format!==Ui?Ie!==null?_e?t.compressedTexSubImage2D(n.TEXTURE_2D,ee,0,0,ie.width,ie.height,Ie,ie.data):t.compressedTexImage2D(n.TEXTURE_2D,ee,C,ie.width,ie.height,0,ie.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):_e?t.texSubImage2D(n.TEXTURE_2D,ee,0,0,ie.width,ie.height,Ie,he,ie.data):t.texImage2D(n.TEXTURE_2D,ee,C,ie.width,ie.height,0,Ie,he,ie.data)}else if(y.isDataArrayTexture)_e?(ue&&t.texStorage3D(n.TEXTURE_2D_ARRAY,ge,C,V.width,V.height,V.depth),t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,0,V.width,V.height,V.depth,Ie,he,V.data)):t.texImage3D(n.TEXTURE_2D_ARRAY,0,C,V.width,V.height,V.depth,0,Ie,he,V.data);else if(y.isData3DTexture)_e?(ue&&t.texStorage3D(n.TEXTURE_3D,ge,C,V.width,V.height,V.depth),t.texSubImage3D(n.TEXTURE_3D,0,0,0,0,V.width,V.height,V.depth,Ie,he,V.data)):t.texImage3D(n.TEXTURE_3D,0,C,V.width,V.height,V.depth,0,Ie,he,V.data);else if(y.isFramebufferTexture){if(ue)if(_e)t.texStorage2D(n.TEXTURE_2D,ge,C,V.width,V.height);else{let ee=V.width,xe=V.height;for(let He=0;He<ge;He++)t.texImage2D(n.TEXTURE_2D,He,C,ee,xe,0,Ie,he,null),ee>>=1,xe>>=1}}else if(te.length>0&&Ae){_e&&ue&&t.texStorage2D(n.TEXTURE_2D,ge,C,te[0].width,te[0].height);for(let ee=0,xe=te.length;ee<xe;ee++)ie=te[ee],_e?t.texSubImage2D(n.TEXTURE_2D,ee,0,0,Ie,he,ie):t.texImage2D(n.TEXTURE_2D,ee,C,Ie,he,ie);y.generateMipmaps=!1}else _e?(ue&&t.texStorage2D(n.TEXTURE_2D,ge,C,V.width,V.height),t.texSubImage2D(n.TEXTURE_2D,0,0,0,Ie,he,V)):t.texImage2D(n.TEXTURE_2D,0,C,Ie,he,V);T(y,Ae)&&R(Z),le.__currentVersion=le.version,y.onUpdate&&y.onUpdate(y)}b.__version=y.version}function Ce(b,y,G){if(y.image.length!==6)return;const Z=We(b,y),ae=y.source;if(t.activeTexture(n.TEXTURE0+G),t.bindTexture(n.TEXTURE_CUBE_MAP,b.__webglTexture),ae.version!==ae.__currentVersion||Z===!0){n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,y.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,y.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,y.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,n.NONE);const le=y.isCompressedTexture||y.image[0].isCompressedTexture,me=y.image[0]&&y.image[0].isDataTexture,V=[];for(let ee=0;ee<6;ee++)!le&&!me?V[ee]=M(y.image[ee],!1,!0,c):V[ee]=me?y.image[ee].image:y.image[ee],V[ee]=qe(y,V[ee]);const Ae=V[0],Ie=E(Ae)||a,he=s.convert(y.format,y.encoding),C=s.convert(y.type),ie=x(y.internalFormat,he,C,y.encoding),te=a&&y.isVideoTexture!==!0,_e=b.__version===void 0;let ue=A(y,Ae,Ie);F(n.TEXTURE_CUBE_MAP,y,Ie);let ge;if(le){te&&_e&&t.texStorage2D(n.TEXTURE_CUBE_MAP,ue,ie,Ae.width,Ae.height);for(let ee=0;ee<6;ee++){ge=V[ee].mipmaps;for(let xe=0;xe<ge.length;xe++){const He=ge[xe];y.format!==Ui?he!==null?te?t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ee,xe,0,0,He.width,He.height,he,He.data):t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ee,xe,ie,He.width,He.height,0,He.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):te?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ee,xe,0,0,He.width,He.height,he,C,He.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ee,xe,ie,He.width,He.height,0,he,C,He.data)}}}else{ge=y.mipmaps,te&&_e&&(ge.length>0&&ue++,t.texStorage2D(n.TEXTURE_CUBE_MAP,ue,ie,V[0].width,V[0].height));for(let ee=0;ee<6;ee++)if(me){te?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ee,0,0,0,V[ee].width,V[ee].height,he,C,V[ee].data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ee,0,ie,V[ee].width,V[ee].height,0,he,C,V[ee].data);for(let xe=0;xe<ge.length;xe++){const Ne=ge[xe].image[ee].image;te?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ee,xe+1,0,0,Ne.width,Ne.height,he,C,Ne.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ee,xe+1,ie,Ne.width,Ne.height,0,he,C,Ne.data)}}else{te?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ee,0,0,0,he,C,V[ee]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ee,0,ie,he,C,V[ee]);for(let xe=0;xe<ge.length;xe++){const He=ge[xe];te?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ee,xe+1,0,0,he,C,He.image[ee]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+ee,xe+1,ie,he,C,He.image[ee])}}}T(y,Ie)&&R(n.TEXTURE_CUBE_MAP),ae.__currentVersion=ae.version,y.onUpdate&&y.onUpdate(y)}b.__version=y.version}function re(b,y,G,Z,ae){const le=s.convert(G.format,G.encoding),me=s.convert(G.type),V=x(G.internalFormat,le,me,G.encoding);i.get(y).__hasExternalTextures||(ae===n.TEXTURE_3D||ae===n.TEXTURE_2D_ARRAY?t.texImage3D(ae,0,V,y.width,y.height,y.depth,0,le,me,null):t.texImage2D(ae,0,V,y.width,y.height,0,le,me,null)),t.bindFramebuffer(n.FRAMEBUFFER,b),Te(y)?d.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,Z,ae,i.get(G).__webglTexture,0,Oe(y)):n.framebufferTexture2D(n.FRAMEBUFFER,Z,ae,i.get(G).__webglTexture,0),t.bindFramebuffer(n.FRAMEBUFFER,null)}function ze(b,y,G){if(n.bindRenderbuffer(n.RENDERBUFFER,b),y.depthBuffer&&!y.stencilBuffer){let Z=n.DEPTH_COMPONENT16;if(G||Te(y)){const ae=y.depthTexture;ae&&ae.isDepthTexture&&(ae.type===ro?Z=n.DEPTH_COMPONENT32F:ae.type===ld&&(Z=n.DEPTH_COMPONENT24));const le=Oe(y);Te(y)?d.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,le,Z,y.width,y.height):n.renderbufferStorageMultisample(n.RENDERBUFFER,le,Z,y.width,y.height)}else n.renderbufferStorage(n.RENDERBUFFER,Z,y.width,y.height);n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,b)}else if(y.depthBuffer&&y.stencilBuffer){const Z=Oe(y);G&&Te(y)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,Z,n.DEPTH24_STENCIL8,y.width,y.height):Te(y)?d.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,Z,n.DEPTH24_STENCIL8,y.width,y.height):n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_STENCIL,y.width,y.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.RENDERBUFFER,b)}else{const Z=y.isWebGLMultipleRenderTargets===!0?y.texture[0]:y.texture,ae=s.convert(Z.format,Z.encoding),le=s.convert(Z.type),me=x(Z.internalFormat,ae,le,Z.encoding),V=Oe(y);G&&Te(y)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,V,me,y.width,y.height):Te(y)?d.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,V,me,y.width,y.height):n.renderbufferStorage(n.RENDERBUFFER,me,y.width,y.height)}n.bindRenderbuffer(n.RENDERBUFFER,null)}function oe(b,y){if(y&&y.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(n.FRAMEBUFFER,b),!(y.depthTexture&&y.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!i.get(y.depthTexture).__webglTexture||y.depthTexture.image.width!==y.width||y.depthTexture.image.height!==y.height)&&(y.depthTexture.image.width=y.width,y.depthTexture.image.height=y.height,y.depthTexture.needsUpdate=!0),k(y.depthTexture,0);const Z=i.get(y.depthTexture).__webglTexture,ae=Oe(y);if(y.depthTexture.format===uo)Te(y)?d.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,Z,0,ae):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,Z,0);else if(y.depthTexture.format===ml)Te(y)?d.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,Z,0,ae):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,Z,0);else throw new Error("Unknown depthTexture format")}function ne(b){const y=i.get(b),G=b.isWebGLCubeRenderTarget===!0;if(b.depthTexture&&!y.__autoAllocateDepthBuffer){if(G)throw new Error("target.depthTexture not supported in Cube render targets");oe(y.__webglFramebuffer,b)}else if(G){y.__webglDepthbuffer=[];for(let Z=0;Z<6;Z++)t.bindFramebuffer(n.FRAMEBUFFER,y.__webglFramebuffer[Z]),y.__webglDepthbuffer[Z]=n.createRenderbuffer(),ze(y.__webglDepthbuffer[Z],b,!1)}else t.bindFramebuffer(n.FRAMEBUFFER,y.__webglFramebuffer),y.__webglDepthbuffer=n.createRenderbuffer(),ze(y.__webglDepthbuffer,b,!1);t.bindFramebuffer(n.FRAMEBUFFER,null)}function pe(b,y,G){const Z=i.get(b);y!==void 0&&re(Z.__webglFramebuffer,b,b.texture,n.COLOR_ATTACHMENT0,n.TEXTURE_2D),G!==void 0&&ne(b)}function De(b){const y=b.texture,G=i.get(b),Z=i.get(y);b.addEventListener("dispose",J),b.isWebGLMultipleRenderTargets!==!0&&(Z.__webglTexture===void 0&&(Z.__webglTexture=n.createTexture()),Z.__version=y.version,o.memory.textures++);const ae=b.isWebGLCubeRenderTarget===!0,le=b.isWebGLMultipleRenderTargets===!0,me=E(b)||a;if(ae){G.__webglFramebuffer=[];for(let V=0;V<6;V++)G.__webglFramebuffer[V]=n.createFramebuffer()}else if(G.__webglFramebuffer=n.createFramebuffer(),le)if(r.drawBuffers){const V=b.texture;for(let Ae=0,Ie=V.length;Ae<Ie;Ae++){const he=i.get(V[Ae]);he.__webglTexture===void 0&&(he.__webglTexture=n.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(a&&b.samples>0&&Te(b)===!1){G.__webglMultisampledFramebuffer=n.createFramebuffer(),G.__webglColorRenderbuffer=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,G.__webglColorRenderbuffer);const V=s.convert(y.format,y.encoding),Ae=s.convert(y.type),Ie=x(y.internalFormat,V,Ae,y.encoding),he=Oe(b);n.renderbufferStorageMultisample(n.RENDERBUFFER,he,Ie,b.width,b.height),t.bindFramebuffer(n.FRAMEBUFFER,G.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.RENDERBUFFER,G.__webglColorRenderbuffer),n.bindRenderbuffer(n.RENDERBUFFER,null),b.depthBuffer&&(G.__webglDepthRenderbuffer=n.createRenderbuffer(),ze(G.__webglDepthRenderbuffer,b,!0)),t.bindFramebuffer(n.FRAMEBUFFER,null)}if(ae){t.bindTexture(n.TEXTURE_CUBE_MAP,Z.__webglTexture),F(n.TEXTURE_CUBE_MAP,y,me);for(let V=0;V<6;V++)re(G.__webglFramebuffer[V],b,y,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+V);T(y,me)&&R(n.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(le){const V=b.texture;for(let Ae=0,Ie=V.length;Ae<Ie;Ae++){const he=V[Ae],C=i.get(he);t.bindTexture(n.TEXTURE_2D,C.__webglTexture),F(n.TEXTURE_2D,he,me),re(G.__webglFramebuffer,b,he,n.COLOR_ATTACHMENT0+Ae,n.TEXTURE_2D),T(he,me)&&R(n.TEXTURE_2D)}t.unbindTexture()}else{let V=n.TEXTURE_2D;(b.isWebGL3DRenderTarget||b.isWebGLArrayRenderTarget)&&(a?V=b.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(V,Z.__webglTexture),F(V,y,me),re(G.__webglFramebuffer,b,y,n.COLOR_ATTACHMENT0,V),T(y,me)&&R(V),t.unbindTexture()}b.depthBuffer&&ne(b)}function Se(b){const y=E(b)||a,G=b.isWebGLMultipleRenderTargets===!0?b.texture:[b.texture];for(let Z=0,ae=G.length;Z<ae;Z++){const le=G[Z];if(T(le,y)){const me=b.isWebGLCubeRenderTarget?n.TEXTURE_CUBE_MAP:n.TEXTURE_2D,V=i.get(le).__webglTexture;t.bindTexture(me,V),R(me),t.unbindTexture()}}}function $e(b){if(a&&b.samples>0&&Te(b)===!1){const y=b.width,G=b.height;let Z=n.COLOR_BUFFER_BIT;const ae=[n.COLOR_ATTACHMENT0],le=b.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT;b.depthBuffer&&ae.push(le);const me=i.get(b),V=me.__ignoreDepthValues!==void 0?me.__ignoreDepthValues:!1;V===!1&&(b.depthBuffer&&(Z|=n.DEPTH_BUFFER_BIT),b.stencilBuffer&&(Z|=n.STENCIL_BUFFER_BIT)),t.bindFramebuffer(n.READ_FRAMEBUFFER,me.__webglMultisampledFramebuffer),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,me.__webglFramebuffer),V===!0&&(n.invalidateFramebuffer(n.READ_FRAMEBUFFER,[le]),n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,[le])),n.blitFramebuffer(0,0,y,G,0,0,y,G,Z,n.NEAREST),p&&n.invalidateFramebuffer(n.READ_FRAMEBUFFER,ae),t.bindFramebuffer(n.READ_FRAMEBUFFER,null),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,me.__webglMultisampledFramebuffer)}}function Oe(b){return Math.min(h,b.samples)}function Te(b){const y=i.get(b);return a&&b.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&y.__useRenderToTexture!==!1}function et(b){const y=o.render.frame;v.get(b)!==y&&(v.set(b,y),b.update())}function qe(b,y){const G=b.encoding,Z=b.format,ae=b.type;return b.isCompressedTexture===!0||b.isVideoTexture===!0||b.format===t0||G!==Eo&&(G===St?a===!1?e.has("EXT_sRGB")===!0&&Z===Ui?(b.format=t0,b.minFilter=li,b.generateMipmaps=!1):y=_b.sRGBToLinear(y):(Z!==Ui||ae!==wo)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",G)),y}this.allocateTextureUnit=U,this.resetTextureUnits=W,this.setTexture2D=k,this.setTexture2DArray=Y,this.setTexture3D=j,this.setTextureCube=K,this.rebindTextures=pe,this.setupRenderTarget=De,this.updateRenderTargetMipmap=Se,this.updateMultisampleRenderTarget=$e,this.setupDepthRenderbuffer=ne,this.setupFrameBufferTexture=re,this.useMultisampledRTT=Te}function IH(n,e,t){const i=t.isWebGL2;function r(s,o=null){let a;if(s===wo)return n.UNSIGNED_BYTE;if(s===IO)return n.UNSIGNED_SHORT_4_4_4_4;if(s===NO)return n.UNSIGNED_SHORT_5_5_5_1;if(s===LO)return n.BYTE;if(s===PO)return n.SHORT;if(s===hu)return n.UNSIGNED_SHORT;if(s===DO)return n.INT;if(s===ld)return n.UNSIGNED_INT;if(s===ro)return n.FLOAT;if(s===du)return i?n.HALF_FLOAT:(a=e.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(s===FO)return n.ALPHA;if(s===Ui)return n.RGBA;if(s===OO)return n.LUMINANCE;if(s===BO)return n.LUMINANCE_ALPHA;if(s===uo)return n.DEPTH_COMPONENT;if(s===ml)return n.DEPTH_STENCIL;if(s===zO)return n.RED;if(s===UO)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),n.RGBA;if(s===t0)return a=e.get("EXT_sRGB"),a!==null?a.SRGB_ALPHA_EXT:null;if(s===kO)return n.RED_INTEGER;if(s===HO)return n.RG;if(s===GO)return n.RG_INTEGER;if(s===VO)return n.RGBA_INTEGER;if(s===Jp||s===Qp||s===em||s===tm)if(o===St)if(a=e.get("WEBGL_compressed_texture_s3tc_srgb"),a!==null){if(s===Jp)return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(s===Qp)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(s===em)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(s===tm)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(a=e.get("WEBGL_compressed_texture_s3tc"),a!==null){if(s===Jp)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===Qp)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===em)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===tm)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===cM||s===uM||s===hM||s===dM)if(a=e.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(s===cM)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===uM)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===hM)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===dM)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===WO)return a=e.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if(s===fM||s===pM)if(a=e.get("WEBGL_compressed_texture_etc"),a!==null){if(s===fM)return o===St?a.COMPRESSED_SRGB8_ETC2:a.COMPRESSED_RGB8_ETC2;if(s===pM)return o===St?a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(s===mM||s===gM||s===vM||s===_M||s===xM||s===yM||s===MM||s===SM||s===wM||s===EM||s===bM||s===TM||s===AM||s===CM)if(a=e.get("WEBGL_compressed_texture_astc"),a!==null){if(s===mM)return o===St?a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:a.COMPRESSED_RGBA_ASTC_4x4_KHR;if(s===gM)return o===St?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:a.COMPRESSED_RGBA_ASTC_5x4_KHR;if(s===vM)return o===St?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:a.COMPRESSED_RGBA_ASTC_5x5_KHR;if(s===_M)return o===St?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:a.COMPRESSED_RGBA_ASTC_6x5_KHR;if(s===xM)return o===St?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:a.COMPRESSED_RGBA_ASTC_6x6_KHR;if(s===yM)return o===St?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:a.COMPRESSED_RGBA_ASTC_8x5_KHR;if(s===MM)return o===St?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:a.COMPRESSED_RGBA_ASTC_8x6_KHR;if(s===SM)return o===St?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:a.COMPRESSED_RGBA_ASTC_8x8_KHR;if(s===wM)return o===St?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:a.COMPRESSED_RGBA_ASTC_10x5_KHR;if(s===EM)return o===St?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:a.COMPRESSED_RGBA_ASTC_10x6_KHR;if(s===bM)return o===St?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:a.COMPRESSED_RGBA_ASTC_10x8_KHR;if(s===TM)return o===St?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:a.COMPRESSED_RGBA_ASTC_10x10_KHR;if(s===AM)return o===St?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:a.COMPRESSED_RGBA_ASTC_12x10_KHR;if(s===CM)return o===St?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:a.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(s===RM)if(a=e.get("EXT_texture_compression_bptc"),a!==null){if(s===RM)return o===St?a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:a.COMPRESSED_RGBA_BPTC_UNORM_EXT}else return null;return s===Wa?i?n.UNSIGNED_INT_24_8:(a=e.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null):n[s]!==void 0?n[s]:null}return{convert:r}}class Pb extends Ni{constructor(e=[]){super(),this.cameras=e}}Pb.prototype.isArrayCamera=!0;class xc extends Wi{constructor(){super(),this.type="Group"}}xc.prototype.isGroup=!0;const NH={type:"move"};class Lm{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new xc,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new xc,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new se,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new se),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new xc,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new se,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new se),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,i){let r=null,s=null,o=null;const a=this._targetRay,l=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred")if(a!==null&&(r=t.getPose(e.targetRaySpace,i),r!==null&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(NH))),c&&e.hand){o=!0;for(const m of e.hand.values()){const f=t.getJointPose(m,i);if(c.joints[m.jointName]===void 0){const _=new xc;_.matrixAutoUpdate=!1,_.visible=!1,c.joints[m.jointName]=_,c.add(_)}const g=c.joints[m.jointName];f!==null&&(g.matrix.fromArray(f.transform.matrix),g.matrix.decompose(g.position,g.rotation,g.scale),g.jointRadius=f.radius),g.visible=f!==null}const u=c.joints["index-finger-tip"],h=c.joints["thumb-tip"],d=u.position.distanceTo(h.position),p=.02,v=.005;c.inputState.pinching&&d>p+v?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&d<=p-v&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(s=t.getPose(e.gripSpace,i),s!==null&&(l.matrix.fromArray(s.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),s.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(s.linearVelocity)):l.hasLinearVelocity=!1,s.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(s.angularVelocity)):l.hasAngularVelocity=!1));return a!==null&&(a.visible=r!==null),l!==null&&(l.visible=s!==null),c!==null&&(c.visible=o!==null),this}}class Db extends _i{constructor(e,t,i,r,s,o,a,l,c,u){if(u=u!==void 0?u:uo,u!==uo&&u!==ml)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");i===void 0&&u===uo&&(i=hu),i===void 0&&u===ml&&(i=Wa),super(null,r,s,o,a,l,u,i,c),this.image={width:e,height:t},this.magFilter=a!==void 0?a:Nn,this.minFilter=l!==void 0?l:Nn,this.flipY=!1,this.generateMipmaps=!1}}Db.prototype.isDepthTexture=!0;class FH extends Dl{constructor(e,t){super();const i=this;let r=null,s=1,o=null,a="local-floor",l=null,c=null,u=null,h=null,d=null,p=null;const v=t.getContextAttributes();let m=null,f=null;const g=[],_=new Map,M=new Ni;M.layers.enable(1),M.viewport=new _n;const E=new Ni;E.layers.enable(2),E.viewport=new _n;const S=[M,E],T=new Pb;T.layers.enable(1),T.layers.enable(2);let R=null,x=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(P){let k=g[P];return k===void 0&&(k=new Lm,g[P]=k),k.getTargetRaySpace()},this.getControllerGrip=function(P){let k=g[P];return k===void 0&&(k=new Lm,g[P]=k),k.getGripSpace()},this.getHand=function(P){let k=g[P];return k===void 0&&(k=new Lm,g[P]=k),k.getHandSpace()};function A(P){const k=_.get(P.inputSource);k&&k.dispatchEvent({type:P.type,data:P.inputSource})}function I(){_.forEach(function(P,k){P.disconnect(k)}),_.clear(),R=null,x=null,e.setRenderTarget(m),d=null,h=null,u=null,r=null,f=null,U.stop(),i.isPresenting=!1,i.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(P){s=P,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(P){a=P,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||o},this.setReferenceSpace=function(P){l=P},this.getBaseLayer=function(){return h!==null?h:d},this.getBinding=function(){return u},this.getFrame=function(){return p},this.getSession=function(){return r},this.setSession=async function(P){if(r=P,r!==null){if(m=e.getRenderTarget(),r.addEventListener("select",A),r.addEventListener("selectstart",A),r.addEventListener("selectend",A),r.addEventListener("squeeze",A),r.addEventListener("squeezestart",A),r.addEventListener("squeezeend",A),r.addEventListener("end",I),r.addEventListener("inputsourceschange",N),v.xrCompatible!==!0&&await t.makeXRCompatible(),r.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const k={antialias:r.renderState.layers===void 0?v.antialias:!0,alpha:v.alpha,depth:v.depth,stencil:v.stencil,framebufferScaleFactor:s};d=new XRWebGLLayer(r,t,k),r.updateRenderState({baseLayer:d}),f=new Lr(d.framebufferWidth,d.framebufferHeight,{format:Ui,type:wo,encoding:e.outputEncoding})}else{let k=null,Y=null,j=null;v.depth&&(j=v.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,k=v.stencil?ml:uo,Y=v.stencil?Wa:hu);const K={colorFormat:e.outputEncoding===St?t.SRGB8_ALPHA8:t.RGBA8,depthFormat:j,scaleFactor:s};u=new XRWebGLBinding(r,t),h=u.createProjectionLayer(K),r.updateRenderState({layers:[h]}),f=new Lr(h.textureWidth,h.textureHeight,{format:Ui,type:wo,depthTexture:new Db(h.textureWidth,h.textureHeight,Y,void 0,void 0,void 0,void 0,void 0,void 0,k),stencilBuffer:v.stencil,encoding:e.outputEncoding,samples:v.antialias?4:0});const ce=e.properties.get(f);ce.__ignoreDepthValues=h.ignoreDepthValues}f.isXRRenderTarget=!0,this.setFoveation(1),o=await r.requestReferenceSpace(a),U.setContext(r),U.start(),i.isPresenting=!0,i.dispatchEvent({type:"sessionstart"})}};function N(P){const k=r.inputSources;for(let Y=0;Y<k.length;Y++){const j=k[Y].handedness==="right"?1:0;_.set(k[Y],g[j])}for(let Y=0;Y<P.removed.length;Y++){const j=P.removed[Y],K=_.get(j);K&&(K.dispatchEvent({type:"disconnected",data:j}),_.delete(j))}for(let Y=0;Y<P.added.length;Y++){const j=P.added[Y],K=_.get(j);K&&K.dispatchEvent({type:"connected",data:j})}}const J=new se,q=new se;function L(P,k,Y){J.setFromMatrixPosition(k.matrixWorld),q.setFromMatrixPosition(Y.matrixWorld);const j=J.distanceTo(q),K=k.projectionMatrix.elements,ce=Y.projectionMatrix.elements,de=K[14]/(K[10]-1),F=K[14]/(K[10]+1),We=(K[9]+1)/K[5],Me=(K[9]-1)/K[5],Ce=(K[8]-1)/K[0],re=(ce[8]+1)/ce[0],ze=de*Ce,oe=de*re,ne=j/(-Ce+re),pe=ne*-Ce;k.matrixWorld.decompose(P.position,P.quaternion,P.scale),P.translateX(pe),P.translateZ(ne),P.matrixWorld.compose(P.position,P.quaternion,P.scale),P.matrixWorldInverse.copy(P.matrixWorld).invert();const De=de+ne,Se=F+ne,$e=ze-pe,Oe=oe+(j-pe),Te=We*F/Se*De,et=Me*F/Se*De;P.projectionMatrix.makePerspective($e,Oe,Te,et,De,Se)}function $(P,k){k===null?P.matrixWorld.copy(P.matrix):P.matrixWorld.multiplyMatrices(k.matrixWorld,P.matrix),P.matrixWorldInverse.copy(P.matrixWorld).invert()}this.updateCamera=function(P){if(r===null)return;T.near=E.near=M.near=P.near,T.far=E.far=M.far=P.far,(R!==T.near||x!==T.far)&&(r.updateRenderState({depthNear:T.near,depthFar:T.far}),R=T.near,x=T.far);const k=P.parent,Y=T.cameras;$(T,k);for(let K=0;K<Y.length;K++)$(Y[K],k);T.matrixWorld.decompose(T.position,T.quaternion,T.scale),P.position.copy(T.position),P.quaternion.copy(T.quaternion),P.scale.copy(T.scale),P.matrix.copy(T.matrix),P.matrixWorld.copy(T.matrixWorld);const j=P.children;for(let K=0,ce=j.length;K<ce;K++)j[K].updateMatrixWorld(!0);Y.length===2?L(T,M,E):T.projectionMatrix.copy(M.projectionMatrix)},this.getCamera=function(){return T},this.getFoveation=function(){if(h!==null)return h.fixedFoveation;if(d!==null)return d.fixedFoveation},this.setFoveation=function(P){h!==null&&(h.fixedFoveation=P),d!==null&&d.fixedFoveation!==void 0&&(d.fixedFoveation=P)};let z=null;function W(P,k){if(c=k.getViewerPose(l||o),p=k,c!==null){const j=c.views;d!==null&&(e.setRenderTargetFramebuffer(f,d.framebuffer),e.setRenderTarget(f));let K=!1;j.length!==T.cameras.length&&(T.cameras.length=0,K=!0);for(let ce=0;ce<j.length;ce++){const de=j[ce];let F=null;if(d!==null)F=d.getViewport(de);else{const Me=u.getViewSubImage(h,de);F=Me.viewport,ce===0&&(e.setRenderTargetTextures(f,Me.colorTexture,h.ignoreDepthValues?void 0:Me.depthStencilTexture),e.setRenderTarget(f))}const We=S[ce];We.matrix.fromArray(de.transform.matrix),We.projectionMatrix.fromArray(de.projectionMatrix),We.viewport.set(F.x,F.y,F.width,F.height),ce===0&&T.matrix.copy(We.matrix),K===!0&&T.cameras.push(We)}}const Y=r.inputSources;for(let j=0;j<g.length;j++){const K=Y[j],ce=_.get(K);ce!==void 0&&ce.update(K,k,l||o)}z&&z(P,k),p=null}const U=new db;U.setAnimationLoop(W),this.setAnimationLoop=function(P){z=P},this.dispose=function(){}}}function UH(n,e){function t(m,f){m.fogColor.value.copy(f.color),f.isFog?(m.fogNear.value=f.near,m.fogFar.value=f.far):f.isFogExp2&&(m.fogDensity.value=f.density)}function i(m,f,g,_,M){f.isMeshBasicMaterial||f.isMeshLambertMaterial?r(m,f):f.isMeshToonMaterial?(r(m,f),u(m,f)):f.isMeshPhongMaterial?(r(m,f),c(m,f)):f.isMeshStandardMaterial?(r(m,f),h(m,f),f.isMeshPhysicalMaterial&&d(m,f,M)):f.isMeshMatcapMaterial?(r(m,f),p(m,f)):f.isMeshDepthMaterial?r(m,f):f.isMeshDistanceMaterial?(r(m,f),v(m,f)):f.isMeshNormalMaterial?r(m,f):f.isLineBasicMaterial?(s(m,f),f.isLineDashedMaterial&&o(m,f)):f.isPointsMaterial?a(m,f,g,_):f.isSpriteMaterial?l(m,f):f.isShadowMaterial?(m.color.value.copy(f.color),m.opacity.value=f.opacity):f.isShaderMaterial&&(f.uniformsNeedUpdate=!1)}function r(m,f){m.opacity.value=f.opacity,f.color&&m.diffuse.value.copy(f.color),f.emissive&&m.emissive.value.copy(f.emissive).multiplyScalar(f.emissiveIntensity),f.map&&(m.map.value=f.map),f.alphaMap&&(m.alphaMap.value=f.alphaMap),f.bumpMap&&(m.bumpMap.value=f.bumpMap,m.bumpScale.value=f.bumpScale,f.side===Hi&&(m.bumpScale.value*=-1)),f.displacementMap&&(m.displacementMap.value=f.displacementMap,m.displacementScale.value=f.displacementScale,m.displacementBias.value=f.displacementBias),f.emissiveMap&&(m.emissiveMap.value=f.emissiveMap),f.normalMap&&(m.normalMap.value=f.normalMap,m.normalScale.value.copy(f.normalScale),f.side===Hi&&m.normalScale.value.negate()),f.specularMap&&(m.specularMap.value=f.specularMap),f.alphaTest>0&&(m.alphaTest.value=f.alphaTest);const g=e.get(f).envMap;if(g&&(m.envMap.value=g,m.flipEnvMap.value=g.isCubeTexture&&g.isRenderTargetTexture===!1?-1:1,m.reflectivity.value=f.reflectivity,m.ior.value=f.ior,m.refractionRatio.value=f.refractionRatio),f.lightMap){m.lightMap.value=f.lightMap;const E=n.physicallyCorrectLights!==!0?Math.PI:1;m.lightMapIntensity.value=f.lightMapIntensity*E}f.aoMap&&(m.aoMap.value=f.aoMap,m.aoMapIntensity.value=f.aoMapIntensity);let _;f.map?_=f.map:f.specularMap?_=f.specularMap:f.displacementMap?_=f.displacementMap:f.normalMap?_=f.normalMap:f.bumpMap?_=f.bumpMap:f.roughnessMap?_=f.roughnessMap:f.metalnessMap?_=f.metalnessMap:f.alphaMap?_=f.alphaMap:f.emissiveMap?_=f.emissiveMap:f.clearcoatMap?_=f.clearcoatMap:f.clearcoatNormalMap?_=f.clearcoatNormalMap:f.clearcoatRoughnessMap?_=f.clearcoatRoughnessMap:f.specularIntensityMap?_=f.specularIntensityMap:f.specularColorMap?_=f.specularColorMap:f.transmissionMap?_=f.transmissionMap:f.thicknessMap?_=f.thicknessMap:f.sheenColorMap?_=f.sheenColorMap:f.sheenRoughnessMap&&(_=f.sheenRoughnessMap),_!==void 0&&(_.isWebGLRenderTarget&&(_=_.texture),_.matrixAutoUpdate===!0&&_.updateMatrix(),m.uvTransform.value.copy(_.matrix));let M;f.aoMap?M=f.aoMap:f.lightMap&&(M=f.lightMap),M!==void 0&&(M.isWebGLRenderTarget&&(M=M.texture),M.matrixAutoUpdate===!0&&M.updateMatrix(),m.uv2Transform.value.copy(M.matrix))}function s(m,f){m.diffuse.value.copy(f.color),m.opacity.value=f.opacity}function o(m,f){m.dashSize.value=f.dashSize,m.totalSize.value=f.dashSize+f.gapSize,m.scale.value=f.scale}function a(m,f,g,_){m.diffuse.value.copy(f.color),m.opacity.value=f.opacity,m.size.value=f.size*g,m.scale.value=_*.5,f.map&&(m.map.value=f.map),f.alphaMap&&(m.alphaMap.value=f.alphaMap),f.alphaTest>0&&(m.alphaTest.value=f.alphaTest);let M;f.map?M=f.map:f.alphaMap&&(M=f.alphaMap),M!==void 0&&(M.matrixAutoUpdate===!0&&M.updateMatrix(),m.uvTransform.value.copy(M.matrix))}function l(m,f){m.diffuse.value.copy(f.color),m.opacity.value=f.opacity,m.rotation.value=f.rotation,f.map&&(m.map.value=f.map),f.alphaMap&&(m.alphaMap.value=f.alphaMap),f.alphaTest>0&&(m.alphaTest.value=f.alphaTest);let g;f.map?g=f.map:f.alphaMap&&(g=f.alphaMap),g!==void 0&&(g.matrixAutoUpdate===!0&&g.updateMatrix(),m.uvTransform.value.copy(g.matrix))}function c(m,f){m.specular.value.copy(f.specular),m.shininess.value=Math.max(f.shininess,1e-4)}function u(m,f){f.gradientMap&&(m.gradientMap.value=f.gradientMap)}function h(m,f){m.roughness.value=f.roughness,m.metalness.value=f.metalness,f.roughnessMap&&(m.roughnessMap.value=f.roughnessMap),f.metalnessMap&&(m.metalnessMap.value=f.metalnessMap),e.get(f).envMap&&(m.envMapIntensity.value=f.envMapIntensity)}function d(m,f,g){m.ior.value=f.ior,f.sheen>0&&(m.sheenColor.value.copy(f.sheenColor).multiplyScalar(f.sheen),m.sheenRoughness.value=f.sheenRoughness,f.sheenColorMap&&(m.sheenColorMap.value=f.sheenColorMap),f.sheenRoughnessMap&&(m.sheenRoughnessMap.value=f.sheenRoughnessMap)),f.clearcoat>0&&(m.clearcoat.value=f.clearcoat,m.clearcoatRoughness.value=f.clearcoatRoughness,f.clearcoatMap&&(m.clearcoatMap.value=f.clearcoatMap),f.clearcoatRoughnessMap&&(m.clearcoatRoughnessMap.value=f.clearcoatRoughnessMap),f.clearcoatNormalMap&&(m.clearcoatNormalScale.value.copy(f.clearcoatNormalScale),m.clearcoatNormalMap.value=f.clearcoatNormalMap,f.side===Hi&&m.clearcoatNormalScale.value.negate())),f.transmission>0&&(m.transmission.value=f.transmission,m.transmissionSamplerMap.value=g.texture,m.transmissionSamplerSize.value.set(g.width,g.height),f.transmissionMap&&(m.transmissionMap.value=f.transmissionMap),m.thickness.value=f.thickness,f.thicknessMap&&(m.thicknessMap.value=f.thicknessMap),m.attenuationDistance.value=f.attenuationDistance,m.attenuationColor.value.copy(f.attenuationColor)),m.specularIntensity.value=f.specularIntensity,m.specularColor.value.copy(f.specularColor),f.specularIntensityMap&&(m.specularIntensityMap.value=f.specularIntensityMap),f.specularColorMap&&(m.specularColorMap.value=f.specularColorMap)}function p(m,f){f.matcap&&(m.matcap.value=f.matcap)}function v(m,f){m.referencePosition.value.copy(f.referencePosition),m.nearDistance.value=f.nearDistance,m.farDistance.value=f.farDistance}return{refreshFogUniforms:t,refreshMaterialUniforms:i}}function OH(){const n=Hd("canvas");return n.style.display="block",n}function Ib(n={}){const e=n.canvas!==void 0?n.canvas:OH(),t=n.context!==void 0?n.context:null,i=n.depth!==void 0?n.depth:!0,r=n.stencil!==void 0?n.stencil:!0,s=n.antialias!==void 0?n.antialias:!1,o=n.premultipliedAlpha!==void 0?n.premultipliedAlpha:!0,a=n.preserveDrawingBuffer!==void 0?n.preserveDrawingBuffer:!1,l=n.powerPreference!==void 0?n.powerPreference:"default",c=n.failIfMajorPerformanceCaveat!==void 0?n.failIfMajorPerformanceCaveat:!1;let u;t!==null?u=t.getContextAttributes().alpha:u=n.alpha!==void 0?n.alpha:!1;let h=null,d=null;const p=[],v=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=Eo,this.physicallyCorrectLights=!1,this.toneMapping=Rr,this.toneMappingExposure=1;const m=this;let f=!1,g=0,_=0,M=null,E=-1,S=null;const T=new _n,R=new _n;let x=null,A=e.width,I=e.height,N=1,J=null,q=null;const L=new _n(0,0,A,I),$=new _n(0,0,A,I);let z=!1;const W=new hb;let U=!1,P=!1,k=null;const Y=new ln,j=new mt,K=new se,ce={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function de(){return M===null?N:1}let F=t;function We(w,D){for(let H=0;H<w.length;H++){const O=w[H],X=e.getContext(O,D);if(X!==null)return X}return null}try{const w={alpha:!0,depth:i,stencil:r,antialias:s,premultipliedAlpha:o,preserveDrawingBuffer:a,powerPreference:l,failIfMajorPerformanceCaveat:c};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${JU}`),e.addEventListener("webglcontextlost",C,!1),e.addEventListener("webglcontextrestored",ie,!1),F===null){const D=["webgl2","webgl","experimental-webgl"];if(m.isWebGL1Renderer===!0&&D.shift(),F=We(D,w),F===null)throw We(D)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}F.getShaderPrecisionFormat===void 0&&(F.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(w){throw console.error("THREE.WebGLRenderer: "+w.message),w}let Me,Ce,re,ze,oe,ne,pe,De,Se,$e,Oe,Te,et,qe,b,y,G,Z,ae,le,me,V,Ae;function Ie(){Me=new Qk(F),Ce=new $k(F,Me,n),Me.init(Ce),V=new IH(F,Me,Ce),re=new PH(F,Me,Ce),ze=new n4(F),oe=new xH,ne=new DH(F,Me,re,oe,Ce,V,ze),pe=new Yk(m),De=new Jk(m),Se=new nB(F,Ce),Ae=new Vk(F,Me,Se,Ce),$e=new e4(F,Se,ze,Ae),Oe=new o4(F,$e,Se,ze),ae=new s4(F,Ce,ne),y=new Xk(oe),Te=new _H(m,pe,De,Me,Ce,Ae,y),et=new UH(m,oe),qe=new MH,b=new AH(Me,Ce),Z=new Gk(m,pe,re,Oe,u,o),G=new LH(m,Oe,Ce),le=new Wk(F,Me,ze,Ce),me=new t4(F,Me,ze,Ce),ze.programs=Te.programs,m.capabilities=Ce,m.extensions=Me,m.properties=oe,m.renderLists=qe,m.shadowMap=G,m.state=re,m.info=ze}Ie();const he=new FH(m,F);this.xr=he,this.getContext=function(){return F},this.getContextAttributes=function(){return F.getContextAttributes()},this.forceContextLoss=function(){const w=Me.get("WEBGL_lose_context");w&&w.loseContext()},this.forceContextRestore=function(){const w=Me.get("WEBGL_lose_context");w&&w.restoreContext()},this.getPixelRatio=function(){return N},this.setPixelRatio=function(w){w!==void 0&&(N=w,this.setSize(A,I,!1))},this.getSize=function(w){return w.set(A,I)},this.setSize=function(w,D,H){if(he.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}A=w,I=D,e.width=Math.floor(w*N),e.height=Math.floor(D*N),H!==!1&&(e.style.width=w+"px",e.style.height=D+"px"),this.setViewport(0,0,w,D)},this.getDrawingBufferSize=function(w){return w.set(A*N,I*N).floor()},this.setDrawingBufferSize=function(w,D,H){A=w,I=D,N=H,e.width=Math.floor(w*H),e.height=Math.floor(D*H),this.setViewport(0,0,w,D)},this.getCurrentViewport=function(w){return w.copy(T)},this.getViewport=function(w){return w.copy(L)},this.setViewport=function(w,D,H,O){w.isVector4?L.set(w.x,w.y,w.z,w.w):L.set(w,D,H,O),re.viewport(T.copy(L).multiplyScalar(N).floor())},this.getScissor=function(w){return w.copy($)},this.setScissor=function(w,D,H,O){w.isVector4?$.set(w.x,w.y,w.z,w.w):$.set(w,D,H,O),re.scissor(R.copy($).multiplyScalar(N).floor())},this.getScissorTest=function(){return z},this.setScissorTest=function(w){re.setScissorTest(z=w)},this.setOpaqueSort=function(w){J=w},this.setTransparentSort=function(w){q=w},this.getClearColor=function(w){return w.copy(Z.getClearColor())},this.setClearColor=function(){Z.setClearColor.apply(Z,arguments)},this.getClearAlpha=function(){return Z.getClearAlpha()},this.setClearAlpha=function(){Z.setClearAlpha.apply(Z,arguments)},this.clear=function(w=!0,D=!0,H=!0){let O=0;w&&(O|=F.COLOR_BUFFER_BIT),D&&(O|=F.DEPTH_BUFFER_BIT),H&&(O|=F.STENCIL_BUFFER_BIT),F.clear(O)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",C,!1),e.removeEventListener("webglcontextrestored",ie,!1),qe.dispose(),b.dispose(),oe.dispose(),pe.dispose(),De.dispose(),Oe.dispose(),Ae.dispose(),Te.dispose(),he.dispose(),he.removeEventListener("sessionstart",xe),he.removeEventListener("sessionend",He),k&&(k.dispose(),k=null),Ne.stop()};function C(w){w.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),f=!0}function ie(){console.log("THREE.WebGLRenderer: Context Restored."),f=!1;const w=ze.autoReset,D=G.enabled,H=G.autoUpdate,O=G.needsUpdate,X=G.type;Ie(),ze.autoReset=w,G.enabled=D,G.autoUpdate=H,G.needsUpdate=O,G.type=X}function te(w){const D=w.target;D.removeEventListener("dispose",te),_e(D)}function _e(w){ue(w),oe.remove(w)}function ue(w){const D=oe.get(w).programs;D!==void 0&&(D.forEach(function(H){Te.releaseProgram(H)}),w.isShaderMaterial&&Te.releaseShaderCache(w))}this.renderBufferDirect=function(w,D,H,O,X,ye){D===null&&(D=ce);const Ee=X.isMesh&&X.matrixWorld.determinant()<0,Re=Pf(w,D,H,O,X);re.setMaterial(O,Ee);let be=H.index;const Ge=H.attributes.position;if(be===null){if(Ge===void 0||Ge.count===0)return}else if(be.count===0)return;let Fe=1;O.wireframe===!0&&(be=$e.getWireframeAttribute(H),Fe=2),Ae.setup(X,O,Re,H,be);let Be,Xe=le;be!==null&&(Be=Se.get(be),Xe=me,Xe.setIndex(Be));const Sn=be!==null?be.count:Ge.count,Hn=H.drawRange.start*Fe,Gn=H.drawRange.count*Fe,Dt=ye!==null?ye.start*Fe:0,ke=ye!==null?ye.count*Fe:1/0,Vn=Math.max(Hn,Dt),je=Math.min(Sn,Hn+Gn,Dt+ke)-1,It=Math.max(0,je-Vn+1);if(It!==0){if(X.isMesh)O.wireframe===!0?(re.setLineWidth(O.wireframeLinewidth*de()),Xe.setMode(F.LINES)):Xe.setMode(F.TRIANGLES);else if(X.isLine){let Qt=O.linewidth;Qt===void 0&&(Qt=1),re.setLineWidth(Qt*de()),X.isLineSegments?Xe.setMode(F.LINES):X.isLineLoop?Xe.setMode(F.LINE_LOOP):Xe.setMode(F.LINE_STRIP)}else X.isPoints?Xe.setMode(F.POINTS):X.isSprite&&Xe.setMode(F.TRIANGLES);if(X.isInstancedMesh)Xe.renderInstances(Vn,It,X.count);else if(H.isInstancedBufferGeometry){const Qt=Math.min(H.instanceCount,H._maxInstanceCount);Xe.renderInstances(Vn,It,Qt)}else Xe.render(Vn,It)}},this.compile=function(w,D){d=b.get(w),d.init(),v.push(d),w.traverseVisible(function(H){H.isLight&&H.layers.test(D.layers)&&(d.pushLight(H),H.castShadow&&d.pushShadow(H))}),d.setupLights(m.physicallyCorrectLights),w.traverse(function(H){const O=H.material;if(O)if(Array.isArray(O))for(let X=0;X<O.length;X++){const ye=O[X];Os(ye,w,H)}else Os(O,w,H)}),v.pop(),d=null};let ge=null;function ee(w){ge&&ge(w)}function xe(){Ne.stop()}function He(){Ne.start()}const Ne=new db;Ne.setAnimationLoop(ee),typeof self!="undefined"&&Ne.setContext(self),this.setAnimationLoop=function(w){ge=w,he.setAnimationLoop(w),w===null?Ne.stop():Ne.start()},he.addEventListener("sessionstart",xe),he.addEventListener("sessionend",He),this.render=function(w,D){if(D!==void 0&&D.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(f===!0)return;w.autoUpdate===!0&&w.updateMatrixWorld(),D.parent===null&&D.updateMatrixWorld(),he.enabled===!0&&he.isPresenting===!0&&(he.cameraAutoUpdate===!0&&he.updateCamera(D),D=he.getCamera()),w.isScene===!0&&w.onBeforeRender(m,w,D,M),d=b.get(w,v.length),d.init(),v.push(d),Y.multiplyMatrices(D.projectionMatrix,D.matrixWorldInverse),W.setFromProjectionMatrix(Y),P=this.localClippingEnabled,U=y.init(this.clippingPlanes,P,D),h=qe.get(w,p.length),h.init(),p.push(h),Lt(w,D,0,m.sortObjects),h.finish(),m.sortObjects===!0&&h.sort(J,q),U===!0&&y.beginShadows();const H=d.state.shadowsArray;if(G.render(H,w,D),U===!0&&y.endShadows(),this.info.autoReset===!0&&this.info.reset(),Z.render(h,w),d.setupLights(m.physicallyCorrectLights),D.isArrayCamera){const O=D.cameras;for(let X=0,ye=O.length;X<ye;X++){const Ee=O[X];Pt(h,w,Ee,Ee.viewport)}}else Pt(h,w,D);M!==null&&(ne.updateMultisampleRenderTarget(M),ne.updateRenderTargetMipmap(M)),w.isScene===!0&&w.onAfterRender(m,w,D),Ae.resetDefaultState(),E=-1,S=null,v.pop(),v.length>0?d=v[v.length-1]:d=null,p.pop(),p.length>0?h=p[p.length-1]:h=null};function Lt(w,D,H,O){if(w.visible===!1)return;if(w.layers.test(D.layers)){if(w.isGroup)H=w.renderOrder;else if(w.isLOD)w.autoUpdate===!0&&w.update(D);else if(w.isLight)d.pushLight(w),w.castShadow&&d.pushShadow(w);else if(w.isSprite){if(!w.frustumCulled||W.intersectsSprite(w)){O&&K.setFromMatrixPosition(w.matrixWorld).applyMatrix4(Y);const Ee=Oe.update(w),Re=w.material;Re.visible&&h.push(w,Ee,Re,H,K.z,null)}}else if((w.isMesh||w.isLine||w.isPoints)&&(w.isSkinnedMesh&&w.skeleton.frame!==ze.render.frame&&(w.skeleton.update(),w.skeleton.frame=ze.render.frame),!w.frustumCulled||W.intersectsObject(w))){O&&K.setFromMatrixPosition(w.matrixWorld).applyMatrix4(Y);const Ee=Oe.update(w),Re=w.material;if(Array.isArray(Re)){const be=Ee.groups;for(let Ge=0,Fe=be.length;Ge<Fe;Ge++){const Be=be[Ge],Xe=Re[Be.materialIndex];Xe&&Xe.visible&&h.push(w,Ee,Xe,H,K.z,Be)}}else Re.visible&&h.push(w,Ee,Re,H,K.z,null)}}const ye=w.children;for(let Ee=0,Re=ye.length;Ee<Re;Ee++)Lt(ye[Ee],D,H,O)}function Pt(w,D,H,O){const X=w.opaque,ye=w.transmissive,Ee=w.transparent;d.setupLightsView(H),ye.length>0&&Rf(X,D,H),O&&re.viewport(T.copy(O)),X.length>0&&ir(X,D,H),ye.length>0&&ir(ye,D,H),Ee.length>0&&ir(Ee,D,H),re.buffers.depth.setTest(!0),re.buffers.depth.setMask(!0),re.buffers.color.setMask(!0),re.setPolygonOffset(!1)}function Rf(w,D,H){const O=Ce.isWebGL2;k===null&&(k=new Lr(1,1,{generateMipmaps:!0,type:Me.has("EXT_color_buffer_half_float")?du:wo,minFilter:Af,samples:O&&s===!0?4:0})),m.getDrawingBufferSize(j),O?k.setSize(j.x,j.y):k.setSize(n0(j.x),n0(j.y));const X=m.getRenderTarget();m.setRenderTarget(k),m.clear();const ye=m.toneMapping;m.toneMapping=Rr,ir(w,D,H),m.toneMapping=ye,ne.updateMultisampleRenderTarget(k),ne.updateRenderTargetMipmap(k),m.setRenderTarget(X)}function ir(w,D,H){const O=D.isScene===!0?D.overrideMaterial:null;for(let X=0,ye=w.length;X<ye;X++){const Ee=w[X],Re=Ee.object,be=Ee.geometry,Ge=O===null?Ee.material:O,Fe=Ee.group;Re.layers.test(H.layers)&&Lf(Re,D,H,be,Ge,Fe)}}function Lf(w,D,H,O,X,ye){w.onBeforeRender(m,D,H,O,X,ye),w.modelViewMatrix.multiplyMatrices(H.matrixWorldInverse,w.matrixWorld),w.normalMatrix.getNormalMatrix(w.modelViewMatrix),X.onBeforeRender(m,D,H,O,w,ye),X.transparent===!0&&X.side===dl?(X.side=Hi,X.needsUpdate=!0,m.renderBufferDirect(H,D,O,X,w,ye),X.side=uu,X.needsUpdate=!0,m.renderBufferDirect(H,D,O,X,w,ye),X.side=dl):m.renderBufferDirect(H,D,O,X,w,ye),w.onAfterRender(m,D,H,O,X,ye)}function Os(w,D,H){D.isScene!==!0&&(D=ce);const O=oe.get(w),X=d.state.lights,ye=d.state.shadowsArray,Ee=X.state.version,Re=Te.getParameters(w,X.state,ye,D,H),be=Te.getProgramCacheKey(Re);let Ge=O.programs;O.environment=w.isMeshStandardMaterial?D.environment:null,O.fog=D.fog,O.envMap=(w.isMeshStandardMaterial?De:pe).get(w.envMap||O.environment),Ge===void 0&&(w.addEventListener("dispose",te),Ge=new Map,O.programs=Ge);let Fe=Ge.get(be);if(Fe!==void 0){if(O.currentProgram===Fe&&O.lightsStateVersion===Ee)return Ol(w,Re),Fe}else Re.uniforms=Te.getUniforms(w),w.onBuild(H,Re,m),w.onBeforeCompile(Re,m),Fe=Te.acquireProgram(Re,be),Ge.set(be,Fe),O.uniforms=Re.uniforms;const Be=O.uniforms;(!w.isShaderMaterial&&!w.isRawShaderMaterial||w.clipping===!0)&&(Be.clippingPlanes=y.uniform),Ol(w,Re),O.needsLights=If(w),O.lightsStateVersion=Ee,O.needsLights&&(Be.ambientLightColor.value=X.state.ambient,Be.lightProbe.value=X.state.probe,Be.directionalLights.value=X.state.directional,Be.directionalLightShadows.value=X.state.directionalShadow,Be.spotLights.value=X.state.spot,Be.spotLightShadows.value=X.state.spotShadow,Be.rectAreaLights.value=X.state.rectArea,Be.ltc_1.value=X.state.rectAreaLTC1,Be.ltc_2.value=X.state.rectAreaLTC2,Be.pointLights.value=X.state.point,Be.pointLightShadows.value=X.state.pointShadow,Be.hemisphereLights.value=X.state.hemi,Be.directionalShadowMap.value=X.state.directionalShadowMap,Be.directionalShadowMatrix.value=X.state.directionalShadowMatrix,Be.spotShadowMap.value=X.state.spotShadowMap,Be.spotShadowMatrix.value=X.state.spotShadowMatrix,Be.pointShadowMap.value=X.state.pointShadowMap,Be.pointShadowMatrix.value=X.state.pointShadowMatrix);const Xe=Fe.getUniforms(),Sn=Es.seqWithValue(Xe.seq,Be);return O.currentProgram=Fe,O.uniformsList=Sn,Fe}function Ol(w,D){const H=oe.get(w);H.outputEncoding=D.outputEncoding,H.instancing=D.instancing,H.skinning=D.skinning,H.morphTargets=D.morphTargets,H.morphNormals=D.morphNormals,H.morphColors=D.morphColors,H.morphTargetsCount=D.morphTargetsCount,H.numClippingPlanes=D.numClippingPlanes,H.numIntersection=D.numClipIntersection,H.vertexAlphas=D.vertexAlphas,H.vertexTangents=D.vertexTangents,H.toneMapping=D.toneMapping}function Pf(w,D,H,O,X){D.isScene!==!0&&(D=ce),ne.resetTextureUnits();const ye=D.fog,Ee=O.isMeshStandardMaterial?D.environment:null,Re=M===null?m.outputEncoding:M.isXRRenderTarget===!0?M.texture.encoding:Eo,be=(O.isMeshStandardMaterial?De:pe).get(O.envMap||Ee),Ge=O.vertexColors===!0&&!!H.attributes.color&&H.attributes.color.itemSize===4,Fe=!!O.normalMap&&!!H.attributes.tangent,Be=!!H.morphAttributes.position,Xe=!!H.morphAttributes.normal,Sn=!!H.morphAttributes.color,Hn=O.toneMapped?m.toneMapping:Rr,Gn=H.morphAttributes.position||H.morphAttributes.normal||H.morphAttributes.color,Dt=Gn!==void 0?Gn.length:0,ke=oe.get(O),Vn=d.state.lights;if(U===!0&&(P===!0||w!==S)){const Nt=w===S&&O.id===E;y.setState(O,w,Nt)}let je=!1;O.version===ke.__version?(ke.needsLights&&ke.lightsStateVersion!==Vn.state.version||ke.outputEncoding!==Re||X.isInstancedMesh&&ke.instancing===!1||!X.isInstancedMesh&&ke.instancing===!0||X.isSkinnedMesh&&ke.skinning===!1||!X.isSkinnedMesh&&ke.skinning===!0||ke.envMap!==be||O.fog===!0&&ke.fog!==ye||ke.numClippingPlanes!==void 0&&(ke.numClippingPlanes!==y.numPlanes||ke.numIntersection!==y.numIntersection)||ke.vertexAlphas!==Ge||ke.vertexTangents!==Fe||ke.morphTargets!==Be||ke.morphNormals!==Xe||ke.morphColors!==Sn||ke.toneMapping!==Hn||Ce.isWebGL2===!0&&ke.morphTargetsCount!==Dt)&&(je=!0):(je=!0,ke.__version=O.version);let It=ke.currentProgram;je===!0&&(It=Os(O,D,X));let Qt=!1,xi=!1,Bs=!1;const nt=It.getUniforms(),yi=ke.uniforms;if(re.useProgram(It.program)&&(Qt=!0,xi=!0,Bs=!0),O.id!==E&&(E=O.id,xi=!0),Qt||S!==w){if(nt.setValue(F,"projectionMatrix",w.projectionMatrix),Ce.logarithmicDepthBuffer&&nt.setValue(F,"logDepthBufFC",2/(Math.log(w.far+1)/Math.LN2)),S!==w&&(S=w,xi=!0,Bs=!0),O.isShaderMaterial||O.isMeshPhongMaterial||O.isMeshToonMaterial||O.isMeshStandardMaterial||O.envMap){const Nt=nt.map.cameraPosition;Nt!==void 0&&Nt.setValue(F,K.setFromMatrixPosition(w.matrixWorld))}(O.isMeshPhongMaterial||O.isMeshToonMaterial||O.isMeshLambertMaterial||O.isMeshBasicMaterial||O.isMeshStandardMaterial||O.isShaderMaterial)&&nt.setValue(F,"isOrthographic",w.isOrthographicCamera===!0),(O.isMeshPhongMaterial||O.isMeshToonMaterial||O.isMeshLambertMaterial||O.isMeshBasicMaterial||O.isMeshStandardMaterial||O.isShaderMaterial||O.isShadowMaterial||X.isSkinnedMesh)&&nt.setValue(F,"viewMatrix",w.matrixWorldInverse)}if(X.isSkinnedMesh){nt.setOptional(F,X,"bindMatrix"),nt.setOptional(F,X,"bindMatrixInverse");const Nt=X.skeleton;Nt&&(Ce.floatVertexTextures?(Nt.boneTexture===null&&Nt.computeBoneTexture(),nt.setValue(F,"boneTexture",Nt.boneTexture,ne),nt.setValue(F,"boneTextureSize",Nt.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const zs=H.morphAttributes;return(zs.position!==void 0||zs.normal!==void 0||zs.color!==void 0&&Ce.isWebGL2===!0)&&ae.update(X,H,O,It),(xi||ke.receiveShadow!==X.receiveShadow)&&(ke.receiveShadow=X.receiveShadow,nt.setValue(F,"receiveShadow",X.receiveShadow)),xi&&(nt.setValue(F,"toneMappingExposure",m.toneMappingExposure),ke.needsLights&&Df(yi,Bs),ye&&O.fog===!0&&et.refreshFogUniforms(yi,ye),et.refreshMaterialUniforms(yi,O,N,I,k),Es.upload(F,ke.uniformsList,yi,ne)),O.isShaderMaterial&&O.uniformsNeedUpdate===!0&&(Es.upload(F,ke.uniformsList,yi,ne),O.uniformsNeedUpdate=!1),O.isSpriteMaterial&&nt.setValue(F,"center",X.center),nt.setValue(F,"modelViewMatrix",X.modelViewMatrix),nt.setValue(F,"normalMatrix",X.normalMatrix),nt.setValue(F,"modelMatrix",X.matrixWorld),It}function Df(w,D){w.ambientLightColor.needsUpdate=D,w.lightProbe.needsUpdate=D,w.directionalLights.needsUpdate=D,w.directionalLightShadows.needsUpdate=D,w.pointLights.needsUpdate=D,w.pointLightShadows.needsUpdate=D,w.spotLights.needsUpdate=D,w.spotLightShadows.needsUpdate=D,w.rectAreaLights.needsUpdate=D,w.hemisphereLights.needsUpdate=D}function If(w){return w.isMeshLambertMaterial||w.isMeshToonMaterial||w.isMeshPhongMaterial||w.isMeshStandardMaterial||w.isShadowMaterial||w.isShaderMaterial&&w.lights===!0}this.getActiveCubeFace=function(){return g},this.getActiveMipmapLevel=function(){return _},this.getRenderTarget=function(){return M},this.setRenderTargetTextures=function(w,D,H){oe.get(w.texture).__webglTexture=D,oe.get(w.depthTexture).__webglTexture=H;const O=oe.get(w);O.__hasExternalTextures=!0,O.__hasExternalTextures&&(O.__autoAllocateDepthBuffer=H===void 0,O.__autoAllocateDepthBuffer||Me.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),O.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(w,D){const H=oe.get(w);H.__webglFramebuffer=D,H.__useDefaultFramebuffer=D===void 0},this.setRenderTarget=function(w,D=0,H=0){M=w,g=D,_=H;let O=!0;if(w){const be=oe.get(w);be.__useDefaultFramebuffer!==void 0?(re.bindFramebuffer(F.FRAMEBUFFER,null),O=!1):be.__webglFramebuffer===void 0?ne.setupRenderTarget(w):be.__hasExternalTextures&&ne.rebindTextures(w,oe.get(w.texture).__webglTexture,oe.get(w.depthTexture).__webglTexture)}let X=null,ye=!1,Ee=!1;if(w){const be=w.texture;(be.isData3DTexture||be.isDataArrayTexture)&&(Ee=!0);const Ge=oe.get(w).__webglFramebuffer;w.isWebGLCubeRenderTarget?(X=Ge[D],ye=!0):Ce.isWebGL2&&w.samples>0&&ne.useMultisampledRTT(w)===!1?X=oe.get(w).__webglMultisampledFramebuffer:X=Ge,T.copy(w.viewport),R.copy(w.scissor),x=w.scissorTest}else T.copy(L).multiplyScalar(N).floor(),R.copy($).multiplyScalar(N).floor(),x=z;if(re.bindFramebuffer(F.FRAMEBUFFER,X)&&Ce.drawBuffers&&O&&re.drawBuffers(w,X),re.viewport(T),re.scissor(R),re.setScissorTest(x),ye){const be=oe.get(w.texture);F.framebufferTexture2D(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_CUBE_MAP_POSITIVE_X+D,be.__webglTexture,H)}else if(Ee){const be=oe.get(w.texture),Ge=D||0;F.framebufferTextureLayer(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0,be.__webglTexture,H||0,Ge)}E=-1},this.readRenderTargetPixels=function(w,D,H,O,X,ye,Ee){if(!(w&&w.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Re=oe.get(w).__webglFramebuffer;if(w.isWebGLCubeRenderTarget&&Ee!==void 0&&(Re=Re[Ee]),Re){re.bindFramebuffer(F.FRAMEBUFFER,Re);try{const be=w.texture,Ge=be.format,Fe=be.type;if(Ge!==Ui&&V.convert(Ge)!==F.getParameter(F.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Be=Fe===du&&(Me.has("EXT_color_buffer_half_float")||Ce.isWebGL2&&Me.has("EXT_color_buffer_float"));if(Fe!==wo&&V.convert(Fe)!==F.getParameter(F.IMPLEMENTATION_COLOR_READ_TYPE)&&!(Fe===ro&&(Ce.isWebGL2||Me.has("OES_texture_float")||Me.has("WEBGL_color_buffer_float")))&&!Be){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}D>=0&&D<=w.width-O&&H>=0&&H<=w.height-X&&F.readPixels(D,H,O,X,V.convert(Ge),V.convert(Fe),ye)}finally{const be=M!==null?oe.get(M).__webglFramebuffer:null;re.bindFramebuffer(F.FRAMEBUFFER,be)}}},this.copyFramebufferToTexture=function(w,D,H=0){if(D.isFramebufferTexture!==!0){console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");return}const O=Math.pow(2,-H),X=Math.floor(D.image.width*O),ye=Math.floor(D.image.height*O);ne.setTexture2D(D,0),F.copyTexSubImage2D(F.TEXTURE_2D,H,0,0,w.x,w.y,X,ye),re.unbindTexture()},this.copyTextureToTexture=function(w,D,H,O=0){const X=D.image.width,ye=D.image.height,Ee=V.convert(H.format),Re=V.convert(H.type);ne.setTexture2D(H,0),F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL,H.flipY),F.pixelStorei(F.UNPACK_PREMULTIPLY_ALPHA_WEBGL,H.premultiplyAlpha),F.pixelStorei(F.UNPACK_ALIGNMENT,H.unpackAlignment),D.isDataTexture?F.texSubImage2D(F.TEXTURE_2D,O,w.x,w.y,X,ye,Ee,Re,D.image.data):D.isCompressedTexture?F.compressedTexSubImage2D(F.TEXTURE_2D,O,w.x,w.y,D.mipmaps[0].width,D.mipmaps[0].height,Ee,D.mipmaps[0].data):F.texSubImage2D(F.TEXTURE_2D,O,w.x,w.y,Ee,Re,D.image),O===0&&H.generateMipmaps&&F.generateMipmap(F.TEXTURE_2D),re.unbindTexture()},this.copyTextureToTexture3D=function(w,D,H,O,X=0){if(m.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const ye=w.max.x-w.min.x+1,Ee=w.max.y-w.min.y+1,Re=w.max.z-w.min.z+1,be=V.convert(O.format),Ge=V.convert(O.type);let Fe;if(O.isData3DTexture)ne.setTexture3D(O,0),Fe=F.TEXTURE_3D;else if(O.isDataArrayTexture)ne.setTexture2DArray(O,0),Fe=F.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL,O.flipY),F.pixelStorei(F.UNPACK_PREMULTIPLY_ALPHA_WEBGL,O.premultiplyAlpha),F.pixelStorei(F.UNPACK_ALIGNMENT,O.unpackAlignment);const Be=F.getParameter(F.UNPACK_ROW_LENGTH),Xe=F.getParameter(F.UNPACK_IMAGE_HEIGHT),Sn=F.getParameter(F.UNPACK_SKIP_PIXELS),Hn=F.getParameter(F.UNPACK_SKIP_ROWS),Gn=F.getParameter(F.UNPACK_SKIP_IMAGES),Dt=H.isCompressedTexture?H.mipmaps[0]:H.image;F.pixelStorei(F.UNPACK_ROW_LENGTH,Dt.width),F.pixelStorei(F.UNPACK_IMAGE_HEIGHT,Dt.height),F.pixelStorei(F.UNPACK_SKIP_PIXELS,w.min.x),F.pixelStorei(F.UNPACK_SKIP_ROWS,w.min.y),F.pixelStorei(F.UNPACK_SKIP_IMAGES,w.min.z),H.isDataTexture||H.isData3DTexture?F.texSubImage3D(Fe,X,D.x,D.y,D.z,ye,Ee,Re,be,Ge,Dt.data):H.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),F.compressedTexSubImage3D(Fe,X,D.x,D.y,D.z,ye,Ee,Re,be,Dt.data)):F.texSubImage3D(Fe,X,D.x,D.y,D.z,ye,Ee,Re,be,Ge,Dt),F.pixelStorei(F.UNPACK_ROW_LENGTH,Be),F.pixelStorei(F.UNPACK_IMAGE_HEIGHT,Xe),F.pixelStorei(F.UNPACK_SKIP_PIXELS,Sn),F.pixelStorei(F.UNPACK_SKIP_ROWS,Hn),F.pixelStorei(F.UNPACK_SKIP_IMAGES,Gn),X===0&&O.generateMipmaps&&F.generateMipmap(Fe),re.unbindTexture()},this.initTexture=function(w){ne.setTexture2D(w,0),re.unbindTexture()},this.resetState=function(){g=0,_=0,M=null,re.reset(),Ae.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}Ib.prototype.isWebGLRenderer=!0;const fu={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`};class Au{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}const BH=new yl(-1,1,1,-1,0,1),Gv=new lt;Gv.setAttribute("position",new rt([-1,3,0,-1,-1,0,3,-1,0],3));Gv.setAttribute("uv",new rt([0,2,0,0,2,0],2));class Nb{constructor(e){this._mesh=new dt(Gv,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,BH)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class pu extends Au{constructor(e,t){super(),this.textureID=t!==void 0?t:"tDiffuse",e instanceof Zt?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=md.clone(e.uniforms),this.material=new Zt({defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new Nb(this.material)}render(e,t,i){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=i.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}}class fS extends Au{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,i){const r=e.getContext(),s=e.state;s.buffers.color.setMask(!1),s.buffers.depth.setMask(!1),s.buffers.color.setLocked(!0),s.buffers.depth.setLocked(!0);let o,a;this.inverse?(o=0,a=1):(o=1,a=0),s.buffers.stencil.setTest(!0),s.buffers.stencil.setOp(r.REPLACE,r.REPLACE,r.REPLACE),s.buffers.stencil.setFunc(r.ALWAYS,o,4294967295),s.buffers.stencil.setClear(a),s.buffers.stencil.setLocked(!0),e.setRenderTarget(i),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),s.buffers.color.setLocked(!1),s.buffers.depth.setLocked(!1),s.buffers.stencil.setLocked(!1),s.buffers.stencil.setFunc(r.EQUAL,1,4294967295),s.buffers.stencil.setOp(r.KEEP,r.KEEP,r.KEEP),s.buffers.stencil.setLocked(!0)}}class zH extends Au{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class kH{constructor(e,t){if(this.renderer=e,t===void 0){const i=e.getSize(new fe);this._pixelRatio=e.getPixelRatio(),this._width=i.width,this._height=i.height,t=new on(this._width*this._pixelRatio,this._height*this._pixelRatio),t.texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=t.width,this._height=t.height;this.renderTarget1=t,this.renderTarget2=t.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],fu===void 0&&console.error("THREE.EffectComposer relies on CopyShader"),pu===void 0&&console.error("THREE.EffectComposer relies on ShaderPass"),this.copyPass=new pu(fu),this.clock=new ZP}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);t!==-1&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0}render(e){e===void 0&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let i=!1;for(let r=0,s=this.passes.length;r<s;r++){const o=this.passes[r];if(o.enabled!==!1){if(o.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(r),o.render(this.renderer,this.writeBuffer,this.readBuffer,e,i),o.needsSwap){if(i){const a=this.renderer.getContext(),l=this.renderer.state.buffers.stencil;l.setFunc(a.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),l.setFunc(a.EQUAL,1,4294967295)}this.swapBuffers()}fS!==void 0&&(o instanceof fS?i=!0:o instanceof zH&&(i=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(e===void 0){const t=this.renderer.getSize(new fe);this._pixelRatio=this.renderer.getPixelRatio(),this._width=t.width,this._height=t.height,e=this.renderTarget1.clone(),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const i=this._width*this._pixelRatio,r=this._height*this._pixelRatio;this.renderTarget1.setSize(i,r),this.renderTarget2.setSize(i,r);for(let s=0;s<this.passes.length;s++)this.passes[s].setSize(i,r)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}}new yl(-1,1,1,-1,0,1);const Fb=new lt;Fb.setAttribute("position",new rt([-1,3,0,-1,-1,0,3,-1,0],3));Fb.setAttribute("uv",new rt([0,2,0,0,2,0],2));class HH extends Au{constructor(e,t,i,r,s){super(),this.scene=e,this.camera=t,this.overrideMaterial=i,this.clearColor=r,this.clearAlpha=s!==void 0?s:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new we}render(e,t,i){const r=e.autoClear;e.autoClear=!1;let s,o;this.overrideMaterial!==void 0&&(o=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(e.getClearColor(this._oldClearColor),s=e.getClearAlpha(),e.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:i),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),this.clearColor&&e.setClearColor(this._oldClearColor,s),this.overrideMaterial!==void 0&&(this.scene.overrideMaterial=o),e.autoClear=r}}const pS={shaderID:"luminosityHighPass",uniforms:{tDiffuse:{value:null},luminosityThreshold:{value:1},smoothWidth:{value:1},defaultColor:{value:new we(0)},defaultOpacity:{value:0}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`};class vl extends Au{constructor(e,t,i,r){super(),this.strength=t!==void 0?t:1,this.radius=i,this.threshold=r,this.resolution=e!==void 0?new fe(e.x,e.y):new fe(256,256),this.clearColor=new we(0,0,0),this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;let s=Math.round(this.resolution.x/2),o=Math.round(this.resolution.y/2);this.renderTargetBright=new on(s,o),this.renderTargetBright.texture.name="UnrealBloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let h=0;h<this.nMips;h++){const d=new on(s,o);d.texture.name="UnrealBloomPass.h"+h,d.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(d);const p=new on(s,o);p.texture.name="UnrealBloomPass.v"+h,p.texture.generateMipmaps=!1,this.renderTargetsVertical.push(p),s=Math.round(s/2),o=Math.round(o/2)}pS===void 0&&console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");const a=pS;this.highPassUniforms=md.clone(a.uniforms),this.highPassUniforms.luminosityThreshold.value=r,this.highPassUniforms.smoothWidth.value=.01,this.materialHighPassFilter=new Zt({uniforms:this.highPassUniforms,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader,defines:{}}),this.separableBlurMaterials=[];const l=[3,5,7,9,11];s=Math.round(this.resolution.x/2),o=Math.round(this.resolution.y/2);for(let h=0;h<this.nMips;h++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(l[h])),this.separableBlurMaterials[h].uniforms.texSize.value=new fe(s,o),s=Math.round(s/2),o=Math.round(o/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=t,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.needsUpdate=!0;const c=[1,.8,.6,.4,.2];this.compositeMaterial.uniforms.bloomFactors.value=c,this.bloomTintColors=[new B(1,1,1),new B(1,1,1),new B(1,1,1),new B(1,1,1),new B(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,fu===void 0&&console.error("THREE.UnrealBloomPass relies on CopyShader");const u=fu;this.copyUniforms=md.clone(u.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new Zt({uniforms:this.copyUniforms,vertexShader:u.vertexShader,fragmentShader:u.fragmentShader,blending:Om,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new we,this.oldClearAlpha=1,this.basic=new Fn,this.fsQuad=new Nb(null)}dispose(){for(let e=0;e<this.renderTargetsHorizontal.length;e++)this.renderTargetsHorizontal[e].dispose();for(let e=0;e<this.renderTargetsVertical.length;e++)this.renderTargetsVertical[e].dispose();this.renderTargetBright.dispose()}setSize(e,t){let i=Math.round(e/2),r=Math.round(t/2);this.renderTargetBright.setSize(i,r);for(let s=0;s<this.nMips;s++)this.renderTargetsHorizontal[s].setSize(i,r),this.renderTargetsVertical[s].setSize(i,r),this.separableBlurMaterials[s].uniforms.texSize.value=new fe(i,r),i=Math.round(i/2),r=Math.round(r/2)}render(e,t,i,r,s){e.getClearColor(this._oldClearColor),this.oldClearAlpha=e.getClearAlpha();const o=e.autoClear;e.autoClear=!1,e.setClearColor(this.clearColor,0),s&&e.state.buffers.stencil.setTest(!1),this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=i.texture,e.setRenderTarget(null),e.clear(),this.fsQuad.render(e)),this.highPassUniforms.tDiffuse.value=i.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.fsQuad.material=this.materialHighPassFilter,e.setRenderTarget(this.renderTargetBright),e.clear(),this.fsQuad.render(e);let a=this.renderTargetBright;for(let l=0;l<this.nMips;l++)this.fsQuad.material=this.separableBlurMaterials[l],this.separableBlurMaterials[l].uniforms.colorTexture.value=a.texture,this.separableBlurMaterials[l].uniforms.direction.value=vl.BlurDirectionX,e.setRenderTarget(this.renderTargetsHorizontal[l]),e.clear(),this.fsQuad.render(e),this.separableBlurMaterials[l].uniforms.colorTexture.value=this.renderTargetsHorizontal[l].texture,this.separableBlurMaterials[l].uniforms.direction.value=vl.BlurDirectionY,e.setRenderTarget(this.renderTargetsVertical[l]),e.clear(),this.fsQuad.render(e),a=this.renderTargetsVertical[l];this.fsQuad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,e.setRenderTarget(this.renderTargetsHorizontal[0]),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,s&&e.state.buffers.stencil.setTest(!0),this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(i),this.fsQuad.render(e)),e.setClearColor(this._oldClearColor,this.oldClearAlpha),e.autoClear=o}getSeperableBlurMaterial(e){return new Zt({defines:{KERNEL_RADIUS:e,SIGMA:e},uniforms:{colorTexture:{value:null},texSize:{value:new fe(.5,.5)},direction:{value:new fe(.5,.5)}},vertexShader:`varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,fragmentShader:`#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`})}getCompositeMaterial(e){return new Zt({defines:{NUM_MIPS:e},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:`varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,fragmentShader:`varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`})}}vl.BlurDirectionX=new fe(1,0);vl.BlurDirectionY=new fe(0,1);class GH{constructor(){this.lastUsedId=0,this.flashes={},this.outputVector=new B}addNewFlash(e){const t=this.lastUsedId+1;return this.lastUsedId=t,this.flashes[t]=e,t}setFlashValue(e,t){if(this.flashes[e])this.flashes[e].copy(t);else throw new Error(`Bad id given ${e}`)}removeFlash(e){delete this.flashes[e]}getAllFlashesColor(){const e=this.outputVector;return e.set(0,0,0),Object.values(this.flashes).forEach(t=>{e.set(e.x+t.x,e.y+t.y,e.z+t.z)}),e.set(this.clampFlashValue(e.x),this.clampFlashValue(e.y),this.clampFlashValue(e.z)),e}clampFlashValue(e){return Ze.clamp(e,0,.15)}}const ud=new GH,Ub=(n,e=.25,t=.003)=>{let i=e;const r=new B;r.set(n[0],n[1],n[2]),r.multiplyScalar(i);const s=ud.addNewFlash(r),o=setInterval(()=>{r.set(n[0],n[1],n[2]),r.multiplyScalar(i),ud.setFlashValue(s,r),i=i-t,i<=0&&o&&(ud.removeFlash(s),clearInterval(o))},16)},VH={uniforms:{tDiffuse:{value:null},color:{value:new we(16777215)}},vertexShader:`
		varying vec2 vUv;
		void main() {
    		vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,fragmentShader:`
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec2 vUv;
		void main() {
			vec4 texel = texture2D( tDiffuse, vUv );
			// vec3 luma = vec3( 0.299, 0.587, 0.114 );
			// float v = dot( texel.xyz, luma );
			gl_FragColor = vec4(vec3(texel) + color, texel.w);
		}`},Ob=new pu(VH),WH=()=>{const{x:n,y:e,z:t}=ud.getAllFlashesColor();Ob.uniforms.color.value.setRGB(n,e,t)};var $H={uniforms:{time:{value:0},tDiffuse:{value:null}},vertexShader:`
        varying vec2 vUv;
		void main() {
    		vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
		}
    `,fragmentShader:`
        float rand(float n){return fract(sin(n) * 43758.5453123);}
        uniform float time;
        uniform sampler2D tDiffuse;

        varying vec2 vUv;

        void main() {
            vec2 shakeOffset = vec2(rand(time * 2.0) / 250.0);
            vec4 texel = texture2D(tDiffuse, vUv + shakeOffset);
            gl_FragColor = texel;
        }
    `};const yc=document.querySelector("#three-canvas-container");if(yc===null)throw new Error("Document needs #three-canvas-container");const Gd=document.querySelector("#three-canvas");if(Gd===null)throw new Error("Document needs #three-canvas.");const Vv=new Ib({canvas:Gd,antialias:!0}),Zs=new kH(Vv),Bb=()=>{Vv.setSize(yc.clientWidth,yc.clientHeight),Zs.setSize(yc.clientWidth,yc.clientHeight)};window.addEventListener("resize",()=>{Bb()});Vv.setClearColor(0);Bb();const XH=new fe(Gd.clientWidth,Gd.clientHeight),jH=new vl(XH,.1,.002,.7),$a=new pu($H);$a.enabled=!1;const zb=new pu(fu);zb.renderToScreen=!0;let Pm=null;const Wv=n=>{Pm||($a.enabled=!0,Pm=setTimeout(()=>{$a.enabled=!1,Pm=null},n))};let kb=!1,Vd=null,oc=null,$h=0;const mu=(n=!0,e)=>{kb=n,n===!1?Vd=null:n===!0&&e&&(Vd=e)},r0=()=>{mu(!1)};let mS=0;const qH=(n,e,t)=>{const i=new HH(n,e);Zs.addPass(i),Zs.addPass(jH),Zs.addPass(Ob),Zs.addPass($a),Zs.addPass(zb);const r=s=>{if(kb)oc===null&&(oc=s),Vd&&Vd(s);else{oc!==null&&($h+=s-oc,oc=null),$a.enabled&&($a.uniforms.time.value=Math.random()),WH();const o=s-$h,a=o-mS;a>500&&($h+=a),mS=o,t(s-$h,a),Zs.render()}window.requestAnimationFrame(r)};window.requestAnimationFrame(r)},Dm={},gS=new we(1,0,0),vS=new we(1,1,1);class $v{constructor(e,t,i,r=5,s=5,o=50){this.frameAmount=s,this.animationSpeed=o,this.flipped=!1,this.currentlyAppliedFlip=!1,Dm[e]||(Dm[e]=new A0().load(e)),this.texture=Dm[e],this.mat=new Zt({uniforms:{uTex:{value:this.texture},uTexWidth:{value:0},uBlendColor:{value:new we(1,1,1)},uFrameAmount:{value:s},uCurrentFrame:{value:0},uFlipped:{value:0}},vertexShader:`
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,fragmentShader:`
                uniform sampler2D uTex;
                uniform float uFlipped;
                uniform float uFrameAmount;
                uniform float uCurrentFrame;
                uniform float uTexWidth;
                uniform vec3 uBlendColor;
                varying vec2 vUv;
                void main() {

                    float windowSize = 1.0 / uFrameAmount;

                    vec2 viewedRange = vec2(windowSize * uCurrentFrame, windowSize * (uCurrentFrame + 1.0));

                    vec2 adjustedUv = (vUv / vec2(uFrameAmount, 1.0)) + vec2(1.0 / uFrameAmount * uCurrentFrame, 0.0);

                    vec2 orientedUv = uFlipped == 0.0 ? adjustedUv : vec2(viewedRange.x + (viewedRange.y - adjustedUv.x), adjustedUv.y);

                    vec4 texel = texture2D(
                        uTex, 
                        orientedUv
                    );

                    gl_FragColor = vec4(texel) * vec4(uBlendColor, 1.0);

                    if (gl_FragColor.a < 0.1) {
                        discard;
                    }

                }
            `}),this.mesh=new dt(new Yd(t,i),this.mat),this.setFlipped(!0),this.lastFrame=-1,this.lastFrameTime=-1,this.mesh.rotateOnAxis(new B(1,0,0),-Math.PI/2),this.mesh.rotateOnAxis(new B(1,0,0),Math.PI/5),this.mesh.position.y=r}flashRed(){this.mat.uniforms.uBlendColor.value=gS,setTimeout(()=>{this.mat.uniforms.uBlendColor.value=vS},500)}setRed(){this.mat.uniforms.uBlendColor.value=gS}setWhite(){this.mat.uniforms.uBlendColor.value=vS}setFlipped(e){this.currentlyAppliedFlip!==e&&(this.currentlyAppliedFlip=e,this.flipped=e,this.mat.uniforms.uFlipped.value=e?1:0,this.resetPlay())}resetPlay(){this.lastFrameTime=-1,this.lastFrame=-1}setFrame(e){this.mat.uniforms.uCurrentFrame.value=e}update(e,t,i){this.setFlipped(t),this.texture.image&&this.mat.uniforms.uTexWidth.value===0&&(this.mat.uniforms.uTexWidth.value=this.texture.image.width),i?e-this.lastFrameTime>this.animationSpeed&&(this.lastFrameTime=e,this.lastFrame=this.lastFrame+1,this.setFrame(this.lastFrame),this.lastFrame===this.frameAmount-1&&(this.lastFrame=-1)):this.resetPlay()}}const yn=(n,e,t,i,r)=>!(Math.abs(e-t)>n||Math.abs(i-r)>n);function Hb(n,e){let t=0;return(...i)=>{if(t===0)return t++,n(...i);t++,t===e&&(t=0)}}const gu=(n,e,t,i,r=!1)=>{var s,o;r&&((s=n.parent)==null||s.localToWorld(n.position)),n.position.sub(e),n.position.applyAxisAngle(t,i),n.position.add(e),r&&((o=n.parent)==null||o.worldToLocal(n.position)),n.rotateOnAxis(t,i)};class ii{constructor(){this.group=new yt,this.minDamage=0,this.maxDamage=0,this.hitDelay=1e3,this.stunValue=500,this.minute=null}update(e,t,i,r){throw new Error("Not implemented")}detectCollision(e,t){throw new Error("Not implemented")}onEnemyCollide(e){throw new Error("Not implemented")}}const Gb=class extends ii{constructor(){super(),this.stunValue=1e3,this.minDamage=15,this.maxDamage=25;const n=30,e=101/(664/3);this.sprite=new $v(ZU,n,n*e,5,3),this.group=this.sprite.mesh}update(n,e,t){const i=Math.sin(n/500),r=Math.cos(n/500);this.group.position.x=t.x+i*100,this.group.position.y=10,this.group.position.z=t.y+Math.sin(n/200)*50,this.sprite.update(n,r<0,!0)}detectCollision(n){return yn(Gb.COLLIDE_DISTANCE,this.group.position.x,n.object.position.x,this.group.position.z,n.object.position.z)}onEnemyCollide(){Wv(200),Mf.play()}};let Vb=Gb;Vb.COLLIDE_DISTANCE=18;const Wb=class extends ii{constructor(n,e){super(),this.stunValue=50,this.minDamage=10,this.maxDamage=15,this.minute=1,this.activeProjectiles=[],this.lastThrowTime=0,this.collisionLight=new Jn(16703234,10,50),this.movementVector=new B,this.group=new yt,this.scene=e,this.modelMesh=n,this.modelMesh.scale.set(.5,.5,.5),this.scene.add(this.collisionLight)}update(n,e,t){if(this.group.position.set(t.x,20,t.y),n-this.lastThrowTime>1e3){const i=this.modelMesh.clone();i.position.copy(this.group.position),this.scene.add(i),CN.play(),i.rotation.y=-Math.PI/2-Math.PI/6,this.activeProjectiles.push({mesh:i,thrownTime:n}),this.lastThrowTime=n}this.activeProjectiles.forEach(i=>{this.movementVector.copy(Wb.ONE_DIR),this.movementVector.multiplyScalar(e/16.667),i.mesh.position.add(this.movementVector),n-i.thrownTime>2500&&(this.activeProjectiles=this.activeProjectiles.filter(r=>r!==i),this.scene.remove(i.mesh))}),this.collisionLight.intensity-=3,this.collisionLight.intensity=Math.max(0,this.collisionLight.intensity)}detectCollision(n){return this.activeProjectiles.some(e=>yn(15,e.mesh.position.x,n.object.position.x,e.mesh.position.z,n.object.position.z))}onEnemyCollide(n){this.collisionLight.position.copy(n.object.position),this.collisionLight.intensity=50,xf.play()}};let Xv=Wb;Xv.ONE_DIR=new B(0,0,-1).applyAxisAngle(new B(0,1,0),-Math.PI/6).multiplyScalar(5);class $b extends ii{constructor(e,t){super(),this.stunValue=2500,this.minDamage=10,this.maxDamage=20,this.minute=2,this.group=new yt,this.modelMesh=e,this.group.add(this.modelMesh),this.modelMesh.scale.set(1.5,1.5,1.5),this.modelMesh.position.z=-30,this.modelMesh.rotation.y=-Math.PI/2}update(e,t,i){this.group.position.set(i.x,20,i.y),this.group.rotation.y-=.075*(t/16.667),this.group.rotation.y<-Math.PI*2&&(this.group.rotation.y=0);let r=(1+(1-Math.sin(this.group.rotation.y)))/2;r=r*2,this.modelMesh.scale.set(r,r,r)}detectCollision(e){const t=this.modelMesh.position.clone().applyMatrix4(this.group.matrixWorld);return yn(25,t.x,e.object.position.x,t.z,e.object.position.z)}onEnemyCollide(e){Wv(500),Mf.play()}}$b.TWO_DIR=new B(0,0,-1).applyAxisAngle(new B(0,1,0),-Math.PI/6*2);class YH extends ii{constructor(e,t){super(),this.traps=[],this.minDamage=8,this.maxDamage=10,this.stunValue=500,this.hitDelay=600,this.minute=3,this.lastPlace=0,this.group=new yt,this.scene=t,this.modelMesh=e,this.modelMesh.scale.set(2,2,2),this.modelMesh.position.y=5}placeTrap(e,t){const i=this.modelMesh.clone();this.scene.add(i),i.position.set(t.x+30,5,t.y),this.traps.push({mesh:i}),RN.play(),this.lastPlace=e}removeOldestTrap(){this.scene.remove(this.traps[0].mesh),this.traps=this.traps.slice(1)}update(e,t,i){e-this.lastPlace>3e3&&(this.placeTrap(e,i),this.traps.length>3&&this.removeOldestTrap())}detectCollision(e){return this.traps.some(t=>yn(25,t.mesh.position.x,e.object.position.x,t.mesh.position.z,e.object.position.z))}onEnemyCollide(e){yf.play()}}class KH extends ii{constructor(e,t){super(),this.hitboxPosV=new B,this.minDamage=15,this.maxDamage=25,this.stunValue=1e3,this.hitDelay=1500,this.minute=4,this.group=new yt,this.scene=t,this.modelMesh=e,this.group.add(this.modelMesh),this.modelMesh.position.x=-35,this.modelMesh.scale.set(1.5,1.5,1.5),gu(this.modelMesh,new B(0,0,0),new B(0,1,0),Math.PI/6*4,!0),this.hitboxMesh=new dt(new Ji(12,12,12,1,1,1)),this.hitboxMesh.visible=!1,this.group.add(this.hitboxMesh),this.hitboxMesh.position.x=-35,gu(this.hitboxMesh,new B(0,0,0),new B(0,1,0),Math.PI/6*4,!0)}update(e,t,i){this.group.position.set(i.x,5,i.y)}detectCollision(e){return this.hitboxPosV.copy(this.hitboxMesh.position),this.hitboxPosV.applyMatrix4(this.group.matrixWorld),yn(10,this.hitboxPosV.x,e.object.position.x,this.hitboxPosV.z,e.object.position.z)}onEnemyCollide(e){PN.play()}}class ZH extends ii{constructor(e,t){super(),this.minDamage=5,this.maxDamage=10,this.stunValue=1500,this.hitDelay=3500,this.minute=5,this.shields=[],this._v=new B,this.group=new yt,this.scene=t,this.modelMesh=e,this.modelMesh.scale.set(1.5,1.5,1.5),this.modelMesh.rotation.y=Math.PI/2,this.shields=new Array(5).fill("").map(()=>this.modelMesh.clone()),this.shields.forEach(i=>this.group.add(i))}update(e,t,i){this.group.position.set(i.x,5,i.y);let r=-e/300;this.shields.forEach((s,o)=>{let a=r+o*250;const l=Math.sin(a)*50,c=Math.cos(a)*50;s.position.set(l,5,c)})}detectCollision(e){return this.shields.some(t=>(this._v.copy(t.position).applyMatrix4(this.group.matrixWorld),yn(20,this._v.x,e.object.position.x,this._v.z,e.object.position.z)))}onEnemyCollide(e){yf.play()}}class JH extends ii{constructor(e,t){super(),this.stunValue=5,this.minDamage=1,this.maxDamage=1,this.hitDelay=0,this.minute=6,this.activeProjectiles=[],this.sourceLight=new Jn(14548736,2,15),this.movementVector=new B,this.findVector=new B,this.findBox=new Mn,this.shotDelay=200,this.lastShotTime=0,this.group=new yt,this.scene=t,this.modelMesh=e,this.modelMesh.position.z=25,this.sourceLight.position.z=15,this.group.add(this.modelMesh),this.group.add(this.sourceLight)}makeProjectileMesh(){return new dt(new E0(2,20,20),new el({color:10070528,shininess:100}))}findEnemyInRange(e,t){this.findVector.set(e.x,0,e.y),new Gi(this.findVector,100).getBoundingBox(this.findBox);const r=t.filter(s=>{const o=s.object.position;return this.findBox.containsPoint(o)});return r.length===0?null:r[Ze.randInt(0,r.length-1)]}update(e,t,i,r){if(this.group.position.set(i.x,5,i.y),this.modelMesh.rotation.y=-Math.PI/2+Math.sin(e/500)/2,this.activeProjectiles.length<6&&e-this.lastShotTime>this.shotDelay){this.findVector.set(i.x,0,i.y),new Gi(this.findVector,100).getBoundingBox(this.findBox);const o=r.filter(a=>{const l=a.object.position;return this.findBox.containsPoint(l)});if(o.length!==0){const a=o[Ze.randInt(0,o.length-1)],l=this.makeProjectileMesh();l.position.copy(this.group.position),l.position.z+=15,l.position.y=40,this.lastShotTime=e,this.scene.add(l),this.activeProjectiles.push({target:a,mesh:l})}}this.activeProjectiles.forEach(s=>{const{mesh:o,target:a}=s;if(a.isDead){const u=this.findEnemyInRange(i,r);u===null?(this.scene.remove(o),this.activeProjectiles=this.activeProjectiles.filter(h=>h.mesh!==o)):s.target=u;return}const l=a.object.position;this.movementVector.subVectors(l,o.position),this.movementVector.normalize(),this.movementVector.multiplyScalar(1.5),o.position.add(this.movementVector),yn(1,o.position.x,l.x,o.position.z,l.z)&&(this.scene.remove(o),this.activeProjectiles=this.activeProjectiles.filter(u=>u.mesh!==o))})}detectCollision(e){const t=this.activeProjectiles.filter(({target:s})=>s===e);if(t.length===0)return!1;const i=e.object.position;return t.filter(({mesh:s})=>yn(5,s.position.x,i.x,s.position.z,i.z)).length>0}onEnemyCollide(e){xf.play()}}class QH extends ii{constructor(e,t){super(),this.stunValue=150,this.minDamage=5,this.maxDamage=10,this.hitDelay=750,this.minute=7,this.sourceLight=new Jn(16755200,1,100),this.group=new yt,this.scene=t,this.modelMesh=e,this.group.add(this.modelMesh),this.group.add(this.sourceLight),this.sourceLight.position.y+=70,this.modelMesh.position.x=-30,this.modelMesh.scale.set(1.5,1.5,1.5),gu(this.modelMesh,new B(0,0,0),new B(0,1,0),Math.PI/6*2,!0)}update(e,t,i,r){this.group.position.set(i.x,5,i.y)}detectCollision(e){const t=e.object.position,i=this.group.position;return yn(50,t.x,i.x,t.z,i.z)}onEnemyCollide(e){yf.play()}}class eG extends ii{constructor(e,t){super(),this.stunValue=150,this.minDamage=5,this.maxDamage=10,this.hitDelay=175,this.minute=8,this.activeStacks=[],this.lastPlacedTime=-8e3,this.findVector=new B,this.findBox=new Mn,this.group=new yt,this.scene=t,this.modelMesh=e,this.modelMesh.rotation.y=Math.PI/2,this.modelMesh.rotation.x=Math.PI/10,this.modelMesh.position.y=5}findEnemyInRange(e,t){this.findVector.set(e.x,0,e.y),new Gi(this.findVector,100).getBoundingBox(this.findBox);const r=t.filter(s=>{const o=s.object.position;return this.findBox.containsPoint(o)});return r.length===0?null:r[Ze.randInt(0,r.length-1)]}update(e,t,i,r){if(e-this.lastPlacedTime>8e3){const s=this.findEnemyInRange(i,r);if(s){this.lastPlacedTime=e;const o=new yt;o.position.copy(s.object.position),o.position.y=0;const a=this.modelMesh.clone();o.add(a);const l=new dt(new vu(80,80,2),new Fn({color:2236962}));l.scale.set(.1,.1,.1),l.position.y=1,l.name="smoke",o.add(l),this.scene.add(o),this.activeStacks.push({group:o,timePlaced:e}),LN.play()}}this.activeStacks=this.activeStacks.filter(({group:s,timePlaced:o})=>e-o>7500?(this.scene.remove(s),!1):!0),this.activeStacks.forEach(s=>{const o=s.group.getObjectByName("smoke");if(!o)throw new Error("No smoke?");if(o.scale.x<1){const a=o.scale.x+.01;o.scale.set(a,a,a)}})}detectCollision(e){return this.activeStacks.some(({group:t})=>{const i=e.object.position;return yn(50,i.x,t.position.x,i.z,t.position.z)})}onEnemyCollide(e){yf.play()}}class tG extends ii{constructor(e,t){super(),this.stunValue=300,this.minDamage=8,this.maxDamage=13,this.hitDelay=500,this.minute=9,this.placedCoils=[],this.placeDelay=2500,this.lastPlacedTime=-500,this.findVector=new B,this.findBox=new Mn,this._yellow=16776960,this.lights=[new Jn(this._yellow,1,80),new Jn(this._yellow,1,80),new Jn(this._yellow,1,80)],this.group=new yt,this.scene=t,this.modelMesh=e,this.modelMesh.scale.set(2,2,2),this.lights.forEach(i=>{this.scene.add(i),i.intensity=0}),this.lightningMesh=new dt(new vu(1,5,70),new Fn({color:this._yellow})),this.lightningMesh.position.y=40,this.lightningMesh.rotation.y=Math.PI/2,this.lightningMesh.visible=!1,this.scene.add(this.lightningMesh)}findEnemyInRange(e,t){this.findVector.set(e.x,0,e.y),new Gi(this.findVector,100).getBoundingBox(this.findBox);const r=t.filter(s=>{const o=s.object.position;return this.findBox.containsPoint(o)});return r.length===0?null:r[Ze.randInt(0,r.length-1)]}update(e,t,i,r){if(e-this.lastPlacedTime>this.placeDelay&&this.placedCoils.length<3){const s=this.findEnemyInRange(i,r);if(s){this.lastPlacedTime=e;const o=new yt,a=this.modelMesh.clone();o.add(a),o.position.copy(s.object.position),o.position.y=0,this.scene.add(o),this.placedCoils.push({group:o,timePlaced:e,lastZapTime:e}),this.lights.forEach((l,c)=>{this.placedCoils[c]?(l.position.copy(this.placedCoils[c].group.position),l.position.y=10,l.intensity=2):l.intensity=0})}}this.placedCoils=this.placedCoils.filter((s,o)=>e-s.timePlaced>9e3?(this.scene.remove(s.group),this.lights[o].intensity=0,!1):!0)}detectCollision(e,t){const i=e.object.position;return this.placedCoils.some(r=>{const s=r.group.position;return t-r.lastZapTime<100?!1:Ze.randFloat(0,1)<.05?(this.lightningMesh.visible=!1,!1):yn(40,i.x,s.x,i.z,s.z)?(r.lastZapTime=t,this.lightningMesh.visible=!0,this.lightningMesh.position.set(i.x,20,i.z),!0):!1})}onEnemyCollide(e){xf.play()}}class Xb extends ii{constructor(e,t){super(),this.stunValue=250,this.minDamage=6,this.maxDamage=10,this.hitDelay=500,this.minute=10,this.throwDelay=250,this.activeProjectiles=[],this.lastThrowTime=0,this.collisionLight=new Jn(16703234,10,50),this.movementVector=new B,this.group=new yt,this.scene=t,this.modelMesh=e,this.modelMesh.scale.set(.75,.75,.75),this.scene.add(this.collisionLight)}update(e,t,i){if(this.group.position.set(i.x,20,i.y),e-this.lastThrowTime>this.throwDelay){const r=this.modelMesh.clone();r.position.copy(this.group.position),this.scene.add(r),r.rotation.y=-Math.PI/2-Math.PI/6;const s=this.movementVector.copy(Xv.ONE_DIR).clone();Ze.randFloat(0,1)>.5&&(s.x*=-1),Ze.randFloat(0,1)>.5&&(s.z*=-1),s.normalize(),this.activeProjectiles.push({mesh:r,thrownTime:e,dir:s}),this.lastThrowTime=e}this.activeProjectiles.forEach(r=>{r.dir.normalize(),r.dir.multiplyScalar(t/16.667),r.dir.multiplyScalar(4),r.mesh.position.add(r.dir),r.mesh.rotation.y-=.3,e-r.thrownTime>1500&&(this.activeProjectiles=this.activeProjectiles.filter(s=>s!==r),this.scene.remove(r.mesh))}),this.collisionLight.intensity-=3,this.collisionLight.intensity=Math.max(0,this.collisionLight.intensity)}detectCollision(e){return this.activeProjectiles.some(t=>yn(15,t.mesh.position.x,e.object.position.x,t.mesh.position.z,e.object.position.z))}onEnemyCollide(e){this.collisionLight.position.copy(e.object.position),this.collisionLight.intensity=50,xf.play()}}Xb.ONE_DIR=new B(0,0,-1).applyAxisAngle(new B(0,1,0),-Math.PI/6).multiplyScalar(5);class jb extends ii{constructor(e,t){super(),this.stunValue=300,this.minDamage=20,this.maxDamage=25,this.minute=11,this.activeProjectiles=[],this.lastThrowsTime=-11e3,this.delay=11e3,this.scene=t,this.group=new yt,this.modelMesh=e,this.modelMesh.scale.set(2,2,2)}update(e,t,i){if(this.group.position.set(i.x,20,i.y),e-this.lastThrowsTime>this.delay){for(let r=0;r<11;r++){const s=this.modelMesh.clone();this.scene.add(s),s.visible=!1,this.activeProjectiles.push({mesh:s,thrownTime:e,showDelay:r*500,shown:!1,dir:new B(Ze.randFloat(-3,3),0,-5)})}this.lastThrowsTime=e}this.activeProjectiles.forEach(r=>{if(!r.shown)if(e>r.thrownTime+r.showDelay)r.shown=!0,r.mesh.visible=!0,r.mesh.position.set(i.x,2,i.y);else return;r.mesh.position.add(r.dir),r.mesh.rotation.y+=.1,r.dir.z+=.1})}detectCollision(e){return this.activeProjectiles.some(t=>{const i=t.mesh.position,r=e.object.position;return yn(30,i.x,r.x,i.z,r.z)})}onEnemyCollide(e){Mf.play()}}jb.ELEVEN_DIR=new B(0,0,-1).applyAxisAngle(new B(0,1,0),-Math.PI/6*11);class nG extends ii{constructor(e,t){super(),this.stunValue=1e3,this.minDamage=40,this.maxDamage=70,this.hitDelay=100,this.minute=12,this.tickDelay=1e3/12,this.lastTick=0,this.lights=[],this._v3=new B(0,0,0),this._axis=new B(0,1,0),this._box=new Mn,this.group=new yt,this.scene=t,this.modelMesh=e,this.group.add(this.modelMesh),this.modelMesh.rotation.y=-Math.PI/2,this.modelMesh.position.z=-75,this.modelMesh.scale.set(2,50,2),this.lights.push(new Jn(65535),new Jn(65535),new Jn(65535)),this.lights.forEach((i,r)=>{this.group.add(i),i.intensity=1,i.distance=40,i.position.z=-50+-50*r})}update(e,t,i,r){this.group.position.set(i.x,15,i.y),e-this.lastTick>this.tickDelay&&(gu(this.modelMesh,this._v3,this._axis,-Math.PI/6),this.lights.forEach(s=>{gu(s,this._v3,this._axis,-Math.PI/6),s.intensity=Ze.randFloat(1,2)}),this.lastTick=e),this.lights.forEach(s=>{s.position.y=this.group.position.y+Math.sin(e/100)*5+5})}detectCollision(e){return this._box.setFromObject(this.modelMesh),this._box.expandByScalar(1.5),!!this._box.containsPoint(e.object.position)}onEnemyCollide(e){Mf.play()}}var iG="/assets/felix-walk.051702d0.png";class rG{constructor(e,t,i){this.health=4,this.maxHealth=4,this.lastDamageTakenTime=-1,this.sprite=e,this.sprite.mesh.position.y=10,this.sprite.mesh.position.x=0,this.sprite.mesh.position.z=80,this.camera=new gn(80,16/9),this.camera.position.y=10,this.aura=new Jn(11184810,10,50),t.add(this.aura),this.ui=i}getPosition(){return new fe(this.sprite.mesh.position.x,this.sprite.mesh.position.z)}getBox(){const e=this.sprite.mesh.geometry.boundingBox;if(!e)throw new Error("Felix has no bounding box. Why?");return e}runUpdate(e){this.aura.position.copy(this.sprite.mesh.position),this.aura.position.y=45,this.camera.position.set(this.sprite.mesh.position.x,this.camera.position.y,this.sprite.mesh.position.z);const t=this.sprite.mesh.position.z;this.camera.rotation.x=-Math.PI/2,this.camera.rotation.x+=Math.PI/12+Math.PI/12*(t/250),this.camera.fov=80+Math.max(0,t)*.01,this.camera.updateProjectionMatrix(),this.camera.position.y<150&&(this.camera.position.y+=1)}takeDamage(e){return e-this.lastDamageTakenTime>2e3&&(this.health=this.health-1,this.ui.setFelixHP(this.health),this.lastDamageTakenTime=e,Ub([1,0,0],.2,.001),Wv(400),hN.play(),this.health===0)?(wN.play(),this.ui.setGameOver(),mu(),!0):!1}heal(e){this.health+=e,this.health=Math.min(this.health,this.maxHealth),this.ui.setFelixHP(this.health)}}const Im=(n,e,t,i,r=!1)=>{var s,o;r&&((s=n.parent)==null||s.localToWorld(n.position)),n.position.sub(e),n.position.applyAxisAngle(t,i),n.position.add(e),r&&((o=n.parent)==null||o.worldToLocal(n.position)),n.rotateOnAxis(t,i)},Nm=new B(0,0,0),Fm=new B(0,1,0);class sG{constructor(e){this.timeElapsed=0,this.minuteHand=new dt(new Ji(260,5,5),new el({color:0})),this.secondsHand=new dt(new Ji(280,5,5),new el({color:7798784,shininess:100})),this.mSecondsHand=new dt(new Ji(300,3,.2),new Fn({color:7798835})),this.minuteHand.rotation.y=-Math.PI/2,this.minuteHand.position.z=-260/2,this.minuteHand.position.y=1,this.secondsHand.rotation.y=-Math.PI/2,this.secondsHand.position.z=-280/2,this.mSecondsHand.rotation.y=-Math.PI/2,this.mSecondsHand.position.z=-300/2,this.startTime=e,this.lastTime=e,this.update=Hb(this.update.bind(this),3)}update(e){const t=e-this.lastTime;this.lastTime=e;const i=-Math.PI*2/(60*60),r=-Math.PI*2/(60*60*12),s=-Math.PI*2/60/4,o=t/16.667;this.timeElapsed+=t;const a=r*o,l=i*o,c=s*o;Im(this.secondsHand,Nm,Fm,l,!0),Im(this.minuteHand,Nm,Fm,a,!0),Im(this.mSecondsHand,Nm,Fm,c,!0)}}var oG="/assets/tuba_man.6bfad5bf.png",aG="/assets/wine_bottle.dda38189.png",lG="/assets/steggodog.0b43323a.png",cG="/assets/roman_soldier.bc1f9735.png",uG="/assets/mammoth.6ab37b2f.png",hG="/assets/chimney_sweep.7fdc3a46.png",dG="/assets/flapper_cat.f35d9843.png",fG="/assets/smoke_stack.a0925597.png",pG="/assets/t_rex.f91df3ce.png",mG="/assets/cave_cat.209e7ae0.png",gG="/assets/ostrich.8edf5f6f.png",vG="/assets/rats.764cbc0b.png",_G="/assets/steam_engine.181c39b7.png",xG="/assets/treble_clef.97fca421.png",yG="/assets/viking_cat.f7126756.png",MG="/assets/war_elephant.af36aa81.png";const vr=new fe,ac=new B,SG=new B(0,1,0);class wG{constructor({textureUrl:e,width:t,height:i,frameAmount:r,animationSpeed:s,health:o,speed:a=5,hitboxPaddingX:l=0,hitboxPaddingY:c=0,increasedRarity:u=0}){this.health=15,this.stun=0,this.isDead=!1,this.hitCache=new Map,this.reverseFlip=!1,this.sprite=new $v(e,t,i,20,r,s),this.health=o,this.object=this.sprite.mesh,this.width=t,this.height=i,this.speed=a,this.hitboxPaddingX=l,this.hitboxPaddingY=c,this.increasedRarity=u,ac.set(0,0,1),ac.applyAxisAngle(SG,Ze.randFloat(0,Math.PI*2)),ac.multiplyScalar(275),this.object.position.x=ac.x,this.object.position.z=ac.z}setReverseFlip(){this.reverseFlip=!0}moveTowards(e,t,i,r=1){if(this.stun>0){this.object.position.x+=Ze.randFloat(-1,1),this.object.position.z+=Ze.randFloat(-1,1),this.stun-=i,this.sprite.setRed();return}else this.sprite.setWhite(),this.stun=0;vr.set(e.x-this.object.position.x,e.y-this.object.position.z),vr.normalize(),vr.divideScalar(this.speed),vr.multiplyScalar(r);const s=i/16.667;vr.multiplyScalar(s),this.object.position.x+=vr.x,this.object.position.z+=vr.y,this.reverseFlip?this.sprite.update(t,vr.x>0,!0):this.sprite.update(t,vr.x<0,!0)}takeDamage(e,t,i){const r=this.hitCache.get(t);if(r){const{untilNextAllowableHit:s,time:o}=r;if(i-o<s)return null}return this.hitCache.set(t,{time:i,untilNextAllowableHit:t.hitDelay}),this.health=this.health-e,this.stun+=t.stunValue,this.health<0}collidesWith(e){const{x:t,z:i}=this.sprite.mesh.position;return!(!(Math.abs(t-e.x)<(this.width+this.hitboxPaddingX)/2)||!(Math.abs(i-e.y)<(this.height+this.hitboxPaddingY)/2))}}const Ul=[{name:"Steggodog",textureUrl:lG,width:30,height:30*.45,frameAmount:3,era:"stoneage",reverseFlip:!0,animationSpeed:50,health:7,speed:1.5},{name:"T-Rex",textureUrl:pG,width:50*1.4,height:50,frameAmount:4,era:"stoneage",reverseFlip:!0,animationSpeed:1e3,health:25,speed:3,increasedRarity:.2,hitboxPaddingY:-5,hitboxPaddingX:-5},{name:"Mammoth",textureUrl:uG,width:80,height:80*.93,frameAmount:4,era:"stoneage",reverseFlip:!0,animationSpeed:1e3,health:50,speed:7,increasedRarity:.4,hitboxPaddingY:-10},{name:"Cave Cat",textureUrl:mG,width:25,height:25,frameAmount:6,era:"stoneage",reverseFlip:!1,animationSpeed:1e3,health:15,speed:3},{name:"Roman Soldier",textureUrl:cG,width:32*.5,height:32,frameAmount:4,era:"ancient",reverseFlip:!0,animationSpeed:100,health:25,increasedRarity:.2,speed:3},{name:"Ostrich",textureUrl:gG,width:40*.762,height:40,frameAmount:4,era:"ancient",reverseFlip:!0,animationSpeed:1e3,health:30,speed:2,increasedRarity:.1,hitboxPaddingY:-5},{name:"Viking Cat",textureUrl:yG,width:25*.75,height:25,frameAmount:6,era:"ancient",reverseFlip:!1,animationSpeed:500,health:20,speed:2.5},{name:"War Elephant",textureUrl:MG,width:60*1.26,height:60,frameAmount:4,era:"ancient",reverseFlip:!0,animationSpeed:500,health:55,speed:5,increasedRarity:.4,hitboxPaddingY:-15,hitboxPaddingX:-5},{name:"Chimney Sweep",textureUrl:hG,width:20,height:20,frameAmount:6,era:"industrial",animationSpeed:100,health:30,speed:2},{name:"Smoke Stack",textureUrl:fG,width:50*1.5,height:50,frameAmount:3,era:"industrial",animationSpeed:50,health:80,speed:3.5,reverseFlip:!0,increasedRarity:.4,hitboxPaddingX:-30,hitboxPaddingY:-10},{name:"Rats",textureUrl:vG,width:20*1.332,height:20,frameAmount:2,era:"industrial",animationSpeed:100,health:20,speed:2},{name:"Steam Engine",textureUrl:_G,width:45*2.245,height:45,frameAmount:3,era:"industrial",animationSpeed:50,health:90,speed:5,reverseFlip:!0,increasedRarity:.2,hitboxPaddingX:-5,hitboxPaddingY:-5},{name:"Flapper",textureUrl:dG,width:32*.67,height:32,frameAmount:4,era:"prohibition",animationSpeed:500,health:60,speed:2,reverseFlip:!0,hitboxPaddingY:-2},{name:"Tuba Guy",textureUrl:oG,width:55*.878571429,height:55,frameAmount:4,era:"prohibition",animationSpeed:500,health:150,speed:4,increasedRarity:.5,hitboxPaddingX:-2},{name:"Wine Bottle",textureUrl:aG,width:20*.3125,height:20,frameAmount:5,era:"prohibition",animationSpeed:200,health:15,speed:2.5,hitboxPaddingY:-2},{name:"Trouble Clef",textureUrl:xG,width:40*.49,height:40,frameAmount:3,era:"prohibition",animationSpeed:750,reverseFlip:!0,health:100,increasedRarity:.2,speed:3.5,hitboxPaddingY:-5}],qb=(n=Ul)=>{const e=Ze.randInt(0,n.length-1);return n[e].name},Cu={};Cu.stoneage=Ul.filter(n=>n.era==="stoneage");Cu.ancient=Ul.filter(n=>n.era==="ancient");Cu.industrial=Ul.filter(n=>n.era==="industrial");Cu.prohibition=Ul.filter(n=>n.era==="prohibition");const EG=n=>{const e=Cu[n];if(!e)throw new Error("Unknown era "+n);return qb(e)};class Um extends wG{constructor(e){const t=Ul.find(i=>i.name===e);if(!t)throw new Error(`Asking to make unknown enemy: ${e}`);super(t),t.reverseFlip===!0&&this.setReverseFlip()}}const ts=new fe,bG=new fe(1,0);class _S{constructor(e,t){this.health=20,this.stun=0,this.isDead=!1,this.hitCache=new Map,this.object=t,this.minute=e}moveTowards(e,t,i){if(this.stun>0){this.object.position.x+=Ze.randFloat(-1,1),this.object.position.z+=Ze.randFloat(-1,1),this.stun-=i,this.object.material.color=new we(1,0,0);return}else this.stun!==0&&(this.object.material.color=new we(0,0,0),this.stun=0);const r=i/16.667;this.object.position.y<30&&(this.object.position.y+=r/4),ts.set(e.x-this.object.position.x,e.y-this.object.position.z),ts.normalize();const s=Math.acos(ts.dot(bG));ts.divideScalar(4.5),ts.multiplyScalar(r),this.object.rotation.y=ts.y>0?-s:s,this.object.position.y>15&&(this.object.position.x+=ts.x,this.object.position.z+=ts.y,this.object.rotation.x+=r/10)}takeDamage(e,t,i){const r=this.hitCache.get(t);if(r){const{untilNextAllowableHit:s,time:o}=r;if(i-o<s)return null}return this.hitCache.set(t,{time:i,untilNextAllowableHit:t.hitDelay}),this.health=this.health-e,this.stun+=t.stunValue,this.health<0}collidesWith(e,t=0){const{x:i,z:r}=this.object.position;return!(!(Math.abs(i-t-e.x)<30/2)||!(Math.abs(r-t-e.y)<30/2))}}class TG{constructor(){const e=window.getDOMOne("#damage-numbers-plane");this.element=e,this.animations=[],this.runAnimations()}convertViewportXYToDOMOffset(e,t,i,r){return{left:i/2+i/2*e,top:r/2-r/2*t}}addToLoop(e,t){this.animations.push({entryTime:Date.now(),fn:e,el:t})}runAnimations(){const e=Date.now();this.animations.forEach(({entryTime:t,fn:i,el:r})=>{const s=e-t;i(s),s>2e3&&(this.animations=this.animations.filter(o=>o.fn!==i),r.remove())}),window.requestAnimationFrame(()=>this.runAnimations())}showNumber(e,t,i){const r=document.createElement("span");r.classList.add("damage-number"),r.innerText=e.toString();const s=this.element.clientWidth,o=this.element.clientHeight,a=this.convertViewportXYToDOMOffset(t,i,s,o);a.left+=Ze.randInt(-30,30),a.left=Ze.clamp(a.left,0,s),a.top=Ze.clamp(a.top,0,o),r.style.opacity="1",r.style.top=`${a.top}px`,r.style.left=`${a.left}px`,this.addToLoop(l=>{r.style.top=`${a.top-l*.2}px`,r.style.left=`${a.left-Math.sin(l/40)*10}px`,r.style.opacity=Math.cos(l/1e3).toString()},r),this.element.appendChild(r)}}const xS=new B;class AG{constructor(e,t){this.gemPickupDistance=30,this.gemRareChance=0,this.scene=e,this.ui=t}createGemMesh(e){return new dt(new b0(3,.5,16,100),new Fn({color:e}))}increaseGemPickupDistance(e){this.gemPickupDistance+=e}increaseRareChance(e){this.gemRareChance+=e}placeGem(e,t,i){const r=new yt;let s=Math.random();s+=this.gemRareChance,s+=i;let o=0;s>.9&&(o=1),s>.98&&(o=2);const a=[{color:new we(0,0,0),amount:1},{color:new we(0,0,1),amount:5},{color:new we(.5,0,.7),amount:10}],l=this.createGemMesh(a[o].color);r.add(l),r.position.x=e,r.position.z=t,r.position.y=5,r.rotation.x=-1.5,this.scene.add(r);let c=!1;return Hb((u,h)=>{const d=Ze.randFloat(.1,Math.PI);if(r.rotation.y+=d,r.rotation.x+=d/Ze.randInt(1,10),c===!0)if(xS.set(h.x-r.position.x,5,h.y-r.position.z),r.position.add(xS.normalize().multiplyScalar(5)),yn(2,r.position.x,h.x,r.position.z,h.y)){const p=a[o];return Ub(p.color.toArray(),.02,1e-4),this.scene.remove(r),this.ui.addXP(p.amount),o===0?MN.play():SN.play(),!0}else return!1;else return yn(this.gemPickupDistance,h.x,r.position.x,h.y,r.position.z)&&(c=!0),!1},2)}playBaggingEffect(e,t,i,r){const o=new Array(Math.min(t,100)).fill(null).map(()=>this.createGemMesh(new we(0,0,0))).map(l=>({mesh:l,delay:Ze.randFloat(0,1)})),a=50;o.forEach(({mesh:l,delay:c})=>{setTimeout(()=>{const{x:u,y:h}=i.getPosition();l.position.y=20,l.position.x=u+Ze.randInt(-a,a),l.position.z=h+Ze.randInt(-a,a);const d=new B().subVectors(r,l.position);d.normalize().multiplyScalar(5),e.add(l);const p=setInterval(()=>{l.position.add(d)},17);setTimeout(()=>{clearInterval(p)},2e3)},c*1500)})}}class CG{constructor(e){this.scene=e}getPickupMesh(){return new dt(new Ji(10,10,10),new Ls({color:16776960}))}dropBagForPickup(e){const t=this.getPickupMesh();return this.scene.add(t),t.position.copy(e),t}detectPickups(e,t){return e.filter(i=>yn(20,i.position.x,t.x,i.position.z,t.y))}}const RG=n=>new Array(n).fill("").map((e,t)=>t),LG=["stoneage","ancient","industrial","prohibition"],PG={stoneage:gN,ancient:vN,industrial:_N,prohibition:xN};class DG{constructor(e,t,i,r,s,o){this.allEnemies=[],this.allWeapons=[],this.canonicalGameMinute=0,this.arsenal=new Map,this.tick=-1,this.bagCollection=[],this.gemFnCollection=[],this.weaponDamageScalar=1,this.enemyMovementScalar=1,this.lastTimeUpdateFramesAgo=0,this.endingSequenceBeginTime=null,this.endingStarted=!1,this.endingFightStartTime=null,this.specificWeaponScalars={},this.cancelTempUpgradeFns=[],this.scaleMinuteForTesting=1,this.currentSong=Iy,this.extraPickupsSafeguard={},this.startTime=e,this.scene=t,this.felix=i,this.ui=r,this.clockNumMeshes=s,this.damageNumbers=new TG,this.baggie=new CG(this.scene),this.gemsManager=new AG(this.scene,this.ui),this.increaseSpeed=o}makeEraEnemy(e){const t=new Um(EG(e));this.scene.add(t.object),this.allEnemies.push(t)}makeAnyEnemy(){const e=new Um(qb());this.scene.add(e.object),this.allEnemies.push(e)}makeEnemyWithName(e){const t=new Um(e);return this.scene.add(t.object),this.allEnemies.push(t),t}getCurrentMinute(e){return Math.floor(e/(1e3*(60*this.scaleMinuteForTesting)))}getCurrentEra(e){const t=1e3*(60*this.scaleMinuteForTesting)*3,i=e-this.startTime,r=Math.floor(i/t);return LG[r]}addWeapon(e){this.scene.add(e.group),this.allWeapons.push(e)}provideClockWeapons(e){this.arsenal=e}activateWeapon(e,t=1){const i=this.arsenal.get(e);if(!i)throw new Error(`Failure to activate unknown weapon: ${e}`);e===5?(this.felix.maxHealth=5,this.felix.health+=1,this.ui.setFelixHP(this.felix.health),this.ui.increaseFelixMaxHP()):e===7&&this.gemsManager.increaseGemPickupDistance(30),this.addWeapon(i),this.specificWeaponScalars[e]=t}activateMinuteReached(e,t){e===12&&(this.endingSequenceBeginTime=t,this.ui.startEndingSequence()),this.canonicalGameMinute=e;const i=this.createClockNumberEnemy(),r=this.ui.getGameState().currentXp;this.gemsManager.playBaggingEffect(this.scene,r,this.felix,i.object.position),this.ui.storeCurrentXPInBag(this.canonicalGameMinute);const s=this.getCurrentEra(t),o=PG[s];o&&o.play()}createClockNumberEnemy(){const e=this.canonicalGameMinute===12?0:this.canonicalGameMinute,t=this.clockNumMeshes[e],i=new _S(this.canonicalGameMinute,t);return this.allEnemies.push(i),i}runEndingTick(e){if(this.endingSequenceBeginTime&&this.endingStarted){this.endingFightStartTime===null&&(this.endingFightStartTime=e);const t=Math.floor(e/1e3);if(t>this.tick){const i=e-this.endingFightStartTime,r=60*1e3-i;this.tick=t,this.ui.setTime(r,!0),i>60*1e3?(mu(),Xp.pause(),this.ui.storeCurrentXPInBag(13),this.currentSong.pause(),this.ui.showVictoryScreen()):(this.makeAnyEnemy(),this.makeAnyEnemy(),this.makeAnyEnemy(),this.makeAnyEnemy())}}}runWorldTick(e){if(this.endingSequenceBeginTime!==null)return this.runEndingTick(e);const t=10;this.lastTimeUpdateFramesAgo===t?(this.ui.setTime(e),this.lastTimeUpdateFramesAgo=0):this.lastTimeUpdateFramesAgo++,this.tick===1?this.ui.setEraMessage("Prehistoric Era"):this.tick===60*3?this.ui.setEraMessage("Ancient History"):this.tick===60*6?this.ui.setEraMessage("Industrial Revolution"):this.tick===60*9&&this.ui.setEraMessage("1920s"),this.tick>1&&this.tick<5?(this.currentSong=Iy,this.currentSong.play()):this.tick===181*1?(this.currentSong.pause(),this.currentSong=EN,this.currentSong.play()):this.tick===181*2?(this.currentSong.pause(),this.currentSong=bN,this.currentSong.play()):this.tick===181*3&&(this.currentSong.pause(),this.currentSong=TN,this.currentSong.play());const i=this.getCurrentMinute(e);if(i>this.canonicalGameMinute){this.activateMinuteReached(i,e);return}const r=Math.floor(e/1e3);if(r>this.tick&&(this.tick=r,this.tick%5===0)){const s=this.getCurrentEra(e);Math.random()<.7?RG(this.tickToEnemyRate(this.tick)).forEach(()=>this.makeEraEnemy(s)):this.activateFunEraEvent(s)}}tickToEnemyRate(e){return e<20?1:e<180?2:e<300?3:e<480?4:e<600?5:e<645?6:7}activateFunEraEvent(e){e==="stoneage"?mc([()=>{const i=[this.makeEnemyWithName("Cave Cat"),this.makeEnemyWithName("Cave Cat"),this.makeEnemyWithName("Cave Cat")];i[1].object.position.copy(i[0].object.position),i[1].object.position.x+=30,i[2].object.position.copy(i[0].object.position),i[2].object.position.z+=30},()=>{this.makeEnemyWithName("Steggodog"),this.makeEnemyWithName("Steggodog"),this.makeEnemyWithName("Steggodog"),this.makeEnemyWithName("Steggodog"),this.makeEnemyWithName("Steggodog")}])[0]():e==="ancient"?mc([()=>{const i=[this.makeEnemyWithName("Ostrich"),this.makeEnemyWithName("Ostrich"),this.makeEnemyWithName("Ostrich"),this.makeEnemyWithName("Ostrich"),this.makeEnemyWithName("Ostrich"),this.makeEnemyWithName("Ostrich")];i.forEach(r=>{r.object.position.copy(i[0].object.position),r.object.position.x+=Ze.randInt(-70,70),r.object.position.z+=Ze.randInt(-70,70)})},()=>{this.makeEnemyWithName("Roman Soldier"),this.makeEnemyWithName("Roman Soldier"),this.makeEnemyWithName("Roman Soldier"),this.makeEnemyWithName("Roman Soldier"),this.makeEnemyWithName("Roman Soldier"),this.makeEnemyWithName("Viking Cat"),this.makeEnemyWithName("Viking Cat"),this.makeEnemyWithName("Viking Cat"),this.makeEnemyWithName("Viking Cat"),this.makeEnemyWithName("Viking Cat"),this.makeEnemyWithName("Viking Cat")}])[0]():e==="industrial"?mc([()=>{const i=[this.makeEnemyWithName("Steam Engine"),this.makeEnemyWithName("Steam Engine")];i.forEach(r=>{r.object.position.copy(i[0].object.position),r.object.position.x+=Ze.randInt(-100,100),r.object.position.z+=Ze.randInt(-100,100)})},()=>{this.makeEnemyWithName("Chimney Sweep"),this.makeEnemyWithName("Chimney Sweep"),this.makeEnemyWithName("Chimney Sweep"),this.makeEnemyWithName("Chimney Sweep"),this.makeEnemyWithName("Chimney Sweep"),this.makeEnemyWithName("Chimney Sweep"),this.makeEnemyWithName("Chimney Sweep"),this.makeEnemyWithName("Chimney Sweep"),this.makeEnemyWithName("Chimney Sweep"),this.makeEnemyWithName("Chimney Sweep"),this.makeEnemyWithName("Chimney Sweep")},()=>{this.makeEnemyWithName("Rats"),this.makeEnemyWithName("Rats"),this.makeEnemyWithName("Rats"),this.makeEnemyWithName("Rats")}])[0]():e==="prohibition"&&mc([()=>{const i=[this.makeEnemyWithName("Flapper"),this.makeEnemyWithName("Flapper"),this.makeEnemyWithName("Flapper"),this.makeEnemyWithName("Flapper"),this.makeEnemyWithName("Flapper"),this.makeEnemyWithName("Flapper"),this.makeEnemyWithName("Flapper"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle")];i.forEach(r=>{r.object.position.copy(i[0].object.position),r.object.position.x+=Ze.randInt(-100,100),r.object.position.z+=Ze.randInt(-100,100)})},()=>{const i=[this.makeEnemyWithName("Tuba Guy"),this.makeEnemyWithName("Tuba Guy"),this.makeEnemyWithName("Tuba Guy"),this.makeEnemyWithName("Trouble Clef"),this.makeEnemyWithName("Trouble Clef"),this.makeEnemyWithName("Trouble Clef"),this.makeEnemyWithName("Trouble Clef"),this.makeEnemyWithName("Trouble Clef"),this.makeEnemyWithName("Trouble Clef")];i.forEach(r=>{r.object.position.copy(i[0].object.position),r.object.position.x+=Ze.randInt(-50,50),r.object.position.z+=Ze.randInt(-50,50)})},()=>{const i=[this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle"),this.makeEnemyWithName("Wine Bottle")];i.forEach(r=>{r.object.position.copy(i[0].object.position),r.object.position.x+=Ze.randInt(-100,100),r.object.position.z+=Ze.randInt(-100,100)})}])[0]()}runWeaponMovement(e,t,i){this.allWeapons.forEach(r=>r.update(e,t,i,this.allEnemies))}processWeaponCollisions(e,t,i){let r=!1;return this.allWeapons.forEach(s=>{if(s.detectCollision(e,t)){let a=Ze.randInt(s.minDamage,s.maxDamage);if(s.minute){const c=this.specificWeaponScalars[s.minute];if(typeof c=="undefined")throw new Error("Missing weapon scalar??");a*=c}a*=this.weaponDamageScalar,a=Math.ceil(a);const l=e.takeDamage(a,s,t);if(l!==null){const c=e.object.position.clone(),{x:u,y:h}=c.project(this.felix.camera);if(this.damageNumbers.showNumber(a,u,h),s.onEnemyCollide(e),l){if(e.object.visible=!1,requestAnimationFrame(()=>{this.scene.remove(e.object)}),i.push(e),e instanceof _S){const d=this.baggie.dropBagForPickup(e.object.position);this.bagCollection.push({mesh:d,forMinute:e.minute})}else this.gemFnCollection.push(this.gemsManager.placeGem(e.object.position.x,e.object.position.z,e.increasedRarity));r=!0}}}}),r}processFelixCollision(e,t){const i=this.felix.getPosition();e.collidesWith(i)&&this.felix.takeDamage(t)&&(this.currentSong.pause(),Xp.pause())}applyGeneralUpgrade(e,t){switch(this.cancelTempUpgradeFns.forEach(i=>i()),this.cancelTempUpgradeFns=[],e){case"MORE_SPEED":this.increaseSpeed(.2*t);break;case"MORE_WEAPON_DAMAGE":this.weaponDamageScalar+=.25*t;break;case"HEAL_NOW":this.felix.heal(Math.floor(1*t));break;case"SLOWER_ENEMIES":this.enemyMovementScalar-=.1*t,this.cancelTempUpgradeFns.push(()=>{this.enemyMovementScalar=1});break;case"PICK_UP_RANGE":this.gemsManager.increaseGemPickupDistance(7.5*t);break;case"FREEZE":this.allEnemies.forEach(i=>{i.stun+=15e3*t});break;case"LUCKY":this.gemsManager.increaseRareChance(.1*t);break;default:throw new Error(`Unknown upgrade id ${e}`)}}getExpectedXPForMinute(e){const t={"1":40,"2":50,"3":60,"4":70,"5":80,"6":90,"7":100,"8":120,"9":140,"10":160,"11":180,"12":200},i=1;return Object.keys(t).forEach(r=>{t[r]=t[r]*i}),t[e.toString()]}processPickups(e,t){const i=[];this.gemFnCollection.forEach(s=>{s(e,t)===!0&&i.push(s)}),this.gemFnCollection=this.gemFnCollection.filter(s=>!i.includes(s));const r=this.bagCollection.filter(s=>this.baggie.detectPickups([s.mesh],t).length===1);if(r.length>0){const s=r[0];this.extraPickupsSafeguard[s.forMinute]===!0?(this.bagCollection=this.bagCollection.filter(o=>o!==s),this.scene.remove(s.mesh)):(this.extraPickupsSafeguard[s.forMinute]=!0,this.bagCollection=this.bagCollection.filter(o=>o!==s),this.scene.remove(s.mesh),mu(),this.currentSong.pause(),$p.play(),yN.play(),this.ui.showUpgradeScreen(s.forMinute,this.getExpectedXPForMinute(s.forMinute),(o,a,l)=>{o?(this.activateWeapon(s.forMinute,l),this.ui.addChosenWeapon(s.forMinute)):a&&this.applyGeneralUpgrade(a,l),this.ui.hideUpgradeScreen(),s.forMinute===12?setTimeout(()=>{this.endingStarted=!0,this.ui.setEraMessage("Survive for one minute!"),this.currentSong.pause(),$p.pause(),Xp.play(),r0()},200):setTimeout(()=>{this.currentSong.play(),$p.pause(),r0()},200)}))}}update(e,t){const i=this.felix.getPosition();this.runWeaponMovement(e,t,i);const r=[];this.allEnemies.forEach(s=>{if(s.object.visible===!1)return;this.processWeaponCollisions(s,e,r)||(s.moveTowards(i,e,t,this.enemyMovementScalar),s.stun<=0&&this.processFelixCollision(s,e))}),r.forEach(s=>{s.isDead=!0}),r.length>0&&(this.allEnemies=this.allEnemies.filter(s=>!r.includes(s))),this.processPickups(e,i),this.runWorldTick(e)}}window.ZERO_VEC3=new B(0,0,0);window.RED=new we(16711680);window.BLUE=new we(255);window.HYPER_BLUE=new we(11206655);const IG=n=>{const e=document.querySelector(n);if(!e)throw new Error(`Couldn't find ${n}. :/`);return e};window.getDOMOne=IG;const va=gU(),Mt=new p0;let yS=!1,pa=[];const lc=new B,NG=()=>new el({color:new we(.7,.7,.7),shininess:500}),Yb=(n,e)=>{const t=n.children.find(i=>i.name===e);if(!t)throw new Error(`Crash error for unknown model name ${e}`);if(!(t instanceof dt))throw new Error("Found non-mesh by name");return t},FG=(n,e)=>{const i=["Twelve","One","Two","Three","Four","Five","Six","Seven","Eight","Nine","Ten","Eleven"].map(o=>`${o}Normal`).map(o=>{const a=Yb(e,o).clone();return a.position.set(0,0,0),a.scale.set(2,2,2),a}),r=275,s=[];for(let o=0;o<12;o++){const a=i[o].clone();Array.isArray(a.material)||(new Ls().copy(a.material),a.material=a.material.clone());const l=-Math.PI/2+Math.PI/6*o;a.position.z=Math.sin(l)*r,a.position.x=Math.cos(l)*r,a.rotation.y=o*(-Math.PI/6)+Math.PI/2,n.add(a),s.push(a)}return s},UG=n=>["One","Two","Three","Four","Five","Six","Seven","Eight","Nine","Ten","Eleven","Twelve"].map(t=>`${t}Weapon`).map(t=>Yb(n,t)),OG=async()=>{const e=(await KU())[0].scene;e.scale.set(2,2,2);const t=new Fs,i=18,r=new $v(iG,i*.69,i,5,6,175/2),s=new rG(r,Mt,va);qH(Mt,s.camera,(o,a)=>{if(yS===!1){yS=!0;const l=new yw(16777215,1);Mt.add(l);const c=new vu(300,300,2,12,2);let u=NG();const h=new dt(c,u);h.name="ground",c.computeBoundingSphere();const d=c.boundingSphere;d&&(d.radius=d.radius*.975),h.rotation.z=Math.PI,Mt.add(h);const p=FG(Mt,e);Mt.add(r.mesh);let v=!1,m=!1,f=1.3,g=!1;pa.push(()=>{if(t.escapeDown){if(g===!0||va.getGameState().onUpgradeScreen!==null)return;g=!0,setTimeout(()=>{g=!1},500),va.showPauseScreen(),_.currentSong.pause(),mu(!0,()=>{if(t.escapeDown){if(g===!0)return;g=!0,setTimeout(()=>{g=!1},500),va.hidePauseScreen(),_.currentSong.play(),r0()}})}}),pa.push((P,k)=>{const Y=k/16.66667;let j=0,K=0;const ce=f*Y;t.dDown&&(j+=ce),t.aDown&&(j-=ce),t.wDown&&(K-=ce),t.sDown&&(K+=ce),j!==0||K!==0?(lc.copy(r.mesh.position),lc.x+=j,lc.z+=K,d&&d.containsPoint(lc)?(v=!0,r.mesh.position.copy(lc),j!==0&&(m=j<0)):v=!1):v=!1;const de=10;v&&K!==0?K>0?m?r.mesh.rotation.z=Math.PI/de:r.mesh.rotation.z=-Math.PI/de:K<0&&(m?r.mesh.rotation.z=-Math.PI/de:r.mesh.rotation.z=Math.PI/de):r.mesh.rotation.z=0}),pa.push(P=>{s.runUpdate(P),r.update(P,m,v)});const _=new DG(o,Mt,s,va,p,P=>{f+=P}),M=new Vb;Mt.add(M.group),_.addWeapon(M);const E=UG(e),S=new Xv(E[0],Mt),T=new $b(E[1],Mt),R=new YH(E[2],Mt),x=new KH(E[3],Mt),A=new ZH(E[4],Mt),I=new JH(E[5],Mt),N=new QH(E[6],Mt),J=new eG(E[7],Mt),q=new tG(E[8],Mt),L=new Xb(E[9],Mt),$=new jb(E[10],Mt),z=new nG(E[11],Mt),W=new Map;W.set(1,S),W.set(2,T),W.set(3,R),W.set(4,x),W.set(5,A),W.set(6,I),W.set(7,N),W.set(8,J),W.set(9,q),W.set(10,L),W.set(11,$),W.set(12,z),_.provideClockWeapons(W),pa.push((P,k)=>{_.update(P,k)});const U=new sG(o);Mt.add(U.secondsHand),Mt.add(U.minuteHand),Mt.add(U.mSecondsHand),pa.push(P=>{U.update(P)})}pa.forEach(l=>l(o,a))})};va.provideStartGame(OG);
